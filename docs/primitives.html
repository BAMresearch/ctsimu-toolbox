<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>ctsimu.primitives API documentation</title>
<meta name="description" content="Structures for linear algebra and geometry: vectors, matrices, lines and polygons.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.primitives</code></h1>
</header>
<section id="section-intro">
<p>Structures for linear algebra and geometry: vectors, matrices, lines and polygons.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctsimu.primitives.rotation_matrix"><code class="name flex">
<span>def <span class="ident">rotation_matrix</span></span>(<span>axis: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>,<br>angle: float) ‑> <a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_matrix(axis:&#39;Vector&#39;, angle:float) -&gt; &#39;Matrix&#39;:
    &#34;&#34;&#34;A matrix that performs a 3D vector rotation around the
    given `axis` vector by the given `angle` (in rad).

    Note that this is only a rotation matrix; translations
    are not taken into account. This means that the pivot point
    will always be the origin of the object that you rotate, i.e.,
    the rotation axis vector is attached to the object&#39;s origin.

    Parameters
    ----------
    axis : Vector
        Rotation axis. Must not be a unit vector.

    angle : float
        Rotation angle.

    Returns
    -------
    R : Matrix
        Rotation matrix.
    &#34;&#34;&#34;
    R = Matrix(3, 3)
    cs = math.cos(angle)
    sn = math.sin(angle)

    nx = axis.unit_vector().x()
    ny = axis.unit_vector().y()
    nz = axis.unit_vector().z()

    # Row 1:
    R.value[0][0] = nx*nx*(1.0-cs) + cs
    R.value[0][1] = nx*ny*(1.0-cs) - nz*sn
    R.value[0][2] = nx*nz*(1.0-cs) + ny*sn

    # Row 2:
    R.value[1][0] = ny*nx*(1.0-cs) + nz*sn
    R.value[1][1] = ny*ny*(1.0-cs) + cs
    R.value[1][2] = ny*nz*(1.0-cs) - nx*sn

    # Row 3:
    R.value[2][0] = nz*nx*(1.0-cs) - ny*sn
    R.value[2][1] = nz*ny*(1.0-cs) + nx*sn
    R.value[2][2] = nz*nz*(1.0-cs) + cs

    return R</code></pre>
</details>
<div class="desc"><p>A matrix that performs a 3D vector rotation around the
given <code>axis</code> vector by the given <code>angle</code> (in rad).</p>
<p>Note that this is only a rotation matrix; translations
are not taken into account. This means that the pivot point
will always be the origin of the object that you rotate, i.e.,
the rotation axis vector is attached to the object's origin.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Rotation axis. Must not be a unit vector.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code></dt>
<dd>Rotation matrix.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.primitives.Line2D"><code class="flex name class">
<span>class <span class="ident">Line2D</span></span>
<span>(</span><span>m: float = None, n: float = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Line2D:
    &#34;&#34;&#34;A mathematical line in 2D space, with a slope and an offset.

    `y = m*x + n`

    Attributes
    ----------
    m : float
        Slope

    n : float
        Vertical offset (i.e., intersection with y axis)
    &#34;&#34;&#34;

    def __init__(self, m:float=None, n:float=None):
        &#34;&#34;&#34;Initialize with specified slope and offset (both optional).

        Parameters
        ----------
        m : float, optional
            Slope

        n : float, optional
            Vertical offset (i.e., intersection with y axis)
        &#34;&#34;&#34;

        self.m = m
        self.n = n

    def __str__(self):
        return &#34;m={}, n={}&#34;.format(self.m, self.n)

    def set(self, m:float, n:float):
        &#34;&#34;&#34;Set line parameters.

        Parameters
        ----------
        m : float
            Slope

        n : float
            Vertical offset (i.e., intersection with y axis)
        &#34;&#34;&#34;
        self.m = m
        self.n = n

    def set_from_points(self, p0:&#39;Vector&#39;, p1:&#39;Vector&#39;):
        &#34;&#34;&#34;Set line slope `m` and offset `n` from two given points `p0` and `p1`.
        Both points are assumed to be on the line.

        Parameters
        ----------
        p0 : Vector
            First point, given by 2D vector. For higher-dimensional vectors, only the first two coordinates are considered.

        p1 : Vector
            Second point, given by 2D vector. For higher-dimensional vectors, only the first two coordinates are considered.
        &#34;&#34;&#34;

        # points are defined by 2D vectors
        x0 = p0.x()
        y0 = p0.y()
        x1 = p1.x()
        y1 = p1.y()

        if x0 != x1:
            self.m = (y1-y0) / (x1-x0)
            self.n = y0 - self.m*x0
        else:
            # Vertical line
            self.m = math.inf
            self.n = x0  # Store x intersection in n if line is vertical

    def intersection(self, v:&#39;Line2D&#39;) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34;Intersection point with another line.

        Parameters
        ----------
        v : Line2D
            Another line that intersects this line.

        Returns
        -------
        intersection : Vector
            2D vector that contains the coordinates of the intersection point.

        Raises
        ------
        Exception : &#34;Lines are parallel.&#34;
            If the lines don&#39;t intersect.
        &#34;&#34;&#34;
        m0 = self.m
        n0 = self.n

        m1 = v.m
        n1 = v.n

        if m0 == m1:
            # Lines are parallel
            raise Exception(&#34;Lines are parallel.&#34;)

        if m0 != math.inf and m1 != math.inf:
            xs = (n1-n0)/(m0-m1)
            ys = m0*xs + n0
            return Vector(x=xs, y=ys)
        elif m0 == math.inf and m1 != math.inf:
            xs = n0
            ys = m1*xs + n1
            return Vector(x=xs, y=ys)
        elif m0 != math.inf and m1 == math.inf:
            xs = n1
            ys = m0*xs + n0
            return Vector(x=xs, y=ys)</code></pre>
</details>
<div class="desc"><p>A mathematical line in 2D space, with a slope and an offset.</p>
<p><code>y = m*x + n</code></p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>Slope</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>float</code></dt>
<dd>Vertical offset (i.e., intersection with y axis)</dd>
</dl>
<p>Initialize with specified slope and offset (both optional).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Slope</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Vertical offset (i.e., intersection with y axis)</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.primitives.Line2D.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self,<br>v: <a title="ctsimu.primitives.Line2D" href="#ctsimu.primitives.Line2D">Line2D</a>) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, v:&#39;Line2D&#39;) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34;Intersection point with another line.

    Parameters
    ----------
    v : Line2D
        Another line that intersects this line.

    Returns
    -------
    intersection : Vector
        2D vector that contains the coordinates of the intersection point.

    Raises
    ------
    Exception : &#34;Lines are parallel.&#34;
        If the lines don&#39;t intersect.
    &#34;&#34;&#34;
    m0 = self.m
    n0 = self.n

    m1 = v.m
    n1 = v.n

    if m0 == m1:
        # Lines are parallel
        raise Exception(&#34;Lines are parallel.&#34;)

    if m0 != math.inf and m1 != math.inf:
        xs = (n1-n0)/(m0-m1)
        ys = m0*xs + n0
        return Vector(x=xs, y=ys)
    elif m0 == math.inf and m1 != math.inf:
        xs = n0
        ys = m1*xs + n1
        return Vector(x=xs, y=ys)
    elif m0 != math.inf and m1 == math.inf:
        xs = n1
        ys = m0*xs + n0
        return Vector(x=xs, y=ys)</code></pre>
</details>
<div class="desc"><p>Intersection point with another line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="ctsimu.primitives.Line2D" href="#ctsimu.primitives.Line2D">Line2D</a></code></dt>
<dd>Another line that intersects this line.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>intersection</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>2D vector that contains the coordinates of the intersection point.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong> :&ensp;<code>"Lines are parallel."</code></dt>
<dd>If the lines don't intersect.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Line2D.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, m: float, n: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, m:float, n:float):
    &#34;&#34;&#34;Set line parameters.

    Parameters
    ----------
    m : float
        Slope

    n : float
        Vertical offset (i.e., intersection with y axis)
    &#34;&#34;&#34;
    self.m = m
    self.n = n</code></pre>
</details>
<div class="desc"><p>Set line parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>Slope</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>float</code></dt>
<dd>Vertical offset (i.e., intersection with y axis)</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Line2D.set_from_points"><code class="name flex">
<span>def <span class="ident">set_from_points</span></span>(<span>self,<br>p0: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>,<br>p1: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_from_points(self, p0:&#39;Vector&#39;, p1:&#39;Vector&#39;):
    &#34;&#34;&#34;Set line slope `m` and offset `n` from two given points `p0` and `p1`.
    Both points are assumed to be on the line.

    Parameters
    ----------
    p0 : Vector
        First point, given by 2D vector. For higher-dimensional vectors, only the first two coordinates are considered.

    p1 : Vector
        Second point, given by 2D vector. For higher-dimensional vectors, only the first two coordinates are considered.
    &#34;&#34;&#34;

    # points are defined by 2D vectors
    x0 = p0.x()
    y0 = p0.y()
    x1 = p1.x()
    y1 = p1.y()

    if x0 != x1:
        self.m = (y1-y0) / (x1-x0)
        self.n = y0 - self.m*x0
    else:
        # Vertical line
        self.m = math.inf
        self.n = x0  # Store x intersection in n if line is vertical</code></pre>
</details>
<div class="desc"><p>Set line slope <code>m</code> and offset <code>n</code> from two given points <code>p0</code> and <code>p1</code>.
Both points are assumed to be on the line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p0</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>First point, given by 2D vector. For higher-dimensional vectors, only the first two coordinates are considered.</dd>
<dt><strong><code>p1</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Second point, given by 2D vector. For higher-dimensional vectors, only the first two coordinates are considered.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="ctsimu.primitives.Matrix"><code class="flex name class">
<span>class <span class="ident">Matrix</span></span>
<span>(</span><span>cols: int = None, rows: int = None, values: list = None, numpy_data=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Matrix:
    &#34;&#34;&#34;Simple matrix class.

    Attributes
    ----------
    cols : int
        Number of matrix columns.

    rows : int
        Number of matrix rows.

    n_entries : int
        Number of matrix elements. (Computed internally whenever matrix size is set or changed.)

    value : numpy.ndarray
        NumPy array that contains the matrix values.
    &#34;&#34;&#34;

    def __init__(self, cols:int=None, rows:int=None, values:list=None, numpy_data=None):
        &#34;&#34;&#34;Initialize matrix by given size or numpy data array.

        If `cols` and `rows` are not `None`, a matrix of the given size
        will be created with all elements being zero. Otherwise,
        the matrix will be set up from the `numpy_data` array if provided.

        Parameters
        ----------
        cols : int, optional
            Number of matrix columns.

        rows : int, optional
            Number of matrix rows.

        values : list, optional
            List of lists to initialize matrix.

        numpy_data : numpy.ndarray, optional
            2-dimensional NumPy array. The number of columns and rows is determined from the array.
        &#34;&#34;&#34;

        if values is not None:
            npda = numpy.array(values)
            self.set_numpy_data_array(npda)
        elif numpy_data is not None:
            self.set_numpy_data_array(numpy_data)
        elif (cols is not None) and (rows is not None):
            self.reset(cols=cols, rows=rows)
        else:
            raise Exception(&#34;Matrix initialization failed. Number of rows and columns must be provided, or an array of values.&#34;)

    def __str__(self):
        return f&#34;{self.value}&#34;

    def __add__(self, x):
        result = self.get_copy()
        result.add(x)
        return result

    def __sub__(self, x):
        result = self.get_copy()
        result.subtract(x)
        return result

    def __mul__(self, x):
        result = self.get_copy()
        result.multiply(x)
        if isinstance(x, Vector):
            # We need to return a vector
            return Vector(numpy_data=result.value)
        
        return result

    def __truediv__(self, x):
        result = self.get_copy()
        result.divide(x)
        return result

    def __floordiv__(self, x):
        result = self.get_copy()
        result.floor_divide(x)
        return result

    def __radd__(self, x):
        return self.__add__(x)

    def __rsub__(self, x):
        if isinstance(x, numbers.Number):
            result = self.get_copy()
            result.multiply(-1)
            result.add(x)
            return result

    def __rmul__(self, x):
        if isinstance(x, numbers.Number):
            return self.__mul__(x)

    def size(self) -&gt; int:
        &#34;&#34;&#34;Get the number of matrix elements.

        Returns
        -------
        n_entries : int
            Number of matrix elements.
        &#34;&#34;&#34;
        return self.n_entries

    def same_size(self, M:&#39;Matrix&#39;) -&gt; bool:
        &#34;&#34;&#34;Check if this matrix has the same size as the given matrix `M`.

        Parameters
        ----------
        M : Matrix

        Returns
        -------
        same_size : bool
            `True` if `M` has the same number of rows and columns as this matrix, otherwise `False`.
        &#34;&#34;&#34;
        if (self.cols == M.cols) and (self.rows == M.rows):
            return True

        return False

    def reset(self, cols:int, rows:int):
        &#34;&#34;&#34;Set matrix size to given number of columns and rows, and set all matrix elements to zero.

        Parameters
        ----------
        cols : int
            Number of matrix columns.

        rows : int
            Number of matrix rows.
        &#34;&#34;&#34;
        self.cols = cols
        self.rows = rows
        self.n_entries = cols*rows
        self.value = numpy.zeros((rows, cols), dtype=numpy.float64)

    def make_identity(self):
        &#34;&#34;&#34;Make this an identity matrix.&#34;&#34;&#34;
        self.value = numpy.zeros((self.rows, self.cols), dtype=numpy.float64)
        for i in range(min(self.cols, self.rows)):
            self.value[i][i] = float(1)

    def set(self, col:int, row:int, value:float):
        &#34;&#34;&#34;Set a matrix element&#39;s value.

        Parameters
        ----------
        col : int
            The element&#39;s column position.

        row : int
            The element&#39;s row position.

        value : float
            The new value of the matrix element.
        &#34;&#34;&#34;
        self.value[row][col] = value

    def set_numpy_data_array(self, numpy_data:&#39;numpy.ndarray&#39;):
        &#34;&#34;&#34;Set up the matrix from a given NumPy array.

        Gets the number of columns and rows from the array and
        uses the array for its values.

        Warning: the array content is not copied, only referenced.
        If you change the array afterwards, the matrix content will
        change as well. Use `numpy.copy()` if you want to pass
        a copy of your array.

        Parameters
        ----------
        numpy_data : numpy.ndarray
            NumPy array of the new matrix values.
        &#34;&#34;&#34;
        self.rows = len(numpy_data)
        self.cols = len(numpy_data[0])
        self.n_entries = self.cols * self.rows
        self.value = numpy_data.astype(float)

    def update_rows_cols(self):
        &#34;&#34;&#34;Update the numbers of rows and columns based on the current shape of `self.value`.&#34;&#34;&#34;

        # Update number of rows and columns
        sh = self.value.shape
        self.rows = sh[0]
        if len(sh) &gt; 1:
            self.cols = sh[1]
        else:
            # Created a vector
            self.cols = 1

    def copy(self, x:&#39;Matrix&#39;):
        &#34;&#34;&#34;Make this matrix a copy of the given matrix `x`.

        Parameters
        ----------
        x : Matrix
            The matrix whose contents shall be copied.
        &#34;&#34;&#34;
        self.set_numpy_data_array(numpy_data=numpy.copy(x.value))

    def get(self, col:int, row:int) -&gt; float:
        &#34;&#34;&#34;Get a matrix element&#39;s value.

        Parameters
        ----------
        col : int
            Element&#39;s column position.

        row : int
            Element&#39;s row position.

        Returns
        -------
        value : float
            Value of the requested matrix element.
        &#34;&#34;&#34;
        if len(self.value) &gt; row:
            if len(self.value[row]) &gt; col:
                return self.value[row][col]

        raise Exception(f&#34;Matrix.get(col={col}, row={row}): requested index does not exist.&#34;)

    def get_copy(self) -&gt; &#39;Matrix&#39;:
        &#34;&#34;&#34;Get a copy of this matrix object.

        Returns
        -------
        copy : Matrix
            Copy of this matrix object.
        &#34;&#34;&#34;
        new_values = numpy.copy(self.value)
        return Matrix(numpy_data=new_values)

    def add(self, x):
        &#34;&#34;&#34;Add a scalar to all matrix elements, or add another compatible matrix of the same size.

        Parameters
        ----------
        x : Matrix or float
            Matrix to be added to this matrix, or scalar to be added to all matrix elements.
        &#34;&#34;&#34;
        if isinstance(x, Matrix):
            # &#39;x&#39; is another matrix:
            if self.same_size(x):
                self.value = numpy.add(self.value, x.value)
            else:
                raise Exception(&#34;Incompatible matrix sizes. Can only add matrices of same size.&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.add(self.value, x)
        else:
            raise Exception(f&#34;Matrix addition failed: M+A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def subtract(self, x):
        &#34;&#34;&#34;Subtract a scalar from all matrix elements, or subtract another compatible matrix.

        Parameters
        ----------
        x : Matrix or float
            Matrix to be subtracted from this matrix, or scalar to be subtracted from all matrix elements.
        &#34;&#34;&#34;
        if isinstance(x, Matrix):
            # &#39;x&#39; is another matrix:
            if self.same_size(x):
                self.value = numpy.subtract(self.value, x.value)
            else:
                raise Exception(&#34;Incompatible matrix sizes. Can only subtract matrices of same size.&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.subtract(self.value, x)
        else:
            raise Exception(f&#34;Matrix subtraction failed: M-A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def multiply(self, x):
        &#34;&#34;&#34;Multiply a scalar to all matrix elements, or perform matrix multiplication with a compatible matrix.

        Parameters
        ----------
        x : Matrix or float
            Compatible matrix to be multiplied with this matrix, or scalar to be multiplied to all matrix elements.
        &#34;&#34;&#34;
        if isinstance(x, Matrix) or isinstance(x, Vector):
            # &#39;x&#39; is another matrix or a vector:
            self.value = numpy.matmul(self.value, x.value)
            self.n_entries = self.value.size

            self.update_rows_cols()

        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.multiply(self.value, x)
        else:
            raise Exception(f&#34;Matrix multiplication failed: M*A is only supported when A is of type &#39;Matrix&#39; or &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def divide(self, x):
        &#34;&#34;&#34;Divide all matrix elements by a scalar, or perform element-wise division with a matrix of the same size.

        Parameters
        ----------
        x : Matrix or float
            Matrix of same size for element-wise division with this matrix, or scalar to divide all matrix elements.
        &#34;&#34;&#34;
        if isinstance(x, Matrix):
            # &#39;x&#39; is another matrix... element-wise division:
            if self.same_size(x):
                self.value = numpy.divide(self.value, x.value)
                self.n_entries = self.value.size
            else:
                raise Exception(&#34;Incompatible matrix sizes. Can only run an element-wise division for matrices of same size.&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.divide(self.value, x)
        else:
            raise Exception(f&#34;Matrix division failed: M/A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def floor_divide(self, x):
        &#34;&#34;&#34;Floor-divide all matrix elements by a scalar, or perform element-wise division with a matrix of the same size.

        Parameters
        ----------
        x : Matrix or float
            Matrix of same size for element-wise floor-division with this matrix, or scalar to floor-divide all matrix elements.
        &#34;&#34;&#34;
        if isinstance(x, Matrix):
            # &#39;x&#39; is another matrix... element-wise division:
            if self.same_size(x):
                self.value = numpy.floor_divide(self.value, x.value)
            else:
                raise Exception(&#34;Incompatible matrix sizes. Can only run an element-wise floor-division for matrices of same size.&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.floor_divide(self.value, x)
        else:
            raise Exception(f&#34;Matrix floor-division failed: M//A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def scale(self, factor:float):
        &#34;&#34;&#34;Scale matrix by a scalar factor.

        Parameters
        ----------
        factor : float
            Factor that scales all matrix elements.
        &#34;&#34;&#34;
        self.value = numpy.multiply(self.value, factor)</code></pre>
</details>
<div class="desc"><p>Simple matrix class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of matrix columns.</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of matrix rows.</dd>
<dt><strong><code>n_entries</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of matrix elements. (Computed internally whenever matrix size is set or changed.)</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>NumPy array that contains the matrix values.</dd>
</dl>
<p>Initialize matrix by given size or numpy data array.</p>
<p>If <code>cols</code> and <code>rows</code> are not <code>None</code>, a matrix of the given size
will be created with all elements being zero. Otherwise,
the matrix will be set up from the <code>numpy_data</code> array if provided.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of matrix columns.</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of matrix rows.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of lists to initialize matrix.</dd>
<dt><strong><code>numpy_data</code></strong> :&ensp;<code>numpy.ndarray</code>, optional</dt>
<dd>2-dimensional NumPy array. The number of columns and rows is determined from the array.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.primitives.Matrix.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, x):
    &#34;&#34;&#34;Add a scalar to all matrix elements, or add another compatible matrix of the same size.

    Parameters
    ----------
    x : Matrix or float
        Matrix to be added to this matrix, or scalar to be added to all matrix elements.
    &#34;&#34;&#34;
    if isinstance(x, Matrix):
        # &#39;x&#39; is another matrix:
        if self.same_size(x):
            self.value = numpy.add(self.value, x.value)
        else:
            raise Exception(&#34;Incompatible matrix sizes. Can only add matrices of same size.&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.add(self.value, x)
    else:
        raise Exception(f&#34;Matrix addition failed: M+A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Add a scalar to all matrix elements, or add another compatible matrix of the same size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code> or <code>float</code></dt>
<dd>Matrix to be added to this matrix, or scalar to be added to all matrix elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self,<br>x: <a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, x:&#39;Matrix&#39;):
    &#34;&#34;&#34;Make this matrix a copy of the given matrix `x`.

    Parameters
    ----------
    x : Matrix
        The matrix whose contents shall be copied.
    &#34;&#34;&#34;
    self.set_numpy_data_array(numpy_data=numpy.copy(x.value))</code></pre>
</details>
<div class="desc"><p>Make this matrix a copy of the given matrix <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code></dt>
<dd>The matrix whose contents shall be copied.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.divide"><code class="name flex">
<span>def <span class="ident">divide</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide(self, x):
    &#34;&#34;&#34;Divide all matrix elements by a scalar, or perform element-wise division with a matrix of the same size.

    Parameters
    ----------
    x : Matrix or float
        Matrix of same size for element-wise division with this matrix, or scalar to divide all matrix elements.
    &#34;&#34;&#34;
    if isinstance(x, Matrix):
        # &#39;x&#39; is another matrix... element-wise division:
        if self.same_size(x):
            self.value = numpy.divide(self.value, x.value)
            self.n_entries = self.value.size
        else:
            raise Exception(&#34;Incompatible matrix sizes. Can only run an element-wise division for matrices of same size.&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.divide(self.value, x)
    else:
        raise Exception(f&#34;Matrix division failed: M/A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Divide all matrix elements by a scalar, or perform element-wise division with a matrix of the same size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code> or <code>float</code></dt>
<dd>Matrix of same size for element-wise division with this matrix, or scalar to divide all matrix elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.floor_divide"><code class="name flex">
<span>def <span class="ident">floor_divide</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floor_divide(self, x):
    &#34;&#34;&#34;Floor-divide all matrix elements by a scalar, or perform element-wise division with a matrix of the same size.

    Parameters
    ----------
    x : Matrix or float
        Matrix of same size for element-wise floor-division with this matrix, or scalar to floor-divide all matrix elements.
    &#34;&#34;&#34;
    if isinstance(x, Matrix):
        # &#39;x&#39; is another matrix... element-wise division:
        if self.same_size(x):
            self.value = numpy.floor_divide(self.value, x.value)
        else:
            raise Exception(&#34;Incompatible matrix sizes. Can only run an element-wise floor-division for matrices of same size.&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.floor_divide(self.value, x)
    else:
        raise Exception(f&#34;Matrix floor-division failed: M//A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Floor-divide all matrix elements by a scalar, or perform element-wise division with a matrix of the same size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code> or <code>float</code></dt>
<dd>Matrix of same size for element-wise floor-division with this matrix, or scalar to floor-divide all matrix elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, col: int, row: int) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, col:int, row:int) -&gt; float:
    &#34;&#34;&#34;Get a matrix element&#39;s value.

    Parameters
    ----------
    col : int
        Element&#39;s column position.

    row : int
        Element&#39;s row position.

    Returns
    -------
    value : float
        Value of the requested matrix element.
    &#34;&#34;&#34;
    if len(self.value) &gt; row:
        if len(self.value[row]) &gt; col:
            return self.value[row][col]

    raise Exception(f&#34;Matrix.get(col={col}, row={row}): requested index does not exist.&#34;)</code></pre>
</details>
<div class="desc"><p>Get a matrix element's value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>Element's column position.</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Element's row position.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the requested matrix element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.get_copy"><code class="name flex">
<span>def <span class="ident">get_copy</span></span>(<span>self) ‑> <a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_copy(self) -&gt; &#39;Matrix&#39;:
    &#34;&#34;&#34;Get a copy of this matrix object.

    Returns
    -------
    copy : Matrix
        Copy of this matrix object.
    &#34;&#34;&#34;
    new_values = numpy.copy(self.value)
    return Matrix(numpy_data=new_values)</code></pre>
</details>
<div class="desc"><p>Get a copy of this matrix object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>copy</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code></dt>
<dd>Copy of this matrix object.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.make_identity"><code class="name flex">
<span>def <span class="ident">make_identity</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_identity(self):
    &#34;&#34;&#34;Make this an identity matrix.&#34;&#34;&#34;
    self.value = numpy.zeros((self.rows, self.cols), dtype=numpy.float64)
    for i in range(min(self.cols, self.rows)):
        self.value[i][i] = float(1)</code></pre>
</details>
<div class="desc"><p>Make this an identity matrix.</p></div>
</dd>
<dt id="ctsimu.primitives.Matrix.multiply"><code class="name flex">
<span>def <span class="ident">multiply</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply(self, x):
    &#34;&#34;&#34;Multiply a scalar to all matrix elements, or perform matrix multiplication with a compatible matrix.

    Parameters
    ----------
    x : Matrix or float
        Compatible matrix to be multiplied with this matrix, or scalar to be multiplied to all matrix elements.
    &#34;&#34;&#34;
    if isinstance(x, Matrix) or isinstance(x, Vector):
        # &#39;x&#39; is another matrix or a vector:
        self.value = numpy.matmul(self.value, x.value)
        self.n_entries = self.value.size

        self.update_rows_cols()

    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.multiply(self.value, x)
    else:
        raise Exception(f&#34;Matrix multiplication failed: M*A is only supported when A is of type &#39;Matrix&#39; or &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Multiply a scalar to all matrix elements, or perform matrix multiplication with a compatible matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code> or <code>float</code></dt>
<dd>Compatible matrix to be multiplied with this matrix, or scalar to be multiplied to all matrix elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, cols: int, rows: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, cols:int, rows:int):
    &#34;&#34;&#34;Set matrix size to given number of columns and rows, and set all matrix elements to zero.

    Parameters
    ----------
    cols : int
        Number of matrix columns.

    rows : int
        Number of matrix rows.
    &#34;&#34;&#34;
    self.cols = cols
    self.rows = rows
    self.n_entries = cols*rows
    self.value = numpy.zeros((rows, cols), dtype=numpy.float64)</code></pre>
</details>
<div class="desc"><p>Set matrix size to given number of columns and rows, and set all matrix elements to zero.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of matrix columns.</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of matrix rows.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.same_size"><code class="name flex">
<span>def <span class="ident">same_size</span></span>(<span>self,<br>M: <a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a>) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def same_size(self, M:&#39;Matrix&#39;) -&gt; bool:
    &#34;&#34;&#34;Check if this matrix has the same size as the given matrix `M`.

    Parameters
    ----------
    M : Matrix

    Returns
    -------
    same_size : bool
        `True` if `M` has the same number of rows and columns as this matrix, otherwise `False`.
    &#34;&#34;&#34;
    if (self.cols == M.cols) and (self.rows == M.rows):
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Check if this matrix has the same size as the given matrix <code>M</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>M</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>same_size</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if <code>M</code> has the same number of rows and columns as this matrix, otherwise <code>False</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, factor: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, factor:float):
    &#34;&#34;&#34;Scale matrix by a scalar factor.

    Parameters
    ----------
    factor : float
        Factor that scales all matrix elements.
    &#34;&#34;&#34;
    self.value = numpy.multiply(self.value, factor)</code></pre>
</details>
<div class="desc"><p>Scale matrix by a scalar factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Factor that scales all matrix elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, col: int, row: int, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, col:int, row:int, value:float):
    &#34;&#34;&#34;Set a matrix element&#39;s value.

    Parameters
    ----------
    col : int
        The element&#39;s column position.

    row : int
        The element&#39;s row position.

    value : float
        The new value of the matrix element.
    &#34;&#34;&#34;
    self.value[row][col] = value</code></pre>
</details>
<div class="desc"><p>Set a matrix element's value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>The element's column position.</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>The element's row position.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The new value of the matrix element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.set_numpy_data_array"><code class="name flex">
<span>def <span class="ident">set_numpy_data_array</span></span>(<span>self, numpy_data: numpy.ndarray)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_numpy_data_array(self, numpy_data:&#39;numpy.ndarray&#39;):
    &#34;&#34;&#34;Set up the matrix from a given NumPy array.

    Gets the number of columns and rows from the array and
    uses the array for its values.

    Warning: the array content is not copied, only referenced.
    If you change the array afterwards, the matrix content will
    change as well. Use `numpy.copy()` if you want to pass
    a copy of your array.

    Parameters
    ----------
    numpy_data : numpy.ndarray
        NumPy array of the new matrix values.
    &#34;&#34;&#34;
    self.rows = len(numpy_data)
    self.cols = len(numpy_data[0])
    self.n_entries = self.cols * self.rows
    self.value = numpy_data.astype(float)</code></pre>
</details>
<div class="desc"><p>Set up the matrix from a given NumPy array.</p>
<p>Gets the number of columns and rows from the array and
uses the array for its values.</p>
<p>Warning: the array content is not copied, only referenced.
If you change the array afterwards, the matrix content will
change as well. Use <code>numpy.copy()</code> if you want to pass
a copy of your array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>numpy_data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>NumPy array of the new matrix values.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self) -&gt; int:
    &#34;&#34;&#34;Get the number of matrix elements.

    Returns
    -------
    n_entries : int
        Number of matrix elements.
    &#34;&#34;&#34;
    return self.n_entries</code></pre>
</details>
<div class="desc"><p>Get the number of matrix elements.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>n_entries</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of matrix elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.subtract"><code class="name flex">
<span>def <span class="ident">subtract</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract(self, x):
    &#34;&#34;&#34;Subtract a scalar from all matrix elements, or subtract another compatible matrix.

    Parameters
    ----------
    x : Matrix or float
        Matrix to be subtracted from this matrix, or scalar to be subtracted from all matrix elements.
    &#34;&#34;&#34;
    if isinstance(x, Matrix):
        # &#39;x&#39; is another matrix:
        if self.same_size(x):
            self.value = numpy.subtract(self.value, x.value)
        else:
            raise Exception(&#34;Incompatible matrix sizes. Can only subtract matrices of same size.&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.subtract(self.value, x)
    else:
        raise Exception(f&#34;Matrix subtraction failed: M-A is only supported when A is of type &#39;Matrix&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Subtract a scalar from all matrix elements, or subtract another compatible matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code> or <code>float</code></dt>
<dd>Matrix to be subtracted from this matrix, or scalar to be subtracted from all matrix elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Matrix.update_rows_cols"><code class="name flex">
<span>def <span class="ident">update_rows_cols</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_rows_cols(self):
    &#34;&#34;&#34;Update the numbers of rows and columns based on the current shape of `self.value`.&#34;&#34;&#34;

    # Update number of rows and columns
    sh = self.value.shape
    self.rows = sh[0]
    if len(sh) &gt; 1:
        self.cols = sh[1]
    else:
        # Created a vector
        self.cols = 1</code></pre>
</details>
<div class="desc"><p>Update the numbers of rows and columns based on the current shape of <code>self.value</code>.</p></div>
</dd>
</dl>
</dd>
<dt id="ctsimu.primitives.Polygon"><code class="flex name class">
<span>class <span class="ident">Polygon</span></span>
<span>(</span><span>*points: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polygon:
    &#34;&#34;&#34; A general 2D polygon with N points in space.

    Attributes
    ----------
    points : list
        List of points that make up the polygon, each point represented by a `Vector`.

    vertex_order_CCW : bool
        `True` if the vertex order is counter-clockwise (standard) or `False` if clockwise.
    &#34;&#34;&#34;

    def __init__(self, *points:&#39;Vector&#39;):
        &#34;&#34;&#34; Initialize with a series of points.
        They should be defined in counter-clockwise direction. They are objects of class `Vector`.

        If the points are specified in clockwise direction, the parameter `vertex_order_CCW` should be set to `False` manually.

        Parameters
        ----------
        *points : Vector
            An arbitrary number of points given.
        &#34;&#34;&#34;
        self.points = []
        self._area = None

        # Vertices defined in counter-clockwise order (True) or clockwise order (False).
        self.vertex_order_CCW = True

        self.set(*points)

    def __str__(self):
        s = &#34;&#34;
        for i, p in enumerate(self.points):
            s += &#34;P{i}: ({x}, {y})\n&#34;.format(i=i, x=p.x(), y=p.y())

        return s

    def make_3D(self, z_component:float):
        &#34;&#34;&#34;Convert all points in xy-plane from 2D vectors to 3D vectors,
        using the provided z_component.

        Parameters
        ----------
        z_component : float
            The new z component for each point&#39;s 3D vector.
        &#34;&#34;&#34;

        for i, p in enumerate(self.points):
            newPoint = Vector(x=p.x(), y=p.y(), z=z_component, n=3)
            self.points[i] = newPoint

    def set(self, *points:&#39;Vector&#39;):
        &#34;&#34;&#34; Set polygon from an arbitrary number of points.
        The points should be defined in counter-clockwise direction. They are objects of class `Vector`.

        If the points are specified in clockwise direction, the parameter `vertex_order_CCW` should be set to `False` manually.

        Parameters
        ----------
        *points : Vector
            An arbitrary number of points.
        &#34;&#34;&#34;

        self.points = []
        self.points.extend(points)

        self._area = None

    def area(self) -&gt; float:
        &#34;&#34;&#34;Get the area enclosed by the polygon.

        Returns
        -------
        area : float
            Area enclosed by the polygon.
        &#34;&#34;&#34;

        if self._area is None:
            self._calculate_area()

        return self._area

    def _calculate_area(self):
        &#34;&#34;&#34;Calculate the area enclosed by the polygon.

        The area will be stored as an internal parameter. The function `area()` can be used to get this value.
        &#34;&#34;&#34;

        self._area = 0

        # Split polygon into triangles and calculate area of each
        # triangle using the trapezoid method.
        if len(self.points) &gt;= 3:
            # Start at first point
            p1 = self.points[0]
            x1 = p1.x()
            y1 = p1.y()

            for i in range(1, len(self.points)-1):
                p2 = self.points[i]
                p3 = self.points[i+1]
                x2 = p2.x()
                y2 = p2.y()
                x3 = p3.x()
                y3 = p3.y()
                self._area += 0.5 * ( (y1+y3)*(x3-x1) + (y2+y3)*(x2-x3) - (y1+y2)*(x2-x1) )

    def get_bounding_box(self) -&gt; tuple[int, int, int, int]:
        &#34;&#34;&#34;Get the polygon&#39;s bounding box values.

        Returns
        -------
        leftmost : float
            Leftmost coordinate.

        upmost : float
            Upmost coordinate.

        rightmost : float
            Rightmost coordinate.

        downmost : float
            Downmost coordinate.
        &#34;&#34;&#34;

        leftmost  = self.points[0].x()
        rightmost = -1
        upmost    = self.points[0].y()
        downmost  = -1

        for p in self.points:
            if p.x() &lt; leftmost:
                leftmost = math.floor(p.x())
            if p.x() &gt; rightmost:
                rightmost = math.ceil(p.x())

            if p.y() &lt; upmost:
                upmost = math.floor(p.y())
            if p.y() &gt; downmost:
                downmost = math.ceil(p.y())

        return int(leftmost), int(upmost), int(rightmost), int(downmost)

    def is_inside_2D(self, point:&#39;Vector&#39;) -&gt; bool:
        &#34;&#34;&#34; Check if the given point is inside the polygon or on an edge.
        Only the xy plane is considered (2D projection).

        Parameters
        ----------
        point : Vector
            Point coordinates to check if they are inside the polygon.

        Returns
        -------
        inside : bool
            `True` if inside, `False` otherwise.
        &#34;&#34;&#34;
        x = point.x()
        y = point.y()

        if len(self.points) &gt;= 3:
            p1 = self.points[0]
            x1 = p1.x()
            y1 = p1.y()

            # Set up sub-triangles and check if point is in any of those:
            for i in range(1, len(self.points)-1):
                p2 = self.points[i]
                p3 = self.points[i+1]
                x2 = p2.x()
                y2 = p2.y()
                x3 = p3.x()
                y3 = p3.y()

                # Calculate the barycentric coordinates of the point with respect to the triangle:
                D = (y2-y3)*(x1-x3) + (x3-x2)*(y1-y3)

                lambda1 = ((y2-y3)*(x-x3) + (x3-x2)*(y-y3)) / D
                lambda2 = ((y3-y1)*(x-x3) + (x1-x3)*(y-y3)) / D
                lambda3 = 1 - lambda1 - lambda2

                #print(&#34;Is {} inside triangle?   D: {}, l1: {}, l2: {}, l3: {}&#34;.format(point, D, lambda1, lambda2, lambda3))

                if (lambda1&gt;=0 and lambda2&gt;=0 and lambda3&gt;=0):
                    return True

        return False

    def _inside_edge(self, edgePoint0:&#39;Vector&#39;, edgePoint1:&#39;Vector&#39;, vertexToTest:&#39;Vector&#39;) -&gt; bool:
        &#34;&#34;&#34; Helper function for clip():
            decide if vertex point is on the &#34;inside&#34; of the clipping edge.
            Inside means &#34;to the left&#34; if vertices are in counter-clockwise direction,
            otherwise &#34;to the right&#34;. &#34;&#34;&#34;

        edge  = Vector(edgePoint1.x() - edgePoint0.x(), edgePoint1.y() - edgePoint0.y())
        point = Vector(vertexToTest.x() - edgePoint0.x(), vertexToTest.y() - edgePoint0.y())

        cpz = edge.cross_z(point)

        if cpz &gt;= 0:  # on the edge
            return True

        return False

    def clip(self, clipping_polygon:&#39;Polygon&#39;) -&gt; &#39;Polygon&#39;:
        &#34;&#34;&#34; Clips the polygon using the given clipping polygon.

        Implementation of the Sutherland-Hodgman clipping algorithm.

        The given `clipping_polygon` must be convex.

        Parameters
        ----------
        clipping_polygon : Polygon
            Clipping polygon. The result will be a polygon that only exists within the boundaries of this clipping polygon.

        Returns
        -------
        clipped : Polygon
            Clipped polygon.
        &#34;&#34;&#34;

        # Make a list of edges (lines) of the clipping polygon:
        outputVertices = self.points # copy.deepcopy(self.points)

        nPoints = len(clipping_polygon.points)
        for i in range(nPoints):
            edgePoint0 = clipping_polygon.points[i]
            edgePoint1 = clipping_polygon.points[int((i+1)%nPoints)]

            edgeLine = Line2D()
            edgeLine.set_from_points(p0=edgePoint0, p1=edgePoint1)

            inputVertices = outputVertices
            outputVertices = []

            #print(&#34;## Clip line: {}&#34;.format(edgeLine))

            for i in range(len(inputVertices)):
                currentPoint  = inputVertices[i]
                previousPoint = inputVertices[(i+len(inputVertices)-1)%len(inputVertices)]

                #print(&#34;  Current Point:  {}&#34;.format(currentPoint))
                #print(&#34;  Previous Point: {}&#34;.format(previousPoint))

                currentLine = Line2D()
                currentLine.set_from_points(p0=currentPoint, p1=previousPoint)

                #print(&#34;  -&gt; current Line: {}&#34;.format(currentLine))

                if self._inside_edge(edgePoint0, edgePoint1, currentPoint):
                    #print(&#34;  Current point is inside clipping polygon.&#34;)
                    if not self._inside_edge(edgePoint0, edgePoint1, previousPoint):
                        try:
                            intersectionPoint = currentLine.intersection(edgeLine)
                            #print(&#34;  Added intersection to output list.&#34;)
                            #print(&#34;  -&gt; intersection: {}&#34;.format(intersectionPoint))
                            outputVertices.append(intersectionPoint)
                        except:  # Parallel lines -&gt; no intersection
                            pass

                    #print(&#34;  Added currentPoint to output list.&#34;)
                    outputVertices.append(currentPoint)
                elif self._inside_edge(edgePoint0, edgePoint1, previousPoint):
                    #print(&#34;  Current point is not inside clipping polygon, but previous point is.&#34;)
                    try:
                        intersectionPoint = currentLine.intersection(edgeLine)
                        #print(&#34;  Only added intersection point to output list.&#34;)
                        #print(&#34;  -&gt; intersection: {}&#34;.format(intersectionPoint))
                        outputVertices.append(intersectionPoint)
                    except:
                        pass
                #else:
                    #print(&#34;Neither current nor previous point is inside clipping polygon.&#34;)


                #print(&#34;\n&#34;)

        result = Polygon(*outputVertices)
        return result</code></pre>
</details>
<div class="desc"><p>A general 2D polygon with N points in space.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>list</code></dt>
<dd>List of points that make up the polygon, each point represented by a <code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code>.</dd>
<dt><strong><code>vertex_order_CCW</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the vertex order is counter-clockwise (standard) or <code>False</code> if clockwise.</dd>
</dl>
<p>Initialize with a series of points.
They should be defined in counter-clockwise direction. They are objects of class <code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code>.</p>
<p>If the points are specified in clockwise direction, the parameter <code>vertex_order_CCW</code> should be set to <code>False</code> manually.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*points</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>An arbitrary number of points given.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.primitives.Polygon.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self) -&gt; float:
    &#34;&#34;&#34;Get the area enclosed by the polygon.

    Returns
    -------
    area : float
        Area enclosed by the polygon.
    &#34;&#34;&#34;

    if self._area is None:
        self._calculate_area()

    return self._area</code></pre>
</details>
<div class="desc"><p>Get the area enclosed by the polygon.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>float</code></dt>
<dd>Area enclosed by the polygon.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Polygon.clip"><code class="name flex">
<span>def <span class="ident">clip</span></span>(<span>self,<br>clipping_polygon: <a title="ctsimu.primitives.Polygon" href="#ctsimu.primitives.Polygon">Polygon</a>) ‑> <a title="ctsimu.primitives.Polygon" href="#ctsimu.primitives.Polygon">Polygon</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clip(self, clipping_polygon:&#39;Polygon&#39;) -&gt; &#39;Polygon&#39;:
    &#34;&#34;&#34; Clips the polygon using the given clipping polygon.

    Implementation of the Sutherland-Hodgman clipping algorithm.

    The given `clipping_polygon` must be convex.

    Parameters
    ----------
    clipping_polygon : Polygon
        Clipping polygon. The result will be a polygon that only exists within the boundaries of this clipping polygon.

    Returns
    -------
    clipped : Polygon
        Clipped polygon.
    &#34;&#34;&#34;

    # Make a list of edges (lines) of the clipping polygon:
    outputVertices = self.points # copy.deepcopy(self.points)

    nPoints = len(clipping_polygon.points)
    for i in range(nPoints):
        edgePoint0 = clipping_polygon.points[i]
        edgePoint1 = clipping_polygon.points[int((i+1)%nPoints)]

        edgeLine = Line2D()
        edgeLine.set_from_points(p0=edgePoint0, p1=edgePoint1)

        inputVertices = outputVertices
        outputVertices = []

        #print(&#34;## Clip line: {}&#34;.format(edgeLine))

        for i in range(len(inputVertices)):
            currentPoint  = inputVertices[i]
            previousPoint = inputVertices[(i+len(inputVertices)-1)%len(inputVertices)]

            #print(&#34;  Current Point:  {}&#34;.format(currentPoint))
            #print(&#34;  Previous Point: {}&#34;.format(previousPoint))

            currentLine = Line2D()
            currentLine.set_from_points(p0=currentPoint, p1=previousPoint)

            #print(&#34;  -&gt; current Line: {}&#34;.format(currentLine))

            if self._inside_edge(edgePoint0, edgePoint1, currentPoint):
                #print(&#34;  Current point is inside clipping polygon.&#34;)
                if not self._inside_edge(edgePoint0, edgePoint1, previousPoint):
                    try:
                        intersectionPoint = currentLine.intersection(edgeLine)
                        #print(&#34;  Added intersection to output list.&#34;)
                        #print(&#34;  -&gt; intersection: {}&#34;.format(intersectionPoint))
                        outputVertices.append(intersectionPoint)
                    except:  # Parallel lines -&gt; no intersection
                        pass

                #print(&#34;  Added currentPoint to output list.&#34;)
                outputVertices.append(currentPoint)
            elif self._inside_edge(edgePoint0, edgePoint1, previousPoint):
                #print(&#34;  Current point is not inside clipping polygon, but previous point is.&#34;)
                try:
                    intersectionPoint = currentLine.intersection(edgeLine)
                    #print(&#34;  Only added intersection point to output list.&#34;)
                    #print(&#34;  -&gt; intersection: {}&#34;.format(intersectionPoint))
                    outputVertices.append(intersectionPoint)
                except:
                    pass
            #else:
                #print(&#34;Neither current nor previous point is inside clipping polygon.&#34;)


            #print(&#34;\n&#34;)

    result = Polygon(*outputVertices)
    return result</code></pre>
</details>
<div class="desc"><p>Clips the polygon using the given clipping polygon.</p>
<p>Implementation of the Sutherland-Hodgman clipping algorithm.</p>
<p>The given <code>clipping_polygon</code> must be convex.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clipping_polygon</code></strong> :&ensp;<code><a title="ctsimu.primitives.Polygon" href="#ctsimu.primitives.Polygon">Polygon</a></code></dt>
<dd>Clipping polygon. The result will be a polygon that only exists within the boundaries of this clipping polygon.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>clipped</code></strong> :&ensp;<code><a title="ctsimu.primitives.Polygon" href="#ctsimu.primitives.Polygon">Polygon</a></code></dt>
<dd>Clipped polygon.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Polygon.get_bounding_box"><code class="name flex">
<span>def <span class="ident">get_bounding_box</span></span>(<span>self) ‑> tuple[int, int, int, int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounding_box(self) -&gt; tuple[int, int, int, int]:
    &#34;&#34;&#34;Get the polygon&#39;s bounding box values.

    Returns
    -------
    leftmost : float
        Leftmost coordinate.

    upmost : float
        Upmost coordinate.

    rightmost : float
        Rightmost coordinate.

    downmost : float
        Downmost coordinate.
    &#34;&#34;&#34;

    leftmost  = self.points[0].x()
    rightmost = -1
    upmost    = self.points[0].y()
    downmost  = -1

    for p in self.points:
        if p.x() &lt; leftmost:
            leftmost = math.floor(p.x())
        if p.x() &gt; rightmost:
            rightmost = math.ceil(p.x())

        if p.y() &lt; upmost:
            upmost = math.floor(p.y())
        if p.y() &gt; downmost:
            downmost = math.ceil(p.y())

    return int(leftmost), int(upmost), int(rightmost), int(downmost)</code></pre>
</details>
<div class="desc"><p>Get the polygon's bounding box values.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>leftmost</code></strong> :&ensp;<code>float</code></dt>
<dd>Leftmost coordinate.</dd>
<dt><strong><code>upmost</code></strong> :&ensp;<code>float</code></dt>
<dd>Upmost coordinate.</dd>
<dt><strong><code>rightmost</code></strong> :&ensp;<code>float</code></dt>
<dd>Rightmost coordinate.</dd>
<dt><strong><code>downmost</code></strong> :&ensp;<code>float</code></dt>
<dd>Downmost coordinate.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Polygon.is_inside_2D"><code class="name flex">
<span>def <span class="ident">is_inside_2D</span></span>(<span>self,<br>point: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_inside_2D(self, point:&#39;Vector&#39;) -&gt; bool:
    &#34;&#34;&#34; Check if the given point is inside the polygon or on an edge.
    Only the xy plane is considered (2D projection).

    Parameters
    ----------
    point : Vector
        Point coordinates to check if they are inside the polygon.

    Returns
    -------
    inside : bool
        `True` if inside, `False` otherwise.
    &#34;&#34;&#34;
    x = point.x()
    y = point.y()

    if len(self.points) &gt;= 3:
        p1 = self.points[0]
        x1 = p1.x()
        y1 = p1.y()

        # Set up sub-triangles and check if point is in any of those:
        for i in range(1, len(self.points)-1):
            p2 = self.points[i]
            p3 = self.points[i+1]
            x2 = p2.x()
            y2 = p2.y()
            x3 = p3.x()
            y3 = p3.y()

            # Calculate the barycentric coordinates of the point with respect to the triangle:
            D = (y2-y3)*(x1-x3) + (x3-x2)*(y1-y3)

            lambda1 = ((y2-y3)*(x-x3) + (x3-x2)*(y-y3)) / D
            lambda2 = ((y3-y1)*(x-x3) + (x1-x3)*(y-y3)) / D
            lambda3 = 1 - lambda1 - lambda2

            #print(&#34;Is {} inside triangle?   D: {}, l1: {}, l2: {}, l3: {}&#34;.format(point, D, lambda1, lambda2, lambda3))

            if (lambda1&gt;=0 and lambda2&gt;=0 and lambda3&gt;=0):
                return True

    return False</code></pre>
</details>
<div class="desc"><p>Check if the given point is inside the polygon or on an edge.
Only the xy plane is considered (2D projection).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Point coordinates to check if they are inside the polygon.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inside</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if inside, <code>False</code> otherwise.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Polygon.make_3D"><code class="name flex">
<span>def <span class="ident">make_3D</span></span>(<span>self, z_component: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_3D(self, z_component:float):
    &#34;&#34;&#34;Convert all points in xy-plane from 2D vectors to 3D vectors,
    using the provided z_component.

    Parameters
    ----------
    z_component : float
        The new z component for each point&#39;s 3D vector.
    &#34;&#34;&#34;

    for i, p in enumerate(self.points):
        newPoint = Vector(x=p.x(), y=p.y(), z=z_component, n=3)
        self.points[i] = newPoint</code></pre>
</details>
<div class="desc"><p>Convert all points in xy-plane from 2D vectors to 3D vectors,
using the provided z_component.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z_component</code></strong> :&ensp;<code>float</code></dt>
<dd>The new z component for each point's 3D vector.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Polygon.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self,<br>*points: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, *points:&#39;Vector&#39;):
    &#34;&#34;&#34; Set polygon from an arbitrary number of points.
    The points should be defined in counter-clockwise direction. They are objects of class `Vector`.

    If the points are specified in clockwise direction, the parameter `vertex_order_CCW` should be set to `False` manually.

    Parameters
    ----------
    *points : Vector
        An arbitrary number of points.
    &#34;&#34;&#34;

    self.points = []
    self.points.extend(points)

    self._area = None</code></pre>
</details>
<div class="desc"><p>Set polygon from an arbitrary number of points.
The points should be defined in counter-clockwise direction. They are objects of class <code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code>.</p>
<p>If the points are specified in clockwise direction, the parameter <code>vertex_order_CCW</code> should be set to <code>False</code> manually.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*points</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>An arbitrary number of points.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="ctsimu.primitives.Vector"><code class="flex name class">
<span>class <span class="ident">Vector</span></span>
<span>(</span><span>x: float = None,<br>y: float = None,<br>z: float = None,<br>w: float = None,<br>n: int = None,<br>numpy_data=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vector:
    &#34;&#34;&#34;A vector in space, arbitrary number of dimensions.

    Attributes
    ----------
    n_entries : int
        Number of vector elements.

    value : numpy.ndarray
        NumPy array that contains the vector elements.
    &#34;&#34;&#34;

    def __init__(self, x:float=None, y:float=None, z:float=None, w:float=None, n:int=None, numpy_data=None):
        &#34;&#34;&#34;Initialize vector by providing elements `x`, (`y`, `z`, `w`) and possibly the number of elements `n`, or a NumPy data array.

        Parameters
        ----------
        x : float, optional
            Value for first vector element.

        y : float, optional
            Value for second vector element.

        z : float, optional
            Value for third vector element.

        w : float, optional
            Value for fourth vector element.

        n : int, optional
            Number of vector elements. Must be provided if no NumPy data array
            is given and if the number of vector elements cannot be automatically
            determined from the given parameters `x`, `y`, `z` and `w`
            (those which are set to `None` are not considered in the
            determination of the dimension).

        numpy_data : numpy.ndarray, optional
            One-dimensional NumPy data array. Must be provided if number of vector elements `n` is not given.
        &#34;&#34;&#34;

        # The following member variables are private and should not
        # be accessed from outside. They are invalidated whenever the
        # vector changes.
        self._unit_vector = None  # the unit vector that corresponds to this vector
        self._length = None  # vector&#39;s length

        self.n_entries = 3 # default: three-component vector

        if numpy_data is not None:
            # Initialize from given numpy data array:
            self.set_numpy_data_array(numpy_data)
        else:
            # Or from regular value arguments:
            if n is not None:
                # If the number of vector components is specified:
                self.n_entries = n
            else:
                # Determine number of vector components from given values:
                if x is not None:
                    self.n_entries = 1
                    if y is not None:
                        self.n_entries = 2
                        if z is not None:
                            self.n_entries = 3
                            if w is not None:
                                self.n_entries = 4

            self.reset(n=self.n_entries)
            self.set(x=x, y=y, z=z, w=w)

        self.update()

    def __str__(self):
        return f&#34;{self.value}&#34;

    def __add__(self, x:&#39;Vector&#39;):
        result = self.get_copy()
        result.add(x)
        return result

    def __sub__(self, x:&#39;Vector&#39;):
        result = self.get_copy()
        result.subtract(x)
        return result

    def __mul__(self, x:&#39;Vector&#39;):
        result = self.get_copy()
        result.multiply(x)
        return result

    def __truediv__(self, x:&#39;Vector&#39;):
        result = self.get_copy()
        result.divide(x)
        return result

    def __floordiv__(self, x:&#39;Vector&#39;):
        result = self.get_copy()
        result.floor_divide(x)
        return result

    def __radd__(self, x:&#39;Vector&#39;):
        if isinstance(x, numbers.Number):
            return self.__add__(x)

    def __rsub__(self, x:&#39;Vector&#39;):
        if isinstance(x, numbers.Number):
            result = self.get_copy()
            result.multiply(-1)
            result.add(x)
            return result

    def __rmul__(self, x:&#39;Vector&#39;):
        if isinstance(x, numbers.Number):
            return self.__mul__(x)

    def size(self) -&gt; int:
        &#34;&#34;&#34;Get the number of vector elements.

        Returns
        -------
        n_entries : int
            Number of vector elements.
        &#34;&#34;&#34;
        return self.n_entries

    def reset(self, n:int):
        &#34;&#34;&#34;Set vector to given size and initialize all values to zero.

        Parameters
        ----------
        n : int
            Number of vector elements.
        &#34;&#34;&#34;
        self.n_entries = n
        self.value = numpy.zeros(n, dtype=numpy.float64)

    def same_size(self, x:&#39;Vector&#39;) -&gt; bool:
        &#34;&#34;&#34;Check if this vector has the same size (i.e., number of vector elements, not length!) as the given vector `x`.

        Returns
        -------
        same_dim : bool
            `True` if number of vector elements matches, `False` otherwise.
        &#34;&#34;&#34;

        if self.n_entries == x.n_entries:
            return True

        return False

    def update(self):
        &#34;&#34;&#34;Called when vector is changed.

        Invalidates private member variables for length and unit vector,
        so they will be re-calculated the next time their public getter
        functions are called.
        &#34;&#34;&#34;
        self._unit_vector = None
        self._length = None

    def x(self) -&gt; float:
        &#34;&#34;&#34;Get first vector element.

        Returns
        -------
        x : float
            First vector element.
        &#34;&#34;&#34;
        return self.value[0]

    def y(self) -&gt; float:
        &#34;&#34;&#34;Get second vector element.

        Returns
        -------
        y : float
            Second vector element.
        &#34;&#34;&#34;
        return self.value[1]

    def z(self) -&gt; float:
        &#34;&#34;&#34;Get third vector element.

        Returns
        -------
        z : float

            Third vector element.
        &#34;&#34;&#34;
        return self.value[2]

    def w(self) -&gt; float:
        &#34;&#34;&#34;Get fourth vector element.

        Returns
        -------
        w : float

            Fourth vector element.
        &#34;&#34;&#34;
        return self.value[3]

    def get(self, i:int) -&gt; float:
        &#34;&#34;&#34;Get value at vector index `i`. Indices start at `0`.

        Parameters
        ----------
        i : int
            Element index of value.

        Returns
        -------
        value : float
            Element value at index position `i`.
        &#34;&#34;&#34;
        return self.value[i]

    def get_copy(self) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34;Get a copy of this `Vector` object.

        Returns
        -------
        v : Vector
            Copy of this vector object.
        &#34;&#34;&#34;
        new_values = numpy.copy(self.value)
        return Vector(numpy_data=new_values)

    def set_x(self, value:float):
        &#34;&#34;&#34;Set vector&#39;s x value (i.e., value of first vector element).

        Parameters
        ----------
        value : float
            Value for the first vector element.
        &#34;&#34;&#34;
        self.value[0] = float(value)
        self.update()

    def set_y(self, value:float):
        &#34;&#34;&#34;Set vector&#39;s y value (i.e., value of second vector element).

        Parameters
        ----------
        value : float
            Value for the second vector element.
        &#34;&#34;&#34;
        self.value[1] = float(value)
        self.update()

    def set_z(self, value:float):
        &#34;&#34;&#34;Set vector&#39;s z value (i.e., value of third vector element).

        Parameters
        ----------
        value : float
            Value for the third vector element.
        &#34;&#34;&#34;
        self.value[2] = float(value)
        self.update()

    def set_w(self, value:float):
        &#34;&#34;&#34;Set vector&#39;s w value (i.e., value of fourth vector element).

        Parameters
        ----------
        value : float
            Value for the fourth vector element.
        &#34;&#34;&#34;
        self.value[3] = float(value)
        self.update()

    def set_x_y(self, x:float=0, y:float=0):
        &#34;&#34;&#34;Set x and y component (relevant for 2D computations).

        Parameters
        ----------
        x : float
            Value for the first vector element.

        y : float
            Value for the second vector element.
        &#34;&#34;&#34;
        self.value[0] = float(x)
        self.value[1] = float(y)
        self.update()

    def set(self, x:float=0, y:float=0, z:float=0, w:float=None):
        &#34;&#34;&#34; Set all vector components.

        Non-existing vector components (such as `w` for a 3D vector) should be set to `None`.

        Parameters
        ----------
        x : float
            Value for the first vector element.

        y : float, optional
            Value for the second vector element.

        z : float, optional
            Value for the third vector element.

        w : float, optional
            Value for the fourth vector element.
        &#34;&#34;&#34;
        if self.n_entries &gt; 0 and x is not None:
            self.value[0] = float(x)

        if self.n_entries &gt; 1 and y is not None:
            self.value[1] = float(y)

        if self.n_entries &gt; 2 and z is not None:
            self.value[2] = float(z)

        if self.n_entries &gt; 3 and w is not None:
            self.value[3] = float(w)

        self.update()

    def set_value_for_index(self, i:int, value:float):
        &#34;&#34;&#34;Set value for element at vector index `i`.

        Parameters
        ----------
        i : int
            Index of the vector element.

        value : float
            New value for the vector element.
        &#34;&#34;&#34;
        self.value[i] = float(value)
        self.update()

    def set_numpy_data_array(self, numpy_data):
        &#34;&#34;&#34;Provide a one-dimensional NumPy array for the vector data.
        The new vector size will be the same as the size of the NumPy array.

        Parameters
        ----------
        numpy_data : numpy.ndarray
            NumPy array for the new vector values.
        &#34;&#34;&#34;
        self.n_entries = len(numpy_data)
        self.value = numpy_data.astype(float)
        self.update()

    def min(self) -&gt; float:
        &#34;&#34;&#34;Minimum value of all vector components.&#34;&#34;&#34;
        return self.value.min()

    def max(self) -&gt; float:
        &#34;&#34;&#34;Maximum value of all vector components.&#34;&#34;&#34;
        return self.value.min()

    def absmin(self) -&gt; float:
        &#34;&#34;&#34;Minimum value of absolute of all vector components.&#34;&#34;&#34;
        return numpy.absolute(self.value).min()

    def absmax(self) -&gt; float:
        &#34;&#34;&#34;Maximum value of absolute of all vector components.&#34;&#34;&#34;
        return numpy.absolute(self.value).max()

    def absmin_nonzero(self) -&gt; float:
        &#34;&#34;&#34;Minimum non-zero value of absolute of all vector components.&#34;&#34;&#34;
        nonzeros = self.value[numpy.nonzero(self.value)]
        if len(nonzeros) &gt; 0:
            return numpy.absolute(nonzeros).min()
        else:
            return None

    def absmax_nonzero(self) -&gt; float:
        &#34;&#34;&#34;Maximum non-zero value of absolute of all vector components.&#34;&#34;&#34;
        nonzeros = self.value[numpy.nonzero(self.value)]
        if len(nonzeros) &gt; 0:
            return numpy.absolute(nonzeros).max()
        else:
            return None

    def make_crystal_vector(self):
        &#34;&#34;&#34;Scale this vector into a crystal direction vector,
        using Miller indices.&#34;&#34;&#34;
        absmin_number = self.absmin_nonzero()
        if absmin_number is not None:
            if absmin_number &gt; 0:
                self.scale(1.0 / absmin_number)

    def crystal_direction(self) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34;Create a vector using Miller indices.&#34;&#34;&#34;
        miller = self.get_copy()
        miller.make_crystal_vector()

        return miller

    def length(self) -&gt; float:
        &#34;&#34;&#34;Get the length of the vector.

        Returns
        -------
        length : float
            Length of the vector.
        &#34;&#34;&#34;
        if self._length is None:
            self._length = numpy.linalg.norm(self.value)

        return self._length

    def angle(self, x:&#39;Vector&#39;) -&gt; float:
        &#34;&#34;&#34;Calculate angle between this vector and the given vector `x`.

        Parameters
        ----------
        x : Vector
            Second vector for angle calculation.

        Returns
        -------
        angle : float
            Angle (in radians) between this vector and given vector `x`.
        &#34;&#34;&#34;
        dotProd = self.dot(x)
        l1 = self.length()
        l2 = x.length()
        lp = l1 * l2

        if lp &gt; 0:
            cs = dotProd / lp
            alpha = 0

            # Avoid out-of-domain due to rounding errors:
            if cs &gt;= 1.0:
                alpha = 0
            elif cs &lt;= -1.0:
                alpha = math.pi
            else:
                alpha = math.acos(cs)

            return alpha
        else:
            return 0

    def make_unit_vector(self):
        &#34;&#34;&#34; Normalize vector length to 1. &#34;&#34;&#34;
        vector_length = self.length()
        if vector_length != 0:
            if vector_length != 1.0:
                self.value /= vector_length
                self.update()
        else:
            raise Exception(&#34;Unit vector: a zero length vector cannot be converted into a unit vector.&#34;)

    def unit_vector(self) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34; Get a unit vector that points in the same direction as this vector.

        Returns
        -------
        unit_vector : Vector
            Unit vector for this vector.

        Note
        ----
        If this vector changes, the returned unit vector object will be invalidated. To store the unit vector permanently, get a copy of the unit vector (using `get_copy()`) so it won&#39;t change:

        ```python
        unitv = v.unit_vector().get_copy()
        ```
        &#34;&#34;&#34;
        if self._unit_vector is None:
            self._unit_vector = self.get_copy()
            self._unit_vector.make_unit_vector()

        return self._unit_vector

    def add(self, x):
        &#34;&#34;&#34;Add a scalar to all vector elements, or add another compatible vector.

        Parameters
        ----------
        x : Vector or float
            Vector of same size to be added (element-wise) or scalar to be added to all vector elements.
        &#34;&#34;&#34;
        if isinstance(x, Vector):
            # &#39;x&#39; is another vector:
            if self.same_size(x):
                self.value = numpy.add(self.value, x.value)
            else:
                raise Exception(f&#34;Incompatible vector sizes. Can only add vectors of same size. Vectors: {self} ({self.n_entries}) and {x} ({x.n_entries})&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.add(self.value, x)
        else:
            raise Exception(f&#34;Vector addition failed: M+A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def subtract(self, x):
        &#34;&#34;&#34;Subtract a scalar from all vector elements, or subtract another compatible vector.

        Parameters
        ----------
        x : Vector or float
            Vector of same size to be subtracted (element-wise) or scalar to be subtracted from all vector elements.
        &#34;&#34;&#34;
        if isinstance(x, Vector):
            # &#39;x&#39; is another vector:
            if self.same_size(x):
                self.value = numpy.subtract(self.value, x.value)
            else:
                raise Exception(&#34;Incompatible vector sizes. Can only subtract vectors of same size.&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.subtract(self.value, x)
        else:
            raise Exception(f&#34;Vector subtraction failed: M-A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def multiply(self, x):
        &#34;&#34;&#34;Multiply a scalar to all vector elements, or perform vector multiplication with a compatible vector.

        Parameters
        ----------
        x : Vector or float
            Vector of same size to be multiplied (element-wise) or scalar to be multiplied to all vector elements.
        &#34;&#34;&#34;
        if isinstance(x, Vector):
            # &#39;x&#39; is another vector:
            self.value = numpy.matmul(self.value, x.value)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.multiply(self.value, x)
        else:
            raise Exception(f&#34;Vector multiplication failed: M*A is only supported when A is of type &#39;Vector&#39; or &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def divide(self, x):
        &#34;&#34;&#34;Divide all vector elements by a scalar, or perform element-wise division with a vector of the same size.

        Parameters
        ----------
        x : Vector or float
            Vector of same size to divide this vector (element-wise) or scalar to divide all vector elements.
        &#34;&#34;&#34;
        if isinstance(x, Vector):
            # &#39;x&#39; is another vector... element-wise division:
            if self.same_size(x):
                self.value = numpy.divide(self.value, x.value)
            else:
                raise Exception(&#34;Incompatible vector sizes. Can only run an element-wise division for vectors of same size.&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.divide(self.value, x)
        else:
            raise Exception(f&#34;Vector division failed: M/A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def floor_divide(self, x):
        &#34;&#34;&#34;Divide all vector elements by a scalar, or perform element-wise division with a vector of the same size.

        Parameters
        ----------
        x : Vector or float
            Vector of same size to floor-divide this vector (element-wise) or scalar to floor-divide all vector elements.
        &#34;&#34;&#34;
        if isinstance(x, Vector):
            # &#39;x&#39; is another vector... element-wise division:
            if self.same_size(x):
                self.value = numpy.floor_divide(self.value, x.value)
            else:
                raise Exception(&#34;Incompatible vector sizes. Can only run an element-wise division for vectors of same size.&#34;)
        elif isinstance(x, numbers.Number):
            # &#39;x&#39; is a scalar:
            self.value = numpy.floor_divide(self.value, x)
        else:
            raise Exception(f&#34;Vector division failed: M/A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)

    def scale(self, factor:float):
        &#34;&#34;&#34;Scale vector by a scalar factor.

        Parameters
        ----------
        factor : float
            Factor that scales all vector elements.
        &#34;&#34;&#34;
        self.value = numpy.multiply(self.value, factor)
        self.update()

    def scaled(self, factor:float) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34; Get a copy of this vector, scaled by the given `factor`.

        Parameters
        ----------
        factor : float
            Factor that scales all vector elements.

        Returns
        -------
        result : Vector
            Scaled copy of this vector.
        &#34;&#34;&#34;
        result = self.get_copy()
        result.scale(factor)
        return result

    def square(self):
        &#34;&#34;&#34; Square all elements of this vector. &#34;&#34;&#34;
        self.value = numpy.square(self.value)
        self.update()

    def squared(self) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34; Get a squared copy of this vector.

        Returns
        -------
        result : Vector
            Squared copy of this vector.
        &#34;&#34;&#34;
        result = self.get_copy()
        result.square()
        return result

    def sqrt(self):
        &#34;&#34;&#34; Set all elements of this vector to their square roots. &#34;&#34;&#34;
        self.value = numpy.sqrt(self.value)
        self.update()

    def distance(self, p:&#39;Vector&#39;) -&gt; float:
        &#34;&#34;&#34; Distance between target points of this and another vector.

        Parameters
        ----------
        p : Vector
            Second vector.

        Returns
        -------
        distance : float
            Distance between the target point of this vector and the target point of the second vector `p`.
        &#34;&#34;&#34;
        return (self-p).length()

    def dot(self, x:&#39;Vector&#39;) -&gt; float:
        &#34;&#34;&#34; Calculate vector dot product.

        Parameters
        ----------
        x : Vector
            Another vector to calculate the dot product with this vector.

        Returns
        -------
        dotp : float
            Dot product of this vector with the vector `x`.
        &#34;&#34;&#34;
        return numpy.dot(self.value, x.value)

    def cross_z(self, x:&#39;Vector&#39;) -&gt; float:
        &#34;&#34;&#34; Calculate the z component of the 3D cross product.

        Parameters
        ----------
        x : Vector
            The second vector to calculate the cross product. Must contain three elements.

        Returns
        -------
        crossz : float
            z component of 3D cross product of this vector with the second vector `x`.
        &#34;&#34;&#34;
        return self.x()*x.y() - self.y()*x.x()

    def cross(self, x:&#39;Vector&#39;) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34; Calculate 3D vector cross product.

        Parameters
        ----------
        x : Vector
            The second vector to calculate the cross product. Must contain three elements.

        Returns
        -------
        crossp : Vector
            3D cross product of this vector with the second vector `x`.
        &#34;&#34;&#34;
        cp = numpy.cross(self.value, x.value)
        return Vector(numpy_data=cp)

    def sum(self) -&gt; float:
        &#34;&#34;&#34; Get the sum of all vector elements.

        Returns
        -------
        sum : float
            Sum of all vector elements.
        &#34;&#34;&#34;
        return numpy.sum(self.value)

    def invert(self):
        &#34;&#34;&#34; Invert this vector: v to -v. &#34;&#34;&#34;
        self.value = -self.value
        self.update()

    def inverse(self) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34; Get the inverse of this vector: -v.

        Returns
        -------
        inv : Vector
            Inverse of this vector, i.e. vector of same length pointing in the opposite direction.
        &#34;&#34;&#34;
        result = self.get_copy()
        result.invert()
        return result

    def rotate_2D_xy(self, angle:float):
        &#34;&#34;&#34; Rotate vector in xy plane.

        Parameters
        ----------
        angle : float
            Rotation angle (in rad).
        &#34;&#34;&#34;
        cs = math.cos(angle)
        sn = math.sin(angle)

        self.set_x(self.x()*cs - self.y()*sn)
        self.set_y(self.x()*sn + self.y()*cs)

    def rotate(self, axis:&#39;Vector&#39;, angle:float):
        &#34;&#34;&#34; Rotate vector around given axis by given angle (in rad).

        Parameters
        ----------
        axis : Vector
            Rotation axis.

        angle : float
            Rotation angle (in rad).
        &#34;&#34;&#34;

        # Implementing a general rotation matrix.
        cs = math.cos(angle)
        sn = math.sin(angle)

        vx = self.x()
        vy = self.y()
        vz = self.z()

        nx = axis.unit_vector().x()
        ny = axis.unit_vector().y()
        nz = axis.unit_vector().z()

        rx = vx*(nx*nx*(1.0-cs) + cs)    + vy*(nx*ny*(1.0-cs) - nz*sn) + vz*(nx*nz*(1.0-cs) + ny*sn)
        ry = vx*(ny*nx*(1.0-cs) + nz*sn) + vy*(ny*ny*(1.0-cs) + cs)    + vz*(ny*nz*(1.0-cs) - nx*sn)
        rz = vx*(nz*nx*(1.0-cs) - ny*sn) + vy*(nz*ny*(1.0-cs) + nx*sn) + vz*(nz*nz*(1.0-cs) + cs)

        self.set(x=rx, y=ry, z=rz)

    def transform(self, M:&#39;Matrix&#39;):
        &#34;&#34;&#34;Apply the transformation given by matrix `M` to this vector.

        Parameters
        ----------
        M : Matrix
            Transformation matrix.
        &#34;&#34;&#34;
        result = M*self
        self.n_entries = result.n_entries
        self.value     = result.value
        self.update()

    def to(self, x:&#39;Vector&#39;) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34; Get a vector that points from this location to the given location `x`.

        Parameters
        ----------
        x : Vector
            Second location vector.

        Returns
        -------
        pointer : Vector
            Vector that points from this vector&#39;s target point to the target point of the given vector `x`.
        &#34;&#34;&#34;
        return self.connection(self, x)

    @staticmethod
    def connection(p0:&#39;Vector&#39;, p1:&#39;Vector&#39;) -&gt; &#39;Vector&#39;:
        &#34;&#34;&#34; Connection vector between two points (represented by vectors).

        Parameters
        ----------
        p0 : Vector
            Origin point of the connection.

        p1 : Vector
            Target point of the connection.

        Returns
        -------
        connecting_vector : Vector
            Vector pointing from the origin `p0` to the target point `p1`.
        &#34;&#34;&#34;
        return p1 - p0</code></pre>
</details>
<div class="desc"><p>A vector in space, arbitrary number of dimensions.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>n_entries</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of vector elements.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>NumPy array that contains the vector elements.</dd>
</dl>
<p>Initialize vector by providing elements <code>x</code>, (<code>y</code>, <code>z</code>, <code>w</code>) and possibly the number of elements <code>n</code>, or a NumPy data array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for first vector element.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for second vector element.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for third vector element.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for fourth vector element.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of vector elements. Must be provided if no NumPy data array
is given and if the number of vector elements cannot be automatically
determined from the given parameters <code>x</code>, <code>y</code>, <code>z</code> and <code>w</code>
(those which are set to <code>None</code> are not considered in the
determination of the dimension).</dd>
<dt><strong><code>numpy_data</code></strong> :&ensp;<code>numpy.ndarray</code>, optional</dt>
<dd>One-dimensional NumPy data array. Must be provided if number of vector elements <code>n</code> is not given.</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="ctsimu.primitives.Vector.connection"><code class="name flex">
<span>def <span class="ident">connection</span></span>(<span>p0: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>,<br>p1: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def connection(p0:&#39;Vector&#39;, p1:&#39;Vector&#39;) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34; Connection vector between two points (represented by vectors).

    Parameters
    ----------
    p0 : Vector
        Origin point of the connection.

    p1 : Vector
        Target point of the connection.

    Returns
    -------
    connecting_vector : Vector
        Vector pointing from the origin `p0` to the target point `p1`.
    &#34;&#34;&#34;
    return p1 - p0</code></pre>
</details>
<div class="desc"><p>Connection vector between two points (represented by vectors).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p0</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Origin point of the connection.</dd>
<dt><strong><code>p1</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Target point of the connection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>connecting_vector</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Vector pointing from the origin <code>p0</code> to the target point <code>p1</code>.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.primitives.Vector.absmax"><code class="name flex">
<span>def <span class="ident">absmax</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absmax(self) -&gt; float:
    &#34;&#34;&#34;Maximum value of absolute of all vector components.&#34;&#34;&#34;
    return numpy.absolute(self.value).max()</code></pre>
</details>
<div class="desc"><p>Maximum value of absolute of all vector components.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.absmax_nonzero"><code class="name flex">
<span>def <span class="ident">absmax_nonzero</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absmax_nonzero(self) -&gt; float:
    &#34;&#34;&#34;Maximum non-zero value of absolute of all vector components.&#34;&#34;&#34;
    nonzeros = self.value[numpy.nonzero(self.value)]
    if len(nonzeros) &gt; 0:
        return numpy.absolute(nonzeros).max()
    else:
        return None</code></pre>
</details>
<div class="desc"><p>Maximum non-zero value of absolute of all vector components.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.absmin"><code class="name flex">
<span>def <span class="ident">absmin</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absmin(self) -&gt; float:
    &#34;&#34;&#34;Minimum value of absolute of all vector components.&#34;&#34;&#34;
    return numpy.absolute(self.value).min()</code></pre>
</details>
<div class="desc"><p>Minimum value of absolute of all vector components.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.absmin_nonzero"><code class="name flex">
<span>def <span class="ident">absmin_nonzero</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absmin_nonzero(self) -&gt; float:
    &#34;&#34;&#34;Minimum non-zero value of absolute of all vector components.&#34;&#34;&#34;
    nonzeros = self.value[numpy.nonzero(self.value)]
    if len(nonzeros) &gt; 0:
        return numpy.absolute(nonzeros).min()
    else:
        return None</code></pre>
</details>
<div class="desc"><p>Minimum non-zero value of absolute of all vector components.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, x):
    &#34;&#34;&#34;Add a scalar to all vector elements, or add another compatible vector.

    Parameters
    ----------
    x : Vector or float
        Vector of same size to be added (element-wise) or scalar to be added to all vector elements.
    &#34;&#34;&#34;
    if isinstance(x, Vector):
        # &#39;x&#39; is another vector:
        if self.same_size(x):
            self.value = numpy.add(self.value, x.value)
        else:
            raise Exception(f&#34;Incompatible vector sizes. Can only add vectors of same size. Vectors: {self} ({self.n_entries}) and {x} ({x.n_entries})&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.add(self.value, x)
    else:
        raise Exception(f&#34;Vector addition failed: M+A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Add a scalar to all vector elements, or add another compatible vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code> or <code>float</code></dt>
<dd>Vector of same size to be added (element-wise) or scalar to be added to all vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.angle"><code class="name flex">
<span>def <span class="ident">angle</span></span>(<span>self,<br>x: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle(self, x:&#39;Vector&#39;) -&gt; float:
    &#34;&#34;&#34;Calculate angle between this vector and the given vector `x`.

    Parameters
    ----------
    x : Vector
        Second vector for angle calculation.

    Returns
    -------
    angle : float
        Angle (in radians) between this vector and given vector `x`.
    &#34;&#34;&#34;
    dotProd = self.dot(x)
    l1 = self.length()
    l2 = x.length()
    lp = l1 * l2

    if lp &gt; 0:
        cs = dotProd / lp
        alpha = 0

        # Avoid out-of-domain due to rounding errors:
        if cs &gt;= 1.0:
            alpha = 0
        elif cs &lt;= -1.0:
            alpha = math.pi
        else:
            alpha = math.acos(cs)

        return alpha
    else:
        return 0</code></pre>
</details>
<div class="desc"><p>Calculate angle between this vector and the given vector <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Second vector for angle calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle (in radians) between this vector and given vector <code>x</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.cross"><code class="name flex">
<span>def <span class="ident">cross</span></span>(<span>self,<br>x: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross(self, x:&#39;Vector&#39;) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34; Calculate 3D vector cross product.

    Parameters
    ----------
    x : Vector
        The second vector to calculate the cross product. Must contain three elements.

    Returns
    -------
    crossp : Vector
        3D cross product of this vector with the second vector `x`.
    &#34;&#34;&#34;
    cp = numpy.cross(self.value, x.value)
    return Vector(numpy_data=cp)</code></pre>
</details>
<div class="desc"><p>Calculate 3D vector cross product.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>The second vector to calculate the cross product. Must contain three elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>crossp</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>3D cross product of this vector with the second vector <code>x</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.cross_z"><code class="name flex">
<span>def <span class="ident">cross_z</span></span>(<span>self,<br>x: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross_z(self, x:&#39;Vector&#39;) -&gt; float:
    &#34;&#34;&#34; Calculate the z component of the 3D cross product.

    Parameters
    ----------
    x : Vector
        The second vector to calculate the cross product. Must contain three elements.

    Returns
    -------
    crossz : float
        z component of 3D cross product of this vector with the second vector `x`.
    &#34;&#34;&#34;
    return self.x()*x.y() - self.y()*x.x()</code></pre>
</details>
<div class="desc"><p>Calculate the z component of the 3D cross product.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>The second vector to calculate the cross product. Must contain three elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>crossz</code></strong> :&ensp;<code>float</code></dt>
<dd>z component of 3D cross product of this vector with the second vector <code>x</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.crystal_direction"><code class="name flex">
<span>def <span class="ident">crystal_direction</span></span>(<span>self) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crystal_direction(self) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34;Create a vector using Miller indices.&#34;&#34;&#34;
    miller = self.get_copy()
    miller.make_crystal_vector()

    return miller</code></pre>
</details>
<div class="desc"><p>Create a vector using Miller indices.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self,<br>p: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, p:&#39;Vector&#39;) -&gt; float:
    &#34;&#34;&#34; Distance between target points of this and another vector.

    Parameters
    ----------
    p : Vector
        Second vector.

    Returns
    -------
    distance : float
        Distance between the target point of this vector and the target point of the second vector `p`.
    &#34;&#34;&#34;
    return (self-p).length()</code></pre>
</details>
<div class="desc"><p>Distance between target points of this and another vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Second vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance between the target point of this vector and the target point of the second vector <code>p</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.divide"><code class="name flex">
<span>def <span class="ident">divide</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide(self, x):
    &#34;&#34;&#34;Divide all vector elements by a scalar, or perform element-wise division with a vector of the same size.

    Parameters
    ----------
    x : Vector or float
        Vector of same size to divide this vector (element-wise) or scalar to divide all vector elements.
    &#34;&#34;&#34;
    if isinstance(x, Vector):
        # &#39;x&#39; is another vector... element-wise division:
        if self.same_size(x):
            self.value = numpy.divide(self.value, x.value)
        else:
            raise Exception(&#34;Incompatible vector sizes. Can only run an element-wise division for vectors of same size.&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.divide(self.value, x)
    else:
        raise Exception(f&#34;Vector division failed: M/A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Divide all vector elements by a scalar, or perform element-wise division with a vector of the same size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code> or <code>float</code></dt>
<dd>Vector of same size to divide this vector (element-wise) or scalar to divide all vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.dot"><code class="name flex">
<span>def <span class="ident">dot</span></span>(<span>self,<br>x: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dot(self, x:&#39;Vector&#39;) -&gt; float:
    &#34;&#34;&#34; Calculate vector dot product.

    Parameters
    ----------
    x : Vector
        Another vector to calculate the dot product with this vector.

    Returns
    -------
    dotp : float
        Dot product of this vector with the vector `x`.
    &#34;&#34;&#34;
    return numpy.dot(self.value, x.value)</code></pre>
</details>
<div class="desc"><p>Calculate vector dot product.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Another vector to calculate the dot product with this vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dotp</code></strong> :&ensp;<code>float</code></dt>
<dd>Dot product of this vector with the vector <code>x</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.floor_divide"><code class="name flex">
<span>def <span class="ident">floor_divide</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floor_divide(self, x):
    &#34;&#34;&#34;Divide all vector elements by a scalar, or perform element-wise division with a vector of the same size.

    Parameters
    ----------
    x : Vector or float
        Vector of same size to floor-divide this vector (element-wise) or scalar to floor-divide all vector elements.
    &#34;&#34;&#34;
    if isinstance(x, Vector):
        # &#39;x&#39; is another vector... element-wise division:
        if self.same_size(x):
            self.value = numpy.floor_divide(self.value, x.value)
        else:
            raise Exception(&#34;Incompatible vector sizes. Can only run an element-wise division for vectors of same size.&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.floor_divide(self.value, x)
    else:
        raise Exception(f&#34;Vector division failed: M/A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Divide all vector elements by a scalar, or perform element-wise division with a vector of the same size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code> or <code>float</code></dt>
<dd>Vector of same size to floor-divide this vector (element-wise) or scalar to floor-divide all vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, i: int) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, i:int) -&gt; float:
    &#34;&#34;&#34;Get value at vector index `i`. Indices start at `0`.

    Parameters
    ----------
    i : int
        Element index of value.

    Returns
    -------
    value : float
        Element value at index position `i`.
    &#34;&#34;&#34;
    return self.value[i]</code></pre>
</details>
<div class="desc"><p>Get value at vector index <code>i</code>. Indices start at <code>0</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>Element index of value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Element value at index position <code>i</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.get_copy"><code class="name flex">
<span>def <span class="ident">get_copy</span></span>(<span>self) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_copy(self) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34;Get a copy of this `Vector` object.

    Returns
    -------
    v : Vector
        Copy of this vector object.
    &#34;&#34;&#34;
    new_values = numpy.copy(self.value)
    return Vector(numpy_data=new_values)</code></pre>
</details>
<div class="desc"><p>Get a copy of this <code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code> object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Copy of this vector object.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.inverse"><code class="name flex">
<span>def <span class="ident">inverse</span></span>(<span>self) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse(self) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34; Get the inverse of this vector: -v.

    Returns
    -------
    inv : Vector
        Inverse of this vector, i.e. vector of same length pointing in the opposite direction.
    &#34;&#34;&#34;
    result = self.get_copy()
    result.invert()
    return result</code></pre>
</details>
<div class="desc"><p>Get the inverse of this vector: -v.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inv</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Inverse of this vector, i.e. vector of same length pointing in the opposite direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert(self):
    &#34;&#34;&#34; Invert this vector: v to -v. &#34;&#34;&#34;
    self.value = -self.value
    self.update()</code></pre>
</details>
<div class="desc"><p>Invert this vector: v to -v.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self) -&gt; float:
    &#34;&#34;&#34;Get the length of the vector.

    Returns
    -------
    length : float
        Length of the vector.
    &#34;&#34;&#34;
    if self._length is None:
        self._length = numpy.linalg.norm(self.value)

    return self._length</code></pre>
</details>
<div class="desc"><p>Get the length of the vector.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the vector.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.make_crystal_vector"><code class="name flex">
<span>def <span class="ident">make_crystal_vector</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_crystal_vector(self):
    &#34;&#34;&#34;Scale this vector into a crystal direction vector,
    using Miller indices.&#34;&#34;&#34;
    absmin_number = self.absmin_nonzero()
    if absmin_number is not None:
        if absmin_number &gt; 0:
            self.scale(1.0 / absmin_number)</code></pre>
</details>
<div class="desc"><p>Scale this vector into a crystal direction vector,
using Miller indices.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.make_unit_vector"><code class="name flex">
<span>def <span class="ident">make_unit_vector</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_unit_vector(self):
    &#34;&#34;&#34; Normalize vector length to 1. &#34;&#34;&#34;
    vector_length = self.length()
    if vector_length != 0:
        if vector_length != 1.0:
            self.value /= vector_length
            self.update()
    else:
        raise Exception(&#34;Unit vector: a zero length vector cannot be converted into a unit vector.&#34;)</code></pre>
</details>
<div class="desc"><p>Normalize vector length to 1.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max(self) -&gt; float:
    &#34;&#34;&#34;Maximum value of all vector components.&#34;&#34;&#34;
    return self.value.min()</code></pre>
</details>
<div class="desc"><p>Maximum value of all vector components.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.min"><code class="name flex">
<span>def <span class="ident">min</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min(self) -&gt; float:
    &#34;&#34;&#34;Minimum value of all vector components.&#34;&#34;&#34;
    return self.value.min()</code></pre>
</details>
<div class="desc"><p>Minimum value of all vector components.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.multiply"><code class="name flex">
<span>def <span class="ident">multiply</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply(self, x):
    &#34;&#34;&#34;Multiply a scalar to all vector elements, or perform vector multiplication with a compatible vector.

    Parameters
    ----------
    x : Vector or float
        Vector of same size to be multiplied (element-wise) or scalar to be multiplied to all vector elements.
    &#34;&#34;&#34;
    if isinstance(x, Vector):
        # &#39;x&#39; is another vector:
        self.value = numpy.matmul(self.value, x.value)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.multiply(self.value, x)
    else:
        raise Exception(f&#34;Vector multiplication failed: M*A is only supported when A is of type &#39;Vector&#39; or &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Multiply a scalar to all vector elements, or perform vector multiplication with a compatible vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code> or <code>float</code></dt>
<dd>Vector of same size to be multiplied (element-wise) or scalar to be multiplied to all vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, n: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, n:int):
    &#34;&#34;&#34;Set vector to given size and initialize all values to zero.

    Parameters
    ----------
    n : int
        Number of vector elements.
    &#34;&#34;&#34;
    self.n_entries = n
    self.value = numpy.zeros(n, dtype=numpy.float64)</code></pre>
</details>
<div class="desc"><p>Set vector to given size and initialize all values to zero.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self,<br>axis: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>,<br>angle: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, axis:&#39;Vector&#39;, angle:float):
    &#34;&#34;&#34; Rotate vector around given axis by given angle (in rad).

    Parameters
    ----------
    axis : Vector
        Rotation axis.

    angle : float
        Rotation angle (in rad).
    &#34;&#34;&#34;

    # Implementing a general rotation matrix.
    cs = math.cos(angle)
    sn = math.sin(angle)

    vx = self.x()
    vy = self.y()
    vz = self.z()

    nx = axis.unit_vector().x()
    ny = axis.unit_vector().y()
    nz = axis.unit_vector().z()

    rx = vx*(nx*nx*(1.0-cs) + cs)    + vy*(nx*ny*(1.0-cs) - nz*sn) + vz*(nx*nz*(1.0-cs) + ny*sn)
    ry = vx*(ny*nx*(1.0-cs) + nz*sn) + vy*(ny*ny*(1.0-cs) + cs)    + vz*(ny*nz*(1.0-cs) - nx*sn)
    rz = vx*(nz*nx*(1.0-cs) - ny*sn) + vy*(nz*ny*(1.0-cs) + nx*sn) + vz*(nz*nz*(1.0-cs) + cs)

    self.set(x=rx, y=ry, z=rz)</code></pre>
</details>
<div class="desc"><p>Rotate vector around given axis by given angle (in rad).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Rotation axis.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle (in rad).</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.rotate_2D_xy"><code class="name flex">
<span>def <span class="ident">rotate_2D_xy</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_2D_xy(self, angle:float):
    &#34;&#34;&#34; Rotate vector in xy plane.

    Parameters
    ----------
    angle : float
        Rotation angle (in rad).
    &#34;&#34;&#34;
    cs = math.cos(angle)
    sn = math.sin(angle)

    self.set_x(self.x()*cs - self.y()*sn)
    self.set_y(self.x()*sn + self.y()*cs)</code></pre>
</details>
<div class="desc"><p>Rotate vector in xy plane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle (in rad).</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.same_size"><code class="name flex">
<span>def <span class="ident">same_size</span></span>(<span>self,<br>x: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def same_size(self, x:&#39;Vector&#39;) -&gt; bool:
    &#34;&#34;&#34;Check if this vector has the same size (i.e., number of vector elements, not length!) as the given vector `x`.

    Returns
    -------
    same_dim : bool
        `True` if number of vector elements matches, `False` otherwise.
    &#34;&#34;&#34;

    if self.n_entries == x.n_entries:
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Check if this vector has the same size (i.e., number of vector elements, not length!) as the given vector <code>x</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>same_dim</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if number of vector elements matches, <code>False</code> otherwise.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, factor: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, factor:float):
    &#34;&#34;&#34;Scale vector by a scalar factor.

    Parameters
    ----------
    factor : float
        Factor that scales all vector elements.
    &#34;&#34;&#34;
    self.value = numpy.multiply(self.value, factor)
    self.update()</code></pre>
</details>
<div class="desc"><p>Scale vector by a scalar factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Factor that scales all vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: float) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor:float) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34; Get a copy of this vector, scaled by the given `factor`.

    Parameters
    ----------
    factor : float
        Factor that scales all vector elements.

    Returns
    -------
    result : Vector
        Scaled copy of this vector.
    &#34;&#34;&#34;
    result = self.get_copy()
    result.scale(factor)
    return result</code></pre>
</details>
<div class="desc"><p>Get a copy of this vector, scaled by the given <code>factor</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Factor that scales all vector elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Scaled copy of this vector.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, x: float = 0, y: float = 0, z: float = 0, w: float = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, x:float=0, y:float=0, z:float=0, w:float=None):
    &#34;&#34;&#34; Set all vector components.

    Non-existing vector components (such as `w` for a 3D vector) should be set to `None`.

    Parameters
    ----------
    x : float
        Value for the first vector element.

    y : float, optional
        Value for the second vector element.

    z : float, optional
        Value for the third vector element.

    w : float, optional
        Value for the fourth vector element.
    &#34;&#34;&#34;
    if self.n_entries &gt; 0 and x is not None:
        self.value[0] = float(x)

    if self.n_entries &gt; 1 and y is not None:
        self.value[1] = float(y)

    if self.n_entries &gt; 2 and z is not None:
        self.value[2] = float(z)

    if self.n_entries &gt; 3 and w is not None:
        self.value[3] = float(w)

    self.update()</code></pre>
</details>
<div class="desc"><p>Set all vector components.</p>
<p>Non-existing vector components (such as <code>w</code> for a 3D vector) should be set to <code>None</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the first vector element.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for the second vector element.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for the third vector element.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Value for the fourth vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set_numpy_data_array"><code class="name flex">
<span>def <span class="ident">set_numpy_data_array</span></span>(<span>self, numpy_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_numpy_data_array(self, numpy_data):
    &#34;&#34;&#34;Provide a one-dimensional NumPy array for the vector data.
    The new vector size will be the same as the size of the NumPy array.

    Parameters
    ----------
    numpy_data : numpy.ndarray
        NumPy array for the new vector values.
    &#34;&#34;&#34;
    self.n_entries = len(numpy_data)
    self.value = numpy_data.astype(float)
    self.update()</code></pre>
</details>
<div class="desc"><p>Provide a one-dimensional NumPy array for the vector data.
The new vector size will be the same as the size of the NumPy array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>numpy_data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>NumPy array for the new vector values.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set_value_for_index"><code class="name flex">
<span>def <span class="ident">set_value_for_index</span></span>(<span>self, i: int, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value_for_index(self, i:int, value:float):
    &#34;&#34;&#34;Set value for element at vector index `i`.

    Parameters
    ----------
    i : int
        Index of the vector element.

    value : float
        New value for the vector element.
    &#34;&#34;&#34;
    self.value[i] = float(value)
    self.update()</code></pre>
</details>
<div class="desc"><p>Set value for element at vector index <code>i</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the vector element.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>New value for the vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set_w"><code class="name flex">
<span>def <span class="ident">set_w</span></span>(<span>self, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_w(self, value:float):
    &#34;&#34;&#34;Set vector&#39;s w value (i.e., value of fourth vector element).

    Parameters
    ----------
    value : float
        Value for the fourth vector element.
    &#34;&#34;&#34;
    self.value[3] = float(value)
    self.update()</code></pre>
</details>
<div class="desc"><p>Set vector's w value (i.e., value of fourth vector element).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the fourth vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set_x"><code class="name flex">
<span>def <span class="ident">set_x</span></span>(<span>self, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x(self, value:float):
    &#34;&#34;&#34;Set vector&#39;s x value (i.e., value of first vector element).

    Parameters
    ----------
    value : float
        Value for the first vector element.
    &#34;&#34;&#34;
    self.value[0] = float(value)
    self.update()</code></pre>
</details>
<div class="desc"><p>Set vector's x value (i.e., value of first vector element).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the first vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set_x_y"><code class="name flex">
<span>def <span class="ident">set_x_y</span></span>(<span>self, x: float = 0, y: float = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x_y(self, x:float=0, y:float=0):
    &#34;&#34;&#34;Set x and y component (relevant for 2D computations).

    Parameters
    ----------
    x : float
        Value for the first vector element.

    y : float
        Value for the second vector element.
    &#34;&#34;&#34;
    self.value[0] = float(x)
    self.value[1] = float(y)
    self.update()</code></pre>
</details>
<div class="desc"><p>Set x and y component (relevant for 2D computations).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the first vector element.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the second vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set_y"><code class="name flex">
<span>def <span class="ident">set_y</span></span>(<span>self, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_y(self, value:float):
    &#34;&#34;&#34;Set vector&#39;s y value (i.e., value of second vector element).

    Parameters
    ----------
    value : float
        Value for the second vector element.
    &#34;&#34;&#34;
    self.value[1] = float(value)
    self.update()</code></pre>
</details>
<div class="desc"><p>Set vector's y value (i.e., value of second vector element).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the second vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.set_z"><code class="name flex">
<span>def <span class="ident">set_z</span></span>(<span>self, value: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_z(self, value:float):
    &#34;&#34;&#34;Set vector&#39;s z value (i.e., value of third vector element).

    Parameters
    ----------
    value : float
        Value for the third vector element.
    &#34;&#34;&#34;
    self.value[2] = float(value)
    self.update()</code></pre>
</details>
<div class="desc"><p>Set vector's z value (i.e., value of third vector element).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value for the third vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self) -&gt; int:
    &#34;&#34;&#34;Get the number of vector elements.

    Returns
    -------
    n_entries : int
        Number of vector elements.
    &#34;&#34;&#34;
    return self.n_entries</code></pre>
</details>
<div class="desc"><p>Get the number of vector elements.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>n_entries</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.sqrt"><code class="name flex">
<span>def <span class="ident">sqrt</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sqrt(self):
    &#34;&#34;&#34; Set all elements of this vector to their square roots. &#34;&#34;&#34;
    self.value = numpy.sqrt(self.value)
    self.update()</code></pre>
</details>
<div class="desc"><p>Set all elements of this vector to their square roots.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.square"><code class="name flex">
<span>def <span class="ident">square</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def square(self):
    &#34;&#34;&#34; Square all elements of this vector. &#34;&#34;&#34;
    self.value = numpy.square(self.value)
    self.update()</code></pre>
</details>
<div class="desc"><p>Square all elements of this vector.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.squared"><code class="name flex">
<span>def <span class="ident">squared</span></span>(<span>self) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def squared(self) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34; Get a squared copy of this vector.

    Returns
    -------
    result : Vector
        Squared copy of this vector.
    &#34;&#34;&#34;
    result = self.get_copy()
    result.square()
    return result</code></pre>
</details>
<div class="desc"><p>Get a squared copy of this vector.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Squared copy of this vector.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.subtract"><code class="name flex">
<span>def <span class="ident">subtract</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract(self, x):
    &#34;&#34;&#34;Subtract a scalar from all vector elements, or subtract another compatible vector.

    Parameters
    ----------
    x : Vector or float
        Vector of same size to be subtracted (element-wise) or scalar to be subtracted from all vector elements.
    &#34;&#34;&#34;
    if isinstance(x, Vector):
        # &#39;x&#39; is another vector:
        if self.same_size(x):
            self.value = numpy.subtract(self.value, x.value)
        else:
            raise Exception(&#34;Incompatible vector sizes. Can only subtract vectors of same size.&#34;)
    elif isinstance(x, numbers.Number):
        # &#39;x&#39; is a scalar:
        self.value = numpy.subtract(self.value, x)
    else:
        raise Exception(f&#34;Vector subtraction failed: M-A is only supported when A is of type &#39;Vector&#39; or a scalar. The given type is not supported: {type(x)}.&#34;)</code></pre>
</details>
<div class="desc"><p>Subtract a scalar from all vector elements, or subtract another compatible vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code> or <code>float</code></dt>
<dd>Vector of same size to be subtracted (element-wise) or scalar to be subtracted from all vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self) -&gt; float:
    &#34;&#34;&#34; Get the sum of all vector elements.

    Returns
    -------
    sum : float
        Sum of all vector elements.
    &#34;&#34;&#34;
    return numpy.sum(self.value)</code></pre>
</details>
<div class="desc"><p>Get the sum of all vector elements.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sum</code></strong> :&ensp;<code>float</code></dt>
<dd>Sum of all vector elements.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.to"><code class="name flex">
<span>def <span class="ident">to</span></span>(<span>self,<br>x: <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a>) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to(self, x:&#39;Vector&#39;) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34; Get a vector that points from this location to the given location `x`.

    Parameters
    ----------
    x : Vector
        Second location vector.

    Returns
    -------
    pointer : Vector
        Vector that points from this vector&#39;s target point to the target point of the given vector `x`.
    &#34;&#34;&#34;
    return self.connection(self, x)</code></pre>
</details>
<div class="desc"><p>Get a vector that points from this location to the given location <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Second location vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pointer</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Vector that points from this vector's target point to the target point of the given vector <code>x</code>.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self,<br>M: <a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, M:&#39;Matrix&#39;):
    &#34;&#34;&#34;Apply the transformation given by matrix `M` to this vector.

    Parameters
    ----------
    M : Matrix
        Transformation matrix.
    &#34;&#34;&#34;
    result = M*self
    self.n_entries = result.n_entries
    self.value     = result.value
    self.update()</code></pre>
</details>
<div class="desc"><p>Apply the transformation given by matrix <code>M</code> to this vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>M</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code></dt>
<dd>Transformation matrix.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.unit_vector"><code class="name flex">
<span>def <span class="ident">unit_vector</span></span>(<span>self) ‑> <a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_vector(self) -&gt; &#39;Vector&#39;:
    &#34;&#34;&#34; Get a unit vector that points in the same direction as this vector.

    Returns
    -------
    unit_vector : Vector
        Unit vector for this vector.

    Note
    ----
    If this vector changes, the returned unit vector object will be invalidated. To store the unit vector permanently, get a copy of the unit vector (using `get_copy()`) so it won&#39;t change:

    ```python
    unitv = v.unit_vector().get_copy()
    ```
    &#34;&#34;&#34;
    if self._unit_vector is None:
        self._unit_vector = self.get_copy()
        self._unit_vector.make_unit_vector()

    return self._unit_vector</code></pre>
</details>
<div class="desc"><p>Get a unit vector that points in the same direction as this vector.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>unit_vector</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Unit vector for this vector.</dd>
</dl>
<h2 id="note">Note</h2>
<p>If this vector changes, the returned unit vector object will be invalidated. To store the unit vector permanently, get a copy of the unit vector (using <code>get_copy()</code>) so it won't change:</p>
<pre><code class="language-python">unitv = v.unit_vector().get_copy()
</code></pre></div>
</dd>
<dt id="ctsimu.primitives.Vector.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Called when vector is changed.

    Invalidates private member variables for length and unit vector,
    so they will be re-calculated the next time their public getter
    functions are called.
    &#34;&#34;&#34;
    self._unit_vector = None
    self._length = None</code></pre>
</details>
<div class="desc"><p>Called when vector is changed.</p>
<p>Invalidates private member variables for length and unit vector,
so they will be re-calculated the next time their public getter
functions are called.</p></div>
</dd>
<dt id="ctsimu.primitives.Vector.w"><code class="name flex">
<span>def <span class="ident">w</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def w(self) -&gt; float:
    &#34;&#34;&#34;Get fourth vector element.

    Returns
    -------
    w : float

        Fourth vector element.
    &#34;&#34;&#34;
    return self.value[3]</code></pre>
</details>
<div class="desc"><p>Get fourth vector element.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Fourth vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.x"><code class="name flex">
<span>def <span class="ident">x</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x(self) -&gt; float:
    &#34;&#34;&#34;Get first vector element.

    Returns
    -------
    x : float
        First vector element.
    &#34;&#34;&#34;
    return self.value[0]</code></pre>
</details>
<div class="desc"><p>Get first vector element.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>First vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.y"><code class="name flex">
<span>def <span class="ident">y</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y(self) -&gt; float:
    &#34;&#34;&#34;Get second vector element.

    Returns
    -------
    y : float
        Second vector element.
    &#34;&#34;&#34;
    return self.value[1]</code></pre>
</details>
<div class="desc"><p>Get second vector element.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Second vector element.</dd>
</dl></div>
</dd>
<dt id="ctsimu.primitives.Vector.z"><code class="name flex">
<span>def <span class="ident">z</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def z(self) -&gt; float:
    &#34;&#34;&#34;Get third vector element.

    Returns
    -------
    z : float

        Third vector element.
    &#34;&#34;&#34;
    return self.value[2]</code></pre>
</details>
<div class="desc"><p>Get third vector element.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Third vector element.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu" href="index.html">ctsimu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctsimu.primitives.rotation_matrix" href="#ctsimu.primitives.rotation_matrix">rotation_matrix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.primitives.Line2D" href="#ctsimu.primitives.Line2D">Line2D</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.primitives.Line2D.intersection" href="#ctsimu.primitives.Line2D.intersection">intersection</a></code></li>
<li><code><a title="ctsimu.primitives.Line2D.set" href="#ctsimu.primitives.Line2D.set">set</a></code></li>
<li><code><a title="ctsimu.primitives.Line2D.set_from_points" href="#ctsimu.primitives.Line2D.set_from_points">set_from_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.primitives.Matrix" href="#ctsimu.primitives.Matrix">Matrix</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.primitives.Matrix.add" href="#ctsimu.primitives.Matrix.add">add</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.copy" href="#ctsimu.primitives.Matrix.copy">copy</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.divide" href="#ctsimu.primitives.Matrix.divide">divide</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.floor_divide" href="#ctsimu.primitives.Matrix.floor_divide">floor_divide</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.get" href="#ctsimu.primitives.Matrix.get">get</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.get_copy" href="#ctsimu.primitives.Matrix.get_copy">get_copy</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.make_identity" href="#ctsimu.primitives.Matrix.make_identity">make_identity</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.multiply" href="#ctsimu.primitives.Matrix.multiply">multiply</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.reset" href="#ctsimu.primitives.Matrix.reset">reset</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.same_size" href="#ctsimu.primitives.Matrix.same_size">same_size</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.scale" href="#ctsimu.primitives.Matrix.scale">scale</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.set" href="#ctsimu.primitives.Matrix.set">set</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.set_numpy_data_array" href="#ctsimu.primitives.Matrix.set_numpy_data_array">set_numpy_data_array</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.size" href="#ctsimu.primitives.Matrix.size">size</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.subtract" href="#ctsimu.primitives.Matrix.subtract">subtract</a></code></li>
<li><code><a title="ctsimu.primitives.Matrix.update_rows_cols" href="#ctsimu.primitives.Matrix.update_rows_cols">update_rows_cols</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.primitives.Polygon" href="#ctsimu.primitives.Polygon">Polygon</a></code></h4>
<ul class="two-column">
<li><code><a title="ctsimu.primitives.Polygon.area" href="#ctsimu.primitives.Polygon.area">area</a></code></li>
<li><code><a title="ctsimu.primitives.Polygon.clip" href="#ctsimu.primitives.Polygon.clip">clip</a></code></li>
<li><code><a title="ctsimu.primitives.Polygon.get_bounding_box" href="#ctsimu.primitives.Polygon.get_bounding_box">get_bounding_box</a></code></li>
<li><code><a title="ctsimu.primitives.Polygon.is_inside_2D" href="#ctsimu.primitives.Polygon.is_inside_2D">is_inside_2D</a></code></li>
<li><code><a title="ctsimu.primitives.Polygon.make_3D" href="#ctsimu.primitives.Polygon.make_3D">make_3D</a></code></li>
<li><code><a title="ctsimu.primitives.Polygon.set" href="#ctsimu.primitives.Polygon.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.primitives.Vector" href="#ctsimu.primitives.Vector">Vector</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.primitives.Vector.absmax" href="#ctsimu.primitives.Vector.absmax">absmax</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.absmax_nonzero" href="#ctsimu.primitives.Vector.absmax_nonzero">absmax_nonzero</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.absmin" href="#ctsimu.primitives.Vector.absmin">absmin</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.absmin_nonzero" href="#ctsimu.primitives.Vector.absmin_nonzero">absmin_nonzero</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.add" href="#ctsimu.primitives.Vector.add">add</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.angle" href="#ctsimu.primitives.Vector.angle">angle</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.connection" href="#ctsimu.primitives.Vector.connection">connection</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.cross" href="#ctsimu.primitives.Vector.cross">cross</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.cross_z" href="#ctsimu.primitives.Vector.cross_z">cross_z</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.crystal_direction" href="#ctsimu.primitives.Vector.crystal_direction">crystal_direction</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.distance" href="#ctsimu.primitives.Vector.distance">distance</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.divide" href="#ctsimu.primitives.Vector.divide">divide</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.dot" href="#ctsimu.primitives.Vector.dot">dot</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.floor_divide" href="#ctsimu.primitives.Vector.floor_divide">floor_divide</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.get" href="#ctsimu.primitives.Vector.get">get</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.get_copy" href="#ctsimu.primitives.Vector.get_copy">get_copy</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.inverse" href="#ctsimu.primitives.Vector.inverse">inverse</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.invert" href="#ctsimu.primitives.Vector.invert">invert</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.length" href="#ctsimu.primitives.Vector.length">length</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.make_crystal_vector" href="#ctsimu.primitives.Vector.make_crystal_vector">make_crystal_vector</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.make_unit_vector" href="#ctsimu.primitives.Vector.make_unit_vector">make_unit_vector</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.max" href="#ctsimu.primitives.Vector.max">max</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.min" href="#ctsimu.primitives.Vector.min">min</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.multiply" href="#ctsimu.primitives.Vector.multiply">multiply</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.reset" href="#ctsimu.primitives.Vector.reset">reset</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.rotate" href="#ctsimu.primitives.Vector.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.rotate_2D_xy" href="#ctsimu.primitives.Vector.rotate_2D_xy">rotate_2D_xy</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.same_size" href="#ctsimu.primitives.Vector.same_size">same_size</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.scale" href="#ctsimu.primitives.Vector.scale">scale</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.scaled" href="#ctsimu.primitives.Vector.scaled">scaled</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set" href="#ctsimu.primitives.Vector.set">set</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set_numpy_data_array" href="#ctsimu.primitives.Vector.set_numpy_data_array">set_numpy_data_array</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set_value_for_index" href="#ctsimu.primitives.Vector.set_value_for_index">set_value_for_index</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set_w" href="#ctsimu.primitives.Vector.set_w">set_w</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set_x" href="#ctsimu.primitives.Vector.set_x">set_x</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set_x_y" href="#ctsimu.primitives.Vector.set_x_y">set_x_y</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set_y" href="#ctsimu.primitives.Vector.set_y">set_y</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.set_z" href="#ctsimu.primitives.Vector.set_z">set_z</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.size" href="#ctsimu.primitives.Vector.size">size</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.sqrt" href="#ctsimu.primitives.Vector.sqrt">sqrt</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.square" href="#ctsimu.primitives.Vector.square">square</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.squared" href="#ctsimu.primitives.Vector.squared">squared</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.subtract" href="#ctsimu.primitives.Vector.subtract">subtract</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.sum" href="#ctsimu.primitives.Vector.sum">sum</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.to" href="#ctsimu.primitives.Vector.to">to</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.transform" href="#ctsimu.primitives.Vector.transform">transform</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.unit_vector" href="#ctsimu.primitives.Vector.unit_vector">unit_vector</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.update" href="#ctsimu.primitives.Vector.update">update</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.w" href="#ctsimu.primitives.Vector.w">w</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.x" href="#ctsimu.primitives.Vector.x">x</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.y" href="#ctsimu.primitives.Vector.y">y</a></code></li>
<li><code><a title="ctsimu.primitives.Vector.z" href="#ctsimu.primitives.Vector.z">z</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
