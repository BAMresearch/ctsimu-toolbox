<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctsimu.scenario.detector API documentation</title>
<meta name="description" content="A CTSimU detector: position, orientation, size, and other parameters." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.scenario.detector</code></h1>
</header>
<section id="section-intro">
<p>A CTSimU detector: position, orientation, size, and other parameters.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-
&#34;&#34;&#34;
A CTSimU detector: position, orientation, size, and other parameters.
&#34;&#34;&#34;

from ..helpers import *
from ..geometry import *
from .part import Part
from .parameter import Parameter
from .group import Group, Array

class Detector(Part):
        &#34;&#34;&#34;CTSimU detector.&#34;&#34;&#34;
        def __init__(self, _root=None):
                Part.__init__(self, name=&#34;detector&#34;, _root=_root)

                # Detector parameters
                self.set(key=&#34;model&#34;,            value=None,    native_unit=&#34;string&#34;, simple=True)
                self.set(key=&#34;manufacturer&#34;,     value=None,    native_unit=&#34;string&#34;, simple=True)
                self.set(key=&#34;type&#34;,             value=&#34;ideal&#34;, native_unit=&#34;string&#34;, simple=True, valid_values=[None, &#34;ideal&#34;, &#34;real&#34;])
                self.set(key=&#34;columns&#34;,          value=1000,    native_unit=&#34;px&#34;)
                self.set(key=&#34;rows&#34;,             value=1000,    native_unit=&#34;px&#34;)

                self.new_subgroup(&#34;pixel_pitch&#34;)
                self.pixel_pitch.set(key=&#34;u&#34;,    value=0.1,     native_unit=&#34;mm&#34;)
                self.pixel_pitch.set(key=&#34;v&#34;,    value=0.1,     native_unit=&#34;mm&#34;)

                self.set(key=&#34;bit_depth&#34;,        value=16,      native_unit=None)
                self.set(key=&#34;integration_time&#34;, value=1.0,     native_unit=&#34;s&#34;)
                self.set(key=&#34;dead_time&#34;,        value=1.0,     native_unit=&#34;s&#34;)
                self.set(key=&#34;image_lag&#34;,        value=0.0,     native_unit=None)
                self.set(key=&#34;gain&#34;,             value=None,    native_unit=None)

                # Properties for gray value reproduction:
                self.new_subgroup(&#34;gray_value&#34;)
                self.gray_value.add_alternative_name(&#34;grey_value&#34;)
                self.gray_value.set(key=&#34;imin&#34;,   value=0,     native_unit=None)
                self.gray_value.set(key=&#34;imax&#34;,   value=60000, native_unit=None)
                self.gray_value.set(key=&#34;factor&#34;, value=None,  native_unit=&#34;1/J&#34;)
                self.gray_value.set(key=&#34;offset&#34;, value=None,  native_unit=None)
                self.gray_value.set(key=&#34;intensity_characteristics_file&#34;,  value=None, native_unit=&#34;string&#34;)
                self.gray_value.set(key=&#34;efficiency_characteristics_file&#34;, value=None, native_unit=&#34;string&#34;)

                # Noise:
                self.new_subgroup(&#34;noise&#34;)
                self.noise.set(key=&#34;snr_at_imax&#34;,                value=None, native_unit=None)
                self.noise.set(key=&#34;noise_characteristics_file&#34;, value=None, native_unit=&#34;string&#34;)

                # Unsharpness:
                self.new_subgroup(&#34;unsharpness&#34;)
                self.unsharpness.add_alternative_name(&#34;sharpness&#34;)
                self.unsharpness.set(key=&#34;basic_spatial_resolution&#34;, value=None, native_unit=&#34;mm&#34;)
                self.unsharpness.set(key=&#34;mtf&#34;, value=None, native_unit=&#34;string&#34;)

                # Bad pixel map:
                self.new_subgroup(&#34;bad_pixel_map&#34;)
                self.bad_pixel_map.set(key=&#34;file&#34;,       value=None, native_unit=&#34;string&#34;)
                # dim_x and dim_y not necessary. Must match detector columns/rows.
                #self.bad_pixel_map.set(key=&#34;dim_x&#34;,      value=None, simple=True)
                #self.bad_pixel_map.set(key=&#34;dim_y&#34;,      value=None, simple=True)
                self.bad_pixel_map.set(key=&#34;type&#34;,       value=&#34;int16&#34;,  native_unit=&#34;string&#34;, simple=True)
                self.bad_pixel_map.set(key=&#34;endian&#34;,     value=&#34;little&#34;, native_unit=&#34;string&#34;, simple=True)
                self.bad_pixel_map.set(key=&#34;headersize&#34;, value=0, simple=True)

                # Scintillator
                self.new_subgroup(&#34;scintillator&#34;)
                self.scintillator.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.scintillator.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)

                # Window
                self.new_subgroup(&#34;window&#34;)
                self.window.new_subgroup(&#34;front&#34;, array=True)
                self.window.front.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.window.front.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)
                self.window.new_subgroup(&#34;rear&#34;, array=True)
                self.window.rear.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.window.rear.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)

                # Filters
                self.new_subgroup(&#34;filters&#34;)
                self.filters.new_subgroup(&#34;front&#34;, array=True)
                self.filters.front.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.filters.front.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)
                self.filters.new_subgroup(&#34;rear&#34;, array=True)
                self.filters.rear.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.filters.rear.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)

        def check(self):
                # Check if the detector type is valid:
                if not (self.get(&#34;type&#34;) in valid_detector_types):
                        raise ValueError(f&#34;Not a valid detector type: \&#39;{self.get(&#39;type&#39;)}\&#39;. Should be any of {valid_detector_types}.&#34;)
                        return False

                return True

        def physical_width(self) -&gt; float:
                &#34;&#34;&#34;Get detector&#39;s physical width in mm.

                Returns
                -------
                physical_width : float
                &#34;&#34;&#34;
                return float(self.get(&#34;pitch_u&#34;) * int(self.get(&#34;columns&#34;)))

        def physical_height(self) -&gt; float:
                &#34;&#34;&#34;Get detector&#39;s physical height in mm.

                Returns
                -------
                physical_height : float
                &#34;&#34;&#34;
                return float(self.get(&#34;pitch_v&#34;) * int(self.get(&#34;rows&#34;)))

        def pixel_area(self) -&gt; float:
                &#34;&#34;&#34;Get area of a single pixel in mm².

                Returns
                -------
                area : float
                        Pixel area in mm².
                &#34;&#34;&#34;
                return self.get(&#34;pitch_u&#34;) * self.get(&#34;pitch_v&#34;)

        def pixel_area_m2(self) -&gt; float:
                &#34;&#34;&#34;Get area of a single pixel in m².

                Returns
                -------
                area : float
                        Pixel area in m².
                &#34;&#34;&#34;
                return self.pixel_area() * 1.0e-6

        def max_gray_value(self) -&gt; int:
                &#34;&#34;&#34;The maximum gray value that can be stored using
                the detector bit depth, assuming gray values are stored as
                unsigned integers.

                Returns
                -------
                max_gray_value : int
                        2^bitdepth - 1
                &#34;&#34;&#34;
                return (2**self.get(&#34;bit_depth&#34;)) - 1

        def set_from_json(self, json_scenario:dict):
                &#34;&#34;&#34;Import the detector definition and geometry from the JSON object.
                The JSON object should contain the complete content
                of the scenario definition file
                (at least the geometry and detector sections).

                Parameters
                ----------
                json_scenario : dict
                        A complete CTSimU scenario object, as imported from a JSON structure.
                &#34;&#34;&#34;
                self.reset()

                # Extract the detector&#39;s geometry:
                geo = json_extract(json_scenario, [&#34;geometry&#34;, &#34;detector&#34;])
                self.set_geometry(json_geometry_object=geo, proper_cs=&#34;local&#34;)

                # Detector properties:
                detprops = json_extract(json_scenario, [&#34;detector&#34;])
                Group.set_from_json(self, detprops)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.scenario.detector.Detector"><code class="flex name class">
<span>class <span class="ident">Detector</span></span>
</code></dt>
<dd>
<div class="desc"><p>CTSimU detector.</p>
<p>The part's name can be set upon initialization.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name for the part.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Detector(Part):
        &#34;&#34;&#34;CTSimU detector.&#34;&#34;&#34;
        def __init__(self, _root=None):
                Part.__init__(self, name=&#34;detector&#34;, _root=_root)

                # Detector parameters
                self.set(key=&#34;model&#34;,            value=None,    native_unit=&#34;string&#34;, simple=True)
                self.set(key=&#34;manufacturer&#34;,     value=None,    native_unit=&#34;string&#34;, simple=True)
                self.set(key=&#34;type&#34;,             value=&#34;ideal&#34;, native_unit=&#34;string&#34;, simple=True, valid_values=[None, &#34;ideal&#34;, &#34;real&#34;])
                self.set(key=&#34;columns&#34;,          value=1000,    native_unit=&#34;px&#34;)
                self.set(key=&#34;rows&#34;,             value=1000,    native_unit=&#34;px&#34;)

                self.new_subgroup(&#34;pixel_pitch&#34;)
                self.pixel_pitch.set(key=&#34;u&#34;,    value=0.1,     native_unit=&#34;mm&#34;)
                self.pixel_pitch.set(key=&#34;v&#34;,    value=0.1,     native_unit=&#34;mm&#34;)

                self.set(key=&#34;bit_depth&#34;,        value=16,      native_unit=None)
                self.set(key=&#34;integration_time&#34;, value=1.0,     native_unit=&#34;s&#34;)
                self.set(key=&#34;dead_time&#34;,        value=1.0,     native_unit=&#34;s&#34;)
                self.set(key=&#34;image_lag&#34;,        value=0.0,     native_unit=None)
                self.set(key=&#34;gain&#34;,             value=None,    native_unit=None)

                # Properties for gray value reproduction:
                self.new_subgroup(&#34;gray_value&#34;)
                self.gray_value.add_alternative_name(&#34;grey_value&#34;)
                self.gray_value.set(key=&#34;imin&#34;,   value=0,     native_unit=None)
                self.gray_value.set(key=&#34;imax&#34;,   value=60000, native_unit=None)
                self.gray_value.set(key=&#34;factor&#34;, value=None,  native_unit=&#34;1/J&#34;)
                self.gray_value.set(key=&#34;offset&#34;, value=None,  native_unit=None)
                self.gray_value.set(key=&#34;intensity_characteristics_file&#34;,  value=None, native_unit=&#34;string&#34;)
                self.gray_value.set(key=&#34;efficiency_characteristics_file&#34;, value=None, native_unit=&#34;string&#34;)

                # Noise:
                self.new_subgroup(&#34;noise&#34;)
                self.noise.set(key=&#34;snr_at_imax&#34;,                value=None, native_unit=None)
                self.noise.set(key=&#34;noise_characteristics_file&#34;, value=None, native_unit=&#34;string&#34;)

                # Unsharpness:
                self.new_subgroup(&#34;unsharpness&#34;)
                self.unsharpness.add_alternative_name(&#34;sharpness&#34;)
                self.unsharpness.set(key=&#34;basic_spatial_resolution&#34;, value=None, native_unit=&#34;mm&#34;)
                self.unsharpness.set(key=&#34;mtf&#34;, value=None, native_unit=&#34;string&#34;)

                # Bad pixel map:
                self.new_subgroup(&#34;bad_pixel_map&#34;)
                self.bad_pixel_map.set(key=&#34;file&#34;,       value=None, native_unit=&#34;string&#34;)
                # dim_x and dim_y not necessary. Must match detector columns/rows.
                #self.bad_pixel_map.set(key=&#34;dim_x&#34;,      value=None, simple=True)
                #self.bad_pixel_map.set(key=&#34;dim_y&#34;,      value=None, simple=True)
                self.bad_pixel_map.set(key=&#34;type&#34;,       value=&#34;int16&#34;,  native_unit=&#34;string&#34;, simple=True)
                self.bad_pixel_map.set(key=&#34;endian&#34;,     value=&#34;little&#34;, native_unit=&#34;string&#34;, simple=True)
                self.bad_pixel_map.set(key=&#34;headersize&#34;, value=0, simple=True)

                # Scintillator
                self.new_subgroup(&#34;scintillator&#34;)
                self.scintillator.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.scintillator.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)

                # Window
                self.new_subgroup(&#34;window&#34;)
                self.window.new_subgroup(&#34;front&#34;, array=True)
                self.window.front.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.window.front.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)
                self.window.new_subgroup(&#34;rear&#34;, array=True)
                self.window.rear.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.window.rear.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)

                # Filters
                self.new_subgroup(&#34;filters&#34;)
                self.filters.new_subgroup(&#34;front&#34;, array=True)
                self.filters.front.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.filters.front.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)
                self.filters.new_subgroup(&#34;rear&#34;, array=True)
                self.filters.rear.set(key=&#34;material_id&#34;, value=None, native_unit=&#34;string&#34;, simple=True)
                self.filters.rear.set(key=&#34;thickness&#34;,   value=None, native_unit=&#34;mm&#34;)

        def check(self):
                # Check if the detector type is valid:
                if not (self.get(&#34;type&#34;) in valid_detector_types):
                        raise ValueError(f&#34;Not a valid detector type: \&#39;{self.get(&#39;type&#39;)}\&#39;. Should be any of {valid_detector_types}.&#34;)
                        return False

                return True

        def physical_width(self) -&gt; float:
                &#34;&#34;&#34;Get detector&#39;s physical width in mm.

                Returns
                -------
                physical_width : float
                &#34;&#34;&#34;
                return float(self.get(&#34;pitch_u&#34;) * int(self.get(&#34;columns&#34;)))

        def physical_height(self) -&gt; float:
                &#34;&#34;&#34;Get detector&#39;s physical height in mm.

                Returns
                -------
                physical_height : float
                &#34;&#34;&#34;
                return float(self.get(&#34;pitch_v&#34;) * int(self.get(&#34;rows&#34;)))

        def pixel_area(self) -&gt; float:
                &#34;&#34;&#34;Get area of a single pixel in mm².

                Returns
                -------
                area : float
                        Pixel area in mm².
                &#34;&#34;&#34;
                return self.get(&#34;pitch_u&#34;) * self.get(&#34;pitch_v&#34;)

        def pixel_area_m2(self) -&gt; float:
                &#34;&#34;&#34;Get area of a single pixel in m².

                Returns
                -------
                area : float
                        Pixel area in m².
                &#34;&#34;&#34;
                return self.pixel_area() * 1.0e-6

        def max_gray_value(self) -&gt; int:
                &#34;&#34;&#34;The maximum gray value that can be stored using
                the detector bit depth, assuming gray values are stored as
                unsigned integers.

                Returns
                -------
                max_gray_value : int
                        2^bitdepth - 1
                &#34;&#34;&#34;
                return (2**self.get(&#34;bit_depth&#34;)) - 1

        def set_from_json(self, json_scenario:dict):
                &#34;&#34;&#34;Import the detector definition and geometry from the JSON object.
                The JSON object should contain the complete content
                of the scenario definition file
                (at least the geometry and detector sections).

                Parameters
                ----------
                json_scenario : dict
                        A complete CTSimU scenario object, as imported from a JSON structure.
                &#34;&#34;&#34;
                self.reset()

                # Extract the detector&#39;s geometry:
                geo = json_extract(json_scenario, [&#34;geometry&#34;, &#34;detector&#34;])
                self.set_geometry(json_geometry_object=geo, proper_cs=&#34;local&#34;)

                # Detector properties:
                detprops = json_extract(json_scenario, [&#34;detector&#34;])
                Group.set_from_json(self, detprops)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctsimu.scenario.part.Part" href="part.html#ctsimu.scenario.part.Part">Part</a></li>
<li><a title="ctsimu.scenario.group.Group" href="group.html#ctsimu.scenario.group.Group">Group</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.scenario.detector.Detector.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self):
        # Check if the detector type is valid:
        if not (self.get(&#34;type&#34;) in valid_detector_types):
                raise ValueError(f&#34;Not a valid detector type: \&#39;{self.get(&#39;type&#39;)}\&#39;. Should be any of {valid_detector_types}.&#34;)
                return False

        return True</code></pre>
</details>
</dd>
<dt id="ctsimu.scenario.detector.Detector.max_gray_value"><code class="name flex">
<span>def <span class="ident">max_gray_value</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>The maximum gray value that can be stored using
the detector bit depth, assuming gray values are stored as
unsigned integers.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>max_gray_value</code></strong> :&ensp;<code>int</code></dt>
<dd>2^bitdepth - 1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_gray_value(self) -&gt; int:
        &#34;&#34;&#34;The maximum gray value that can be stored using
        the detector bit depth, assuming gray values are stored as
        unsigned integers.

        Returns
        -------
        max_gray_value : int
                2^bitdepth - 1
        &#34;&#34;&#34;
        return (2**self.get(&#34;bit_depth&#34;)) - 1</code></pre>
</details>
</dd>
<dt id="ctsimu.scenario.detector.Detector.physical_height"><code class="name flex">
<span>def <span class="ident">physical_height</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get detector's physical height in mm.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>physical_height</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_height(self) -&gt; float:
        &#34;&#34;&#34;Get detector&#39;s physical height in mm.

        Returns
        -------
        physical_height : float
        &#34;&#34;&#34;
        return float(self.get(&#34;pitch_v&#34;) * int(self.get(&#34;rows&#34;)))</code></pre>
</details>
</dd>
<dt id="ctsimu.scenario.detector.Detector.physical_width"><code class="name flex">
<span>def <span class="ident">physical_width</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get detector's physical width in mm.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>physical_width</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_width(self) -&gt; float:
        &#34;&#34;&#34;Get detector&#39;s physical width in mm.

        Returns
        -------
        physical_width : float
        &#34;&#34;&#34;
        return float(self.get(&#34;pitch_u&#34;) * int(self.get(&#34;columns&#34;)))</code></pre>
</details>
</dd>
<dt id="ctsimu.scenario.detector.Detector.pixel_area"><code class="name flex">
<span>def <span class="ident">pixel_area</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get area of a single pixel in mm².</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel area in mm².</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixel_area(self) -&gt; float:
        &#34;&#34;&#34;Get area of a single pixel in mm².

        Returns
        -------
        area : float
                Pixel area in mm².
        &#34;&#34;&#34;
        return self.get(&#34;pitch_u&#34;) * self.get(&#34;pitch_v&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.scenario.detector.Detector.pixel_area_m2"><code class="name flex">
<span>def <span class="ident">pixel_area_m2</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get area of a single pixel in m².</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel area in m².</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixel_area_m2(self) -&gt; float:
        &#34;&#34;&#34;Get area of a single pixel in m².

        Returns
        -------
        area : float
                Pixel area in m².
        &#34;&#34;&#34;
        return self.pixel_area() * 1.0e-6</code></pre>
</details>
</dd>
<dt id="ctsimu.scenario.detector.Detector.set_from_json"><code class="name flex">
<span>def <span class="ident">set_from_json</span></span>(<span>self, json_scenario: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Import the detector definition and geometry from the JSON object.
The JSON object should contain the complete content
of the scenario definition file
(at least the geometry and detector sections).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>json_scenario</code></strong> :&ensp;<code>dict</code></dt>
<dd>A complete CTSimU scenario object, as imported from a JSON structure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_from_json(self, json_scenario:dict):
        &#34;&#34;&#34;Import the detector definition and geometry from the JSON object.
        The JSON object should contain the complete content
        of the scenario definition file
        (at least the geometry and detector sections).

        Parameters
        ----------
        json_scenario : dict
                A complete CTSimU scenario object, as imported from a JSON structure.
        &#34;&#34;&#34;
        self.reset()

        # Extract the detector&#39;s geometry:
        geo = json_extract(json_scenario, [&#34;geometry&#34;, &#34;detector&#34;])
        self.set_geometry(json_geometry_object=geo, proper_cs=&#34;local&#34;)

        # Detector properties:
        detprops = json_extract(json_scenario, [&#34;detector&#34;])
        Group.set_from_json(self, detprops)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctsimu.scenario.part.Part" href="part.html#ctsimu.scenario.part.Part">Part</a></b></code>:
<ul class="hlist">
<li><code><a title="ctsimu.scenario.part.Part.acknowledge_change" href="group.html#ctsimu.scenario.group.Group.acknowledge_change">acknowledge_change</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.attach_to_stage" href="part.html#ctsimu.scenario.part.Part.attach_to_stage">attach_to_stage</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.changed" href="group.html#ctsimu.scenario.group.Group.changed">changed</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.geometry_dict" href="part.html#ctsimu.scenario.part.Part.geometry_dict">geometry_dict</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.get" href="group.html#ctsimu.scenario.group.Group.get">get</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.is_attached_to_stage" href="part.html#ctsimu.scenario.part.Part.is_attached_to_stage">is_attached_to_stage</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.json_dict" href="group.html#ctsimu.scenario.group.Group.json_dict">json_dict</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.parameter" href="group.html#ctsimu.scenario.group.Group.parameter">parameter</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.reset" href="part.html#ctsimu.scenario.part.Part.reset">reset</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set" href="group.html#ctsimu.scenario.group.Group.set">set</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_center" href="part.html#ctsimu.scenario.part.Part.set_center">set_center</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_frame" href="part.html#ctsimu.scenario.part.Part.set_frame">set_frame</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_geometry" href="part.html#ctsimu.scenario.part.Part.set_geometry">set_geometry</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_name" href="part.html#ctsimu.scenario.part.Part.set_name">set_name</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_parameter" href="group.html#ctsimu.scenario.group.Group.set_parameter">set_parameter</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_parameter_from_key" href="group.html#ctsimu.scenario.group.Group.set_parameter_from_key">set_parameter_from_key</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_parameter_from_possible_keys" href="group.html#ctsimu.scenario.group.Group.set_parameter_from_possible_keys">set_parameter_from_possible_keys</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_parameter_value" href="group.html#ctsimu.scenario.group.Group.set_parameter_value">set_parameter_value</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_u" href="part.html#ctsimu.scenario.part.Part.set_u">set_u</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.set_w" href="part.html#ctsimu.scenario.part.Part.set_w">set_w</a></code></li>
<li><code><a title="ctsimu.scenario.part.Part.standard_value" href="group.html#ctsimu.scenario.group.Group.standard_value">standard_value</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu.scenario" href="index.html">ctsimu.scenario</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.scenario.detector.Detector" href="#ctsimu.scenario.detector.Detector">Detector</a></code></h4>
<ul class="two-column">
<li><code><a title="ctsimu.scenario.detector.Detector.check" href="#ctsimu.scenario.detector.Detector.check">check</a></code></li>
<li><code><a title="ctsimu.scenario.detector.Detector.max_gray_value" href="#ctsimu.scenario.detector.Detector.max_gray_value">max_gray_value</a></code></li>
<li><code><a title="ctsimu.scenario.detector.Detector.physical_height" href="#ctsimu.scenario.detector.Detector.physical_height">physical_height</a></code></li>
<li><code><a title="ctsimu.scenario.detector.Detector.physical_width" href="#ctsimu.scenario.detector.Detector.physical_width">physical_width</a></code></li>
<li><code><a title="ctsimu.scenario.detector.Detector.pixel_area" href="#ctsimu.scenario.detector.Detector.pixel_area">pixel_area</a></code></li>
<li><code><a title="ctsimu.scenario.detector.Detector.pixel_area_m2" href="#ctsimu.scenario.detector.Detector.pixel_area_m2">pixel_area_m2</a></code></li>
<li><code><a title="ctsimu.scenario.detector.Detector.set_from_json" href="#ctsimu.scenario.detector.Detector.set_from_json">set_from_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>