<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>ctsimu.scenario.drift API documentation</title>
<meta name="description" content="Drift structure for a `ctsimu.scenario.parameter.Parameter`.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.scenario.drift</code></h1>
</header>
<section id="section-intro">
<p>Drift structure for a <code><a title="ctsimu.scenario.parameter.Parameter" href="parameter.html#ctsimu.scenario.parameter.Parameter">Parameter</a></code>.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.scenario.drift.Drift"><code class="flex name class">
<span>class <span class="ident">Drift</span></span>
<span>(</span><span>native_unit: str, preferred_unit: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Drift structure for a parameter.
Drifts typically belong to a <code><a title="ctsimu.scenario.parameter.Parameter" href="parameter.html#ctsimu.scenario.parameter.Parameter">Parameter</a></code> object,
which keeps a list of possible parameter drifts.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>list</code></dt>
<dd>List of drift values. If the number of drift values does not
match the number of frames in the CT scan, a linear interpolation
between the drift values can be used to calculate the drift value
for a specific frame.</dd>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The drift's native unit. Should match the native unit of the
<code><a title="ctsimu.scenario.parameter.Parameter" href="parameter.html#ctsimu.scenario.parameter.Parameter">Parameter</a></code> object to which this drift belongs.
Possible values: <code>None</code>, <code>"mm"</code>, <code>"rad"</code>, <code>"deg"</code>, <code>"s"</code>, <code>"mA"</code>, <code>"kV"</code>, <code>"g/cm^3"</code>, <code>"lp/mm"</code>, <code>"deg/s"</code>, <code>"C"</code>, <code>"bool"</code>, <code>"string"</code>.</dd>
<dt><strong><code>known_to_reconstruction</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should this parameter drift be considered by the reconstruction software?
This attribute is obeyed when calculating projection matrices.</dd>
<dt><strong><code>interpolation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Does a linear interpolation take place between the components of the
<code>trajectory</code> list if the number of trajectory components does not match
the number of frames in the CT scan?</dd>
</dl>
<p>A new drift object must be assigned a valid native unit
to enable the JSON parser to convert the drift values from the
JSON file, if necessary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The drift's native unit. Should match the native unit of the
<code><a title="ctsimu.scenario.parameter.Parameter" href="parameter.html#ctsimu.scenario.parameter.Parameter">Parameter</a></code> object to which this drift belongs.
Possible values: <code>None</code>, <code>"mm"</code>, <code>"rad"</code>, <code>"deg"</code>, <code>"s"</code>, <code>"mA"</code>, <code>"kV"</code>, <code>"g/cm^3"</code>, <code>"lp/mm"</code>, <code>"deg/s"</code>, <code>"C"</code>, <code>"bool"</code>, <code>"string"</code>.</dd>
<dt><strong><code>preferred_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Preferred unit to represent these drift values in the JSON file.
If set to <code>None</code>, the native unit will be used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Drift:
        &#34;&#34;&#34;Drift structure for a parameter.
        Drifts typically belong to a `ctsimu.scenario.parameter.Parameter` object,
        which keeps a list of possible parameter drifts.

        Attributes
        ----------
        trajectory : list
                List of drift values. If the number of drift values does not
                match the number of frames in the CT scan, a linear interpolation
                between the drift values can be used to calculate the drift value
                for a specific frame.

        native_unit : str
                The drift&#39;s native unit. Should match the native unit of the
                `ctsimu.scenario.parameter.Parameter` object to which this drift belongs.
                Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`, `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

        known_to_reconstruction : bool
                Should this parameter drift be considered by the reconstruction software?
                This attribute is obeyed when calculating projection matrices.

        interpolation : bool
                Does a linear interpolation take place between the components of the
                `trajectory` list if the number of trajectory components does not match
                the number of frames in the CT scan?
        &#34;&#34;&#34;

        def __init__(self, native_unit:str, preferred_unit:str=None, _root=None):
                &#34;&#34;&#34;A new drift object must be assigned a valid native unit
                to enable the JSON parser to convert the drift values from the
                JSON file, if necessary.

                Parameters
                ----------
                native_unit : str
                        The drift&#39;s native unit. Should match the native unit of the
                        `ctsimu.scenario.parameter.Parameter` object to which this drift belongs.
                        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`, `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

                preferred_unit : str
                        Preferred unit to represent these drift values in the JSON file.
                        If set to `None`, the native unit will be used.
                &#34;&#34;&#34;
                self._root = _root  # root scenario object

                self.value = []
                self.native_unit = native_unit

                if preferred_unit is not None:
                        self.preferred_unit = preferred_unit
                else:
                        self.preferred_unit = native_unit

                self.known_to_reconstruction = True
                self.interpolation = True

                self.reset()

        def reset(self):
                &#34;&#34;&#34;Clear the list of drift values, set `known_to_reconstruction` to `True`.&#34;&#34;&#34;
                self.known_to_reconstruction = True
                self.value = []

        def json_dict(self) -&gt; dict:
                &#34;&#34;&#34;Create a CTSimU JSON dictionary for this drift.

                Returns
                -------
                json_dict : dict
                &#34;&#34;&#34;
                jd = dict()
                if len(self.value) &gt; 0:
                        jd[&#34;value&#34;] = self.value
                else:
                        jd[&#34;value&#34;] = None

                if self.native_unit not in native_units_to_omit_in_json_file:
                        unit = self.native_unit
                        if self.preferred_unit is not None:
                                unit = self.preferred_unit

                                # Convert value to preferred unit:
                                conversion_factor = convert_to_native_unit(given_unit=self.preferred_unit, native_unit=self.native_unit, value=1)

                                if conversion_factor != 0:
                                        jd[&#34;value&#34;] = list()
                                        for val in self.value:
                                                jd[&#34;value&#34;].append(val/conversion_factor)

                        jd[&#34;unit&#34;] = unit

                jd[&#34;known_to_reconstruction&#34;] = self.known_to_reconstruction
                return jd

        def set_known_to_reconstruction(self, known:bool):
                &#34;&#34;&#34;Set the `known_to_reconstruction` property.

                Parameters
                ----------
                known : bool
                        Should the reconstruction software take this drift into account?
                &#34;&#34;&#34;
                self.known_to_reconstruction = known

        def set_interpolation(self, intpol:bool):
                &#34;&#34;&#34;Set the `interpolation` property. Only necessary for
                number-type parameters. String parameters cannot run an interpolation.

                Parameters
                ----------
                intpol : bool
                        `True` if the drift value should be interpolated if the number of
                        drift components does not match the number of frames in the CT scan.
                        `False` if no interpolation should take place: the last drift value
                        that would match the given frame number is taken.
                &#34;&#34;&#34;
                self.interpolation = intpol

        def set_native_unit(self, native_unit:str):
                &#34;&#34;&#34;Set the drifts&#39;s native unit.

                Parameters
                ----------
                native_unit : str
                        New native unit for the drift.
                        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`, `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.
                &#34;&#34;&#34;
                if is_valid_native_unit(native_unit):
                        self.native_unit = native_unit

                        if native_unit == &#34;string&#34;:
                                self.interpolation = False

        def add_drift_component(self, value):
                &#34;&#34;&#34;Add a drift component to the list of drift values.

                Parameters
                ----------
                value : float or str or bool
                        Drift value. For number-type drifts (`float`), this is given as an
                        absolute deviation from the parameter&#39;s standard value.
                        For string-type drifts (`str`), this is the string that should replace
                        the parameter&#39;s standard value.
                &#34;&#34;&#34;
                self.value.append(value)

        def set_from_json(self, json_drift_object:dict) -&gt; bool:
                &#34;&#34;&#34;Set the drift from a given CTSimU drift structure.
                The proper `native_unit` must be set up correctly before
                running this function.

                Parameters
                ----------
                json_drift_object : dict
                        A CTSimU drift structure, imported from a JSON structure.

                Returns
                -------
                success : bool
                        `True` on success, `False` if an error occurred.
                &#34;&#34;&#34;
                self.reset()

                # Get JSON unit:
                if json_exists_and_not_null(json_drift_object, [&#34;unit&#34;]):
                        self.preferred_unit = get_value(
                                dictionary=json_drift_object,
                                keys=[&#34;unit&#34;],
                                fail_value=self.native_unit
                        )

                # Known to reconstruction
                if json_exists_and_not_null(json_drift_object, [&#34;known_to_reconstruction&#34;]):
                        self.set_known_to_reconstruction(
                                get_value_in_native_unit(
                                        native_unit=&#34;bool&#34;,
                                        dictionary=json_drift_object,
                                        keys=[&#34;known_to_reconstruction&#34;],
                                        fail_value=True
                                )
                        )

                # Get drift values:
                if json_exists_and_not_null(json_drift_object, [&#34;value&#34;]):
                        value = json_extract(json_drift_object, [&#34;value&#34;])
                        if isinstance(value, list):
                                # Drift value is an array.
                                for v in value:
                                        self.add_drift_component(
                                                convert_to_native_unit(self.preferred_unit, self.native_unit, v)
                                        )

                                return True
                        elif isinstance(value, numbers.Number):
                                # Interpret value as a single number:
                                self.add_drift_component(
                                        convert_to_native_unit(self.preferred_unit, self.native_unit, value)
                                )
                                return True
                elif json_exists_and_not_null(json_drift_object, [&#34;file&#34;]):
                        filename = json_extract(json_drift_object, [&#34;file&#34;])
                        if isinstance(filename, str):
                                # Read drift values from a file
                                if self._root is not None:
                                        # Get path relative to JSON file:
                                        rel_filename = self._root.path_of_external_file(filename)
                                else:
                                        rel_filename = filename

                                values = read_csv_file(rel_filename)

                                firstColumn = values[0]
                                for v in firstColumn:
                                        self.add_drift_component(float(v))

                                return True

                return False

        def get_value_for_frame(self, frame:float, n_frames:int) -&gt; float | str | bool:
                &#34;&#34;&#34;Return a drift value for the given `frame` number,
                assuming a total number of `n_frames` in the CT scan.
                If interpolation is activated, linear interpolation will
                take place between drift values, but also for frame numbers
                outside of the expected range: (frame &lt; 0) and (frame &gt;= n_frames).
                Note that the frame number starts at 0.

                Parameters
                ----------
                frame : float
                        Current frame number.

                n_frames : int
                        Total number of frames in scan.

                Returns
                -------
                value : float or str or bool
                        The drift&#39;s value for the given `frame` number.
                &#34;&#34;&#34;

                nTrajectoryPoints = len(self.value)
                if nTrajectoryPoints is not None:
                        if nTrajectoryPoints &gt; 1:
                                if n_frames &gt; 1:
                                        # We know that we have at least two drift values, so we are
                                        # on the safe side for linear interpolations.
                                        # We also know that we have at least two frames in the scan,
                                        # and can therefore map our &#34;scan progress&#34; (the current
                                        # frame number) to the array of drift values.

                                        lastFrameNr = n_frames - 1 # frames start counting at 0

                                        # Frame progress on a scale between 0 and 1.
                                        # 0: first frame (start), 1: last frame (finish).
                                        progress = float(frame) / float(lastFrameNr)

                                        # Calculate the theoretical array index to get the drift
                                        # value for the current frame from the array of drift values:
                                        lastTrajectoryIndex = int(nTrajectoryPoints - 1)
                                        trajectoryIndex = progress * float(lastTrajectoryIndex)

                                        if (progress &gt;= 0) and (progress &lt;= 1):
                                                # We are inside the array of drift values.
                                                leftIndex = int(math.floor(trajectoryIndex))

                                                if float(leftIndex) == float(trajectoryIndex):
                                                        # We are exactly at one trajectory point;
                                                        # no need for interpolation.
                                                        return self.value[leftIndex]

                                                if self.interpolation is True:
                                                        # Linear interpolation:
                                                        rightIndex = int(leftIndex + 1)

                                                        # We return a weighted average of the two drift
                                                        # values where the current frame is &#34;in between&#34;.
                                                        # Weight for the right bin is frac(trajectoryIndex).
                                                        rightWeight = float(trajectoryIndex) - float(math.floor(trajectoryIndex))

                                                        # Weight for the left bin is 1-rightWeight.
                                                        leftWeight = 1.0 - rightWeight

                                                        return leftWeight*self.value[leftIndex] \
                                                                + rightWeight*self.value[rightIndex]
                                                else:
                                                        # No interpolation.
                                                        # Return the value at the last drift value index
                                                        # that would apply to this frame position.
                                                        return self.value[leftIndex]
                                        else:
                                                # Linear interpolation beyond provided trajectory data.
                                                if progress &gt; 1.0:
                                                        # We are beyond the expected last frame.
                                                        if self.interpolation is True:
                                                                # Linear interpolation beyond last two drift values:
                                                                trajectoryValue0 = self.value[int(lastTrajectoryIndex-1)]
                                                                trajectoryValue1 = self.value[int(lastTrajectoryIndex)]
                                                                offsetValue = trajectoryValue1

                                                                # We assume a linear interpolation function beyond the two
                                                                # last drift values. Taking the last frame as the zero point
                                                                # (i.e., the starting point) of this linear interpolation,
                                                                # the frame&#39;s position on the x axis would be:
                                                                xTraj = trajectoryIndex - float(lastTrajectoryIndex)
                                                        else:
                                                                # No interpolation. Return last trajectory value:
                                                                return self.value[lastTrajectoryIndex]
                                                else:
                                                        # We are before the first frame (i.e., before frame 0).
                                                        if self.interpolation is True:
                                                                trajectoryValue0 = self.value[0]
                                                                trajectoryValue1 = self.value[1]
                                                                offsetValue = trajectoryValue0

                                                                # We assume a linear interpolation function beyond the two
                                                                # last drift values. Taking the last frame as the zero point
                                                                # (i.e., the starting point) of this linear interpolation,
                                                                # the frame&#39;s position on the x axis would be:
                                                                xTraj = trajectoryIndex # is negative in this case
                                                        else:
                                                                # No interpolation. Return first trajectory value:
                                                                return self.value[0]

                                                # m = the slope of our linear interpolation function.
                                                # We are on the axis of trajectory drift values:
                                                # Our step size in x direction is 1 (trajectoryValue1 and
                                                # trajectoryValue0 are one trajectory step apart). Not
                                                # to be confused with the frame number.
                                                m = float(trajectoryValue1 - trajectoryValue0)
                                                driftValue = m * xTraj + offsetValue

                                                return driftValue
                                else:
                                        # n_frames &lt;= 1
                                        # If &#34;scan&#34; only has 1 or 0 frames,
                                        # simply return the first trajectory value.
                                        return self.value[0]
                        else:
                                # trajectory points &lt;= 1:
                                if nTrajectoryPoints &gt; 0:
                                        # Simply check if the trajectory consists of at least
                                        # 1 point and return this value:
                                        return self.value[0]

                # Drifts are per-frame absolute deviations from the standard value,
                # so 0 is a sane default value for no drift components:
                return 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.scenario.drift.Drift.add_drift_component"><code class="name flex">
<span>def <span class="ident">add_drift_component</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a drift component to the list of drift values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code></dt>
<dd>Drift value. For number-type drifts (<code>float</code>), this is given as an
absolute deviation from the parameter's standard value.
For string-type drifts (<code>str</code>), this is the string that should replace
the parameter's standard value.</dd>
</dl></div>
</dd>
<dt id="ctsimu.scenario.drift.Drift.get_value_for_frame"><code class="name flex">
<span>def <span class="ident">get_value_for_frame</span></span>(<span>self, frame: float, n_frames: int) ‑> float | str | bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return a drift value for the given <code>frame</code> number,
assuming a total number of <code>n_frames</code> in the CT scan.
If interpolation is activated, linear interpolation will
take place between drift values, but also for frame numbers
outside of the expected range: (frame &lt; 0) and (frame &gt;= n_frames).
Note that the frame number starts at 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>float</code></dt>
<dd>Current frame number.</dd>
<dt><strong><code>n_frames</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of frames in scan.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code></dt>
<dd>The drift's value for the given <code>frame</code> number.</dd>
</dl></div>
</dd>
<dt id="ctsimu.scenario.drift.Drift.json_dict"><code class="name flex">
<span>def <span class="ident">json_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Create a CTSimU JSON dictionary for this drift.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>json_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="ctsimu.scenario.drift.Drift.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the list of drift values, set <code>known_to_reconstruction</code> to <code>True</code>.</p></div>
</dd>
<dt id="ctsimu.scenario.drift.Drift.set_from_json"><code class="name flex">
<span>def <span class="ident">set_from_json</span></span>(<span>self, json_drift_object: dict) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Set the drift from a given CTSimU drift structure.
The proper <code>native_unit</code> must be set up correctly before
running this function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>json_drift_object</code></strong> :&ensp;<code>dict</code></dt>
<dd>A CTSimU drift structure, imported from a JSON structure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>success</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> on success, <code>False</code> if an error occurred.</dd>
</dl></div>
</dd>
<dt id="ctsimu.scenario.drift.Drift.set_interpolation"><code class="name flex">
<span>def <span class="ident">set_interpolation</span></span>(<span>self, intpol: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the <code>interpolation</code> property. Only necessary for
number-type parameters. String parameters cannot run an interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>intpol</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the drift value should be interpolated if the number of
drift components does not match the number of frames in the CT scan.
<code>False</code> if no interpolation should take place: the last drift value
that would match the given frame number is taken.</dd>
</dl></div>
</dd>
<dt id="ctsimu.scenario.drift.Drift.set_known_to_reconstruction"><code class="name flex">
<span>def <span class="ident">set_known_to_reconstruction</span></span>(<span>self, known: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the <code>known_to_reconstruction</code> property.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>known</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should the reconstruction software take this drift into account?</dd>
</dl></div>
</dd>
<dt id="ctsimu.scenario.drift.Drift.set_native_unit"><code class="name flex">
<span>def <span class="ident">set_native_unit</span></span>(<span>self, native_unit: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the drifts's native unit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>New native unit for the drift.
Possible values: <code>None</code>, <code>"mm"</code>, <code>"rad"</code>, <code>"deg"</code>, <code>"s"</code>, <code>"mA"</code>, <code>"kV"</code>, <code>"g/cm^3"</code>, <code>"lp/mm"</code>, <code>"deg/s"</code>, <code>"C"</code>, <code>"bool"</code>, <code>"string"</code>.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu.scenario" href="index.html">ctsimu.scenario</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.scenario.drift.Drift" href="#ctsimu.scenario.drift.Drift">Drift</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.scenario.drift.Drift.add_drift_component" href="#ctsimu.scenario.drift.Drift.add_drift_component">add_drift_component</a></code></li>
<li><code><a title="ctsimu.scenario.drift.Drift.get_value_for_frame" href="#ctsimu.scenario.drift.Drift.get_value_for_frame">get_value_for_frame</a></code></li>
<li><code><a title="ctsimu.scenario.drift.Drift.json_dict" href="#ctsimu.scenario.drift.Drift.json_dict">json_dict</a></code></li>
<li><code><a title="ctsimu.scenario.drift.Drift.reset" href="#ctsimu.scenario.drift.Drift.reset">reset</a></code></li>
<li><code><a title="ctsimu.scenario.drift.Drift.set_from_json" href="#ctsimu.scenario.drift.Drift.set_from_json">set_from_json</a></code></li>
<li><code><a title="ctsimu.scenario.drift.Drift.set_interpolation" href="#ctsimu.scenario.drift.Drift.set_interpolation">set_interpolation</a></code></li>
<li><code><a title="ctsimu.scenario.drift.Drift.set_known_to_reconstruction" href="#ctsimu.scenario.drift.Drift.set_known_to_reconstruction">set_known_to_reconstruction</a></code></li>
<li><code><a title="ctsimu.scenario.drift.Drift.set_native_unit" href="#ctsimu.scenario.drift.Drift.set_native_unit">set_native_unit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
