<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctsimu.geometry API documentation</title>
<meta name="description" content="Coordinate systems, transformations and projection matrix functionality …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.geometry</code></h1>
</header>
<section id="section-intro">
<p>Coordinate systems, transformations and projection matrix functionality.</p>
<p>This geometry module relies on basic objects like vectors and matrices from the <code><a title="ctsimu.primitives" href="primitives.html">ctsimu.primitives</a></code> module.</p>
<h1 id="coordinate-systems">Coordinate Systems</h1>
<p>The geometry subpackage provides a <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code> class that lets you create and manipulate objects in a virtual CT scene. Such an oject has a position (<code>center</code>) and three basis vectors (<code>u</code>, <code>v</code>, <code>w</code>). These basis vectors are assumed to be orthogonal, but they do not have to be unit vectors. The <code>center</code> acts as the pivot point for rotations.</p>
<p>Example for creating and manipulating an object:</p>
<pre><code class="language-python">from ctsimu.geometry import *
from ctsimu.helpers  import *  # provides deg2rad()

mySpecimen = CoordinateSystem()

# Set position and orientation:
mySpecimen.center = Vector(250, 0, 0)
mySpecimen.u = Vector(0, -1,  0)
mySpecimen.v = Vector(0,  0, -1)
mySpecimen.w = Vector(1,  0,  0)

# Manipulate:
mySpecimen.translate(translationVector=Vector(5.2, 0, 4.3))
mySpecimen.rotateAroundU(angle=deg2rad(2.0))
mySpecimen.rotate(axis=Vector(1, 1, 1), angle=deg2rad(5.0))

print(&quot;My specimen's new location and orientation:&quot;)
print(mySpecimen)

&quot;&quot;&quot;
My specimen's new location and orientation:
Center: ( 255.2000000,  0.0000000,  4.3000000)
u:      ( 0.0490510, -0.9974631, -0.0515878)
v:      (-0.0167454,  0.0508215, -0.9985674)
w:      ( 0.9986559,  0.0498445, -0.0142101)
&quot;&quot;&quot;
</code></pre>
<h1 id="full-ct-geometry">Full CT Geometry</h1>
<p>For a full CT, we need an X-ray source, a stage for the specimens, and a detector. The <code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code> class bundles three coordinate systems (one for each of those components), and additional information about the detector (using the <code><a title="ctsimu.geometry.Detector" href="#ctsimu.geometry.Detector">Detector</a></code> class, an extension of a regular <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>). The following figure shows their standard orientations when a CT geometry is initialized.</p>
<p><img alt="Standard coordinate system" src="pictures/geometry.png" title="Standard coordinate system"></p>
<p>The orientation of the coordinate system and all components can be changed by rotations or by manually setting the object basis vectors. However, it is important to keep the following conventions.</p>
<h2 id="detector-convention">Detector convention</h2>
<ul>
<li>The detector's <code>u</code> vector is its row vector.</li>
<li>The detector's <code>v</code> vector is its column vector.</li>
<li>The detector's <code>w</code> vector has no special meaning. It is a planar normal that must be chosen such that the detector's coordinate system remains right-handed.</li>
</ul>
<h2 id="stage-convention">Stage convention</h2>
<ul>
<li>The stage's <code>w</code> vector is its axis of CT rotation.</li>
<li>The stage's <code>center</code> typically refers to the center of the reconstructed volume (possibly the center of the specimen) and is <em>not</em> meant to describe the location of the turntable (which would normally be at a lower position).</li>
</ul>
<h2 id="source-convention">Source convention</h2>
<p>There is currently no restriction on the source coordinate system. We usually assume its <code>w</code> axis to be the direction of the principal ray, but this is not a necessity.</p>
<p>In the following examples, the source will be located at the origin <code>(0, 0, 0)</code> of the world coordinate system, whereas stage and detector are placed in positive <em>x</em> direction (see figure above).</p>
<h2 id="example-setup">Example Setup</h2>
<p>In the following example, we set up a standard CT geometry.</p>
<pre><code class="language-python">from ctsimu.geometry import *

# General CT parameters:
SOD = 250.0 # mm
SDD = 800.0 # mm

pixelSize = 0.2 # mm
pixelColumns = 2000
pixelRows = 1000

# Create a CT geometry object:
myCT = Geometry()

# Stage:
myCT.stage.center.x = SOD

# Detector:
myCT.detector.center.x = SDD
myCT.detector.setSize(
    pixelsU = pixelColumns,
    pixelsV = pixelRows,
    pitchU = pixelSize,
    pitchV = pixelSize
    )

myCT.update() # calculates derived geometry parameters

print(myCT.info())
</code></pre>
<h1 id="reference-frames">Reference Frames</h1>
<p>Implicitly, each coordinate system has a reference coordinate system (its <em>reference frame</em>) in which its <code>center</code> and <code>u</code>, <code>v</code>, <code>w</code> basis vectors are located and described. Typically, we assume that this is a right-handed standard coordinate system. It does not necessarily have to be the world coordinate system. For example, you might want to attach a specimen to the sample stage by implicitly making the stage coordinate system its reference coordinate system. You, the programmer, have to know the reference coordinate system of your objects, as this information is not explicitly stored by the toolbox.</p>
<p>Any new <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code> object is initialized to be a right-handed standard coordinate system with its center at <code>(0, 0, 0)</code>:</p>
<pre><code class="language-python">from ctsimu.geometry import *

myWorld = CoordinateSystem()

print(&quot;My World:&quot;)
print(myWorld)

&quot;&quot;&quot;
My World:
Center: ( 0.0000000,  0.0000000,  0.0000000)
u:      ( 1.0000000,  0.0000000,  0.0000000)
v:      ( 0.0000000,  1.0000000,  0.0000000)
w:      ( 0.0000000,  0.0000000,  1.0000000)
&quot;&quot;&quot;
</code></pre>
<p>You can change the reference frame of a <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>. In the following example, we set up a CT geometry with a stage that is tilted by 2°. We place a specimen object in the stage coordinate system and move it "upwards" by 5 mm along the (now tilted) axis of rotation. Afterwards, we change the specimen's reference frame to see where it is actually located in the world coordinate system. Refer to the image of the standard orientations above to see what is going on with the coordinate systems.</p>
<pre><code class="language-python">from ctsimu.geometry import *
from ctsimu.helpers  import *  # provides deg2rad()

world = CoordinateSystem()

# Set up a quick CT geometry with a tilted stage axis:
myCT = Geometry()
myCT.stage.center.x = 250  # SOD
myCT.stage.rotateAroundU(angle = deg2rad(2.0))
myCT.detector.center.x = 800  # SDD

# Assume a specimen in the (tilted) stage
# coordinate system, shifted 5 mm &quot;upwards&quot;
# along the axis of rotation:
mySpecimen = CoordinateSystem()
mySpecimen.translateZ(5.0)

# Change the specimen's reference frame to
# the world coordinate system:
mySpecimen.changeReferenceFrame(
    fromCS = myCT.stage,
    toCS = world)

print(&quot;The specimen's world coordinates:&quot;)
print(mySpecimen)

&quot;&quot;&quot;
The specimen's world coordinates:
Center: ( 250.0000000, -0.1744975,  4.9969541)
u:      ( 1.0000000,  0.0000000,  0.0000000)
v:      ( 0.0000000,  0.9993908,  0.0348995)
w:      ( 0.0000000, -0.0348995,  0.9993908)
&quot;&quot;&quot;
</code></pre>
<p><strong>Note:</strong> When changing reference frames, the original (<code>fromCS</code>) and the target reference frame (<code>toCS</code>) must both have the same common reference frame for themselves. In the example above, we change the reference frame from the stage coordinate system to the world coordinate system. Both of them have the same reference frame: the world coordinate system (which is special, because it is also a reference for itself).</p>
<h1 id="projection-matrices">Projection Matrices</h1>
<p>A projection matrix maps a 3D point coordinate <code>(x, y, z)</code> from the stage coordinate system to a 2D point coordinate <code>(u, v)</code> in the detector coordinate system. They are used by some reconstruction softwares to describe arbitrary scan trajectories. For such a reconstruction, we need one projection matrix for each projection image.</p>
<p><img alt="Euclidean Mapping" src="pictures/pmatrix_mapping_euclidean.png" title="Mapping a coordinate from the stage coordinate system to a coordinate in the detector coordinate system"></p>
<h2 id="mathematical-background">Mathematical Background</h2>
<p>We operate in <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">homogeneous coordinates</a> because we are in a projective geometry and this concept allows us to describe translations in space by a matrix. Homogeneous coordinates describe rays in a space and are therefore only defined up to a scale factor, which is carried as an additional coordinate. This way, a Euclidean 3-vector turns into a homogeneous 4-vector. Our mapping becomes:</p>
<p><img alt="Homogeneous Mapping" src="pictures/pmatrix_mapping_homogeneous.png" title="Mapping in homogeneous coordinates"></p>
<p>The following picture illustrates a 1D projective geometry. The <em>h</em> axis is our scale factor for the homogeneous coordinates. In this geometry, all points on a ray are equivalent. The points at <em>h</em>=1 are the normalized homogeneous coordinates.</p>
<p><img alt="Projective geometry for a 1D Euclidean space" src="pictures/hom_coords.png" title="Projective geometry for a 1D Euclidean space"></p>
<p>We can use this concept to describe translations in space with a matrix multiplication:</p>
<p><img alt="Translation Matrix" src="pictures/pmatrix_translation.png" title="Translation Matrix"></p>
<p>We now consider two coordinate systems: the stage coordinate system (our origin) and the detector coordinate system (our target). The world coordinate system is not important in this context. In the following picture, 3D (Euclidean) coordinates are expressed in terms of the stage coordinate system, and 2D (Euclidean) coordinates are expressed in terms of the detector coordinate system (ignoring its <em>w</em> axis).</p>
<p><img alt="Projective system" src="pictures/geometry_stage_projection.png" title="Projective system"></p>
<p>To calculate a projection matrix for the current geometry, we have to consider five subsequent transformations. Each transformation is expressed by a matrix. The final projection matrix is then the product of these five transformation matrices.</p>
<ol>
<li>
<p>We shift the origin of the coordinate system from the stage to the source, which is our center of projection.</p>
<p><img alt="Shifting the origin to the source" src="pictures/pmatrix_F.png" title="Shifting the origin to the source"></p>
</li>
<li>
<p>We perform a basis transformation to express the 3D coordinates in terms of the axes of the detector coordinate system. The origin remains at the source. You can also think of this transformation as a rotation into the detector coordinate system.</p>
<p><img alt="Rotation into detector coordinate system" src="pictures/pmatrix_R.png" title="Rotation into detector coordinate system"></p>
<p>All basis vectors in this matrix are assumed to be unit vectors.</p>
<p>This matrix takes care of any stage or detector tilts.</p>
<p>After this transformation, the third (<em>"z"</em>) coordinate in a vector now refers to its position on the detector normal (its <em>w</em> axis). Therefore, this third coordinate now contains something similar to what we would normally call the SOD (source-object distance) of that point. The fourth coordinate of our homogeneous vector has not been scaled so far (α=1), which means we have not left the projective plane which we call home (our real world). This is important to keep in mind for the next step.</p>
</li>
<li>
<p>We use a matrix that reduces the dimension of our vector by one (from a homogeneous 4-vector to a homogeneous 3-vector). This step is sometimes called the actual <em>projection</em>.</p>
<p><img alt="Projection reduces dimension" src="pictures/pmatrix_D.png" title="Projection reduces dimension"></p>
<p>In the previous step, the third component of the 4-vector used to be something similar to the SOD. This has now become the <em>scale component</em> β of our homogeneous 3-vector (because a multiplication with this matrix throws away the fourth vector component, which has still been α=1). This means we are now in a projective plane β=SOD, away from the detector plane of our home world (which would be at β=1).</p>
<p>This problem is solved in the end by a simple renormalization of the matrix. Stay tuned!</p>
</li>
<li>
<p>We take care of the magnification and any additional scaling.</p>
<p><img alt="Scaling" src="pictures/pmatrix_S.png" title="Scaling"></p>
<p>The SDD (source-detector distance) in this case means the length of the principal ray from source to detector (i.e., the ray that is parallel to the detector normal <em>w</em> and orthogonally hits the detector plane).</p>
<p>This matrix simply scales any image at the projective plane β=1 such that its <em>u</em> and <em>v</em> component will obey the magnification by the SDD (source-detector distance). Sometimes, the stage coordinate system is expressed in a different unit than the detector coordinate system (e.g. mm vs. px). In this case, we can introduce scale factors s<sub>u</sub> and s<sub>v</sub> that take care of further scaling, e.g. to handle the pixel size.</p>
<p>Note that the final renormalization will turn out to be a division by the SOD (as mentioned in the previous step). This will convert the SDD-factors of this matrix into the actual magnification: M=SDD/SOD. We do not incorporate this here because the SOD as a parameter is not well-defined and might lead to confusion in a non-standard geometry.</p>
</li>
<li>
<p>The origin of the detector coordinate system might not be where the principal ray hits the detector (i.e., the center of projection projected onto the detector). We need to take care of this additional shift:</p>
<p><img alt="Translation on detector" src="pictures/pmatrix_T.png" title="Translation on detector"></p>
</li>
</ol>
<p>The final projection matrix is a 3×4 matrix that results from a multiplication of these five matrices and a renormalization by the lower-right component (p<sub>23</sub>) to get back to the projective plane of our home world (see step 3).</p>
<p><img alt="Final projection matrix" src="pictures/pmatrix_P.png" title="Final projection matrix"></p>
<h2 id="generating-projection-matrices">Generating Projection Matrices</h2>
<p>You can call the function <code>projectionMatrix()</code> of any <code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code> object to get a projection matrix for its current configuration.</p>
<pre><code class="language-python">from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.x    = 250  # SOD
myCT.detector.center.x = 800  # SDD

# Calculate the projection matrix:
P = myCT.projectionMatrix()

print(&quot;Projection Matrix:&quot;)
print(P)

&quot;&quot;&quot;
Projection Matrix:
[ 0.0000000  -3.2000000   0.0000000   0.0000000  ]
[ 0.0000000   0.0000000   3.2000000   0.0000000  ]
[ 0.0040000   0.0000000   0.0000000   1.0000000  ]
&quot;&quot;&quot;
</code></pre>
<h3 id="openct-cera">openCT &amp; CERA</h3>
<p>The toolbox provides two pre-configured modes to calculate projection matrices for openCT (which can be used in VGSTUDIO MAX) and for SIEMENS CERA. Each software needs slightly different projection matrices, because they define their detector coordinate system in different ways. See the next section about the image and volume coordinate system for details.</p>
<p>In the following example, we calculate a projection matrix for each software by defining the <code>mode</code> when calling the <code>projectionMatrix()</code> function.</p>
<pre><code class="language-python">from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.x    = 250  # SOD
myCT.detector.center.x = 800  # SDD

# Set the detector size:
myCT.detector.setSize(
    pixelsU = 2000,
    pixelsV = 1000,
    pitchU  = 0.2,
    pitchV  = 0.2)

# Calculate the projection matrix:
P_openCT = myCT.projectionMatrix(mode=&quot;openCT&quot;)
P_CERA   = myCT.projectionMatrix(mode=&quot;CERA&quot;)

print(&quot;openCT:&quot;)
print(P_openCT)

print(&quot;CERA:&quot;)
print(P_CERA)
</code></pre>
<p>openCT's definition of the detector coordinate system matches our definition. In this case, we get the same projection matrix as without the <code>mode</code> parameter.</p>
<h3 id="image-volume-coordinate-systems">Image &amp; Volume Coordinate Systems</h3>
<p>Depending on the reconstruction software, the <strong>image coordinate system</strong> of the projection image does not have to match our standard detector coordinate system. Also, the <strong>volume coordinate system</strong> of the reconstructed volume does not have to match the stage coordinate system.</p>
<p>In the following three examples, we will show how to use the parameter <code>imageCS</code> and <code>volumeCS</code> to define our own image and volume coordinate systems.</p>
<p><img alt="Image and volume coordinate system" src="pictures/image_stage_cs.png" title="Image and volume coordinate system"></p>
<p><strong>Note:</strong> The image coordinate system is expressed in terms of the detector coordinate system (its reference coordinate system). Similarly, the volume coordinate system is expressed in terms of the stage coordinate system. To set the scale factor for the image or volume coordinate system, we set the lengths of their basis vectors to the correct conversion factor (e.g., the pixel size in mm/px or the voxel size in mm/voxel).</p>
<h4 id="example-1-cera">Example 1: CERA</h4>
<p>Even though we have a pre-defined more for CERA, we will use its image coordinate system (illustrated above) to show how to set up an image coordinate system for CERA manually.</p>
<p>CERA's volume coordinate system matches our stage coordinate system, so we won't have to create our own volume coordinate system.</p>
<p>CERA's image coordinate system has its origin in the center of the lower left pixel of the detector. This means we have to move its origin by half the detector's physical width to the left and half the detector's physical height downwards from the origin of the detector coordinate system, and then back by half a physical pixel size (the detector pitch). We can use the attributes <code>physWidth</code> and <code>physHeight</code>, which are automatically calculated when calling <code>setSize()</code>.</p>
<pre><code class="language-python">from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.x    = 250  # SOD
myCT.detector.center.x = 800  # SDD

# Set the detector size:
myCT.detector.setSize(
    pixelsU = 2000,
    pixelsV = 1000,
    pitchU  = 0.2,
    pitchV  = 0.2)

# Set up a new image coordinate system,
# relative to the detector coordinate system:
image = CoordinateSystem()

# CERA places the origin of the image CS in the center
# of the lower left pixel of the projection image.
image.center.x = -(myCT.detector.physWidth  / 2.0) + 0.5*myCT.detector.pitchU
image.center.y =  (myCT.detector.physHeight / 2.0) - 0.5*myCT.detector.pitchV

# CERA's unit of the image CS is in px, so we need to
# scale the image CS basis vectors by the pixel size.
# Also, v points up instead of down. This also flips
# the w axis to keep a right-handed coordinate system.
image.u.scale( myCT.detector.pitchU)
image.v.scale(-myCT.detector.pitchV)
image.w.scale(-1.0)

# Calculate the projection matrix:
P = myCT.projectionMatrix(imageCS=image)

print(&quot;CERA projection matrix:&quot;)
print(P)
</code></pre>
<h4 id="example-2-openct">Example 2: openCT</h4>
<p>In the case of openCT, the image coordinate system matches our detector coordinate system. Also, the volume coordinate system matches our definition of the stage coordinate system. In this case, we can simply call the <code>projectionMatrix()</code> function without any parameters.</p>
<p>However, for the sake of clarity, we create a standard coordinate system for both the image and volume coordinate system. Because they are expressed in terms of their respective reference coordinate systems (detector and stage), they exactly represent their respective reference CS as seen from the outside world.</p>
<pre><code class="language-python">from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.x    = 250  # SOD
myCT.detector.center.x = 800  # SDD

# Set the detector size:
myCT.detector.setSize(
    pixelsU = 2000,
    pixelsV = 1000,
    pitchU  = 0.2,
    pitchV  = 0.2)

# Set up a new image coordinate system
# as a standard coordinate system,
# relative to the detector coordinate system:
image = CoordinateSystem()

# Set up a new volume coordinate system
# as a standard coordinate system,
# relative to the stage coordinate system:
volume = CoordinateSystem()

# Calculate the projection matrix:
P = myCT.projectionMatrix(
    imageCS = image,
    volumeCS = volume)

print(&quot;openCT projection matrix:&quot;)
print(P)
</code></pre>
<h4 id="example-3">Example 3</h4>
<p>For the third example (see illustration), we will have to move the origin of the image coordinate system to the upper left corner of the detector and scale its basis vectors by the pixel size because its units are pixels.</p>
<p>The volume coordinate system has its origin at the front lower right corner of the reconstruction volume. Because it is no longer at the stage's center, we will actually have to define the volume's physical size in order to correctly calculate the corner coordinate in terms of the stage coordinate system.</p>
<p>We also scale the basis vectors of the volume coordinate system by the voxel size, because we assume that our reconstruction software expresses its volume coordinates in voxel units instead of world units (mm).</p>
<pre><code class="language-python">from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.x    = 250  # SOD in mm
myCT.detector.center.x = 800  # SDD in mm

# Set the detector size:
myCT.detector.setSize(
    pixelsU = 2000,
    pixelsV = 1000,
    pitchU  = 0.2,
    pitchV  = 0.2)

# Define the size of the reconstruction volume:
volume_size_x = 2000 # voxels
volume_size_y = 2000 # voxels
volume_size_z = 1000 # voxels
voxel_size = 0.0625  # mm/voxel

# Set up a new image coordinate system,
# relative to the detector coordinate system:
image = CoordinateSystem()

# Move the image origin to the upper left corner
# of the detector coordinate system:
image.center.x = -myCT.detector.physWidth  / 2.0
image.center.y = -myCT.detector.physHeight / 2.0

# Our unit of the image CS is in px, so we need to
# scale the image CS basis vectors by the pixel size.
image.u.scale(myCT.detector.pitchU)
image.v.scale(myCT.detector.pitchV)

# Set up a new volume coordinate system,
# relative to the stage coordinate system:
volume = CoordinateSystem()

# Move the volume origin to the front lower right
# corner of the reconstruction volume:
volume.center.x = -volume_size_x * voxel_size / 2.0
volume.center.y = -volume_size_y * voxel_size / 2.0
volume.center.z = -volume_size_z * voxel_size / 2.0

# Our unit of the volume CS is in voxels, so we need to
# scale the volume CS basis vectors by the voxel size.
volume.u.scale(voxel_size)
volume.v.scale(voxel_size)
volume.w.scale(voxel_size)

# Calculate the projection matrix:
P = myCT.projectionMatrix(imageCS=image, volumeCS=volume)

print(&quot;My projection matrix:&quot;)
print(P)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-
&#34;&#34;&#34;
Coordinate systems, transformations and projection matrix functionality.

This geometry module relies on basic objects like vectors and matrices from the `ctsimu.primitives` module.

.. include:: ./geometry.md
&#34;&#34;&#34;

import numpy
import os    # File and path handling
import json
import math
import copy
import pkgutil
from datetime import datetime

from .primitives import *
from .image import Image  # To create detector flat field

def basisTransformMatrix(fromCS:&#39;CoordinateSystem&#39;, toCS:&#39;CoordinateSystem&#39;) -&gt; Matrix:
    &#34;&#34;&#34;Calculate a matrix that transforms coordinates from `fromCS` to `toCS`.

    `fromCS` and `toCS` must have the same common reference frame
    (e.g. the world coordinate system).

    Parameters
    ----------
    fromCS : CoordinateSystem
        The origin coordinate system.

    toCS : CoordinateSystem
        The target coordinate system.

    Returns
    -------
    T : Matrix
        The 3x3 basis transformation matrix.

    References
    ----------
    * S. Widnall: [Lecture L3 - Vectors, Matrices and Coordinate Transformations]
    [Lecture L3 - Vectors, Matrices and Coordinate Transformations]: https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec03.pdf
    &#34;&#34;&#34;

    T = Matrix(3, 3)

    # Row 1:
    T.value[0][0] = toCS.u.unitVector().dot(fromCS.u.unitVector())
    T.value[0][1] = toCS.u.unitVector().dot(fromCS.v.unitVector())
    T.value[0][2] = toCS.u.unitVector().dot(fromCS.w.unitVector())

    # Row 2:
    T.value[1][0] = toCS.v.unitVector().dot(fromCS.u.unitVector())
    T.value[1][1] = toCS.v.unitVector().dot(fromCS.v.unitVector())
    T.value[1][2] = toCS.v.unitVector().dot(fromCS.w.unitVector())

    # Row 3:
    T.value[2][0] = toCS.w.unitVector().dot(fromCS.u.unitVector())
    T.value[2][1] = toCS.w.unitVector().dot(fromCS.v.unitVector())
    T.value[2][2] = toCS.w.unitVector().dot(fromCS.w.unitVector())

    return T

class CoordinateSystem:
    &#34;&#34;&#34;Coordinate system: center point and axis vectors.

    An object according to the CTSimU scenario specification,
    containing a center coordinate and an orientation in 3D space.
    
    The center and axis vectors are expressed in terms of the
    object&#39;s reference coordinate system, which must be known implicitly
    when objects of this class are used.

    Geometrical objects could be source, stage or detector.
    Samples would need additional attention due to possible attachment
    to stage coordinate system (instead of world).

    Attributes
    ----------
    center : Vector
        The location of the center point in a reference
        coordinate system (usually world or stage).

    u : Vector
        Basis vector for the u axis.

    v : Vector
        Basis vector for the v axis.

    w : Vector
        Basis vector for the w axis.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard world coordinate system.&#34;&#34;&#34;
        self.center  = Vector(0, 0, 0)
        self.u = Vector(1, 0, 0)
        self.v = Vector(0, 1, 0)
        self.w = Vector(0, 0, 1)

    def __str__(self):
        &#34;&#34;&#34;Information string for easy printing.&#34;&#34;&#34;

        txt  = &#34;Center: {}\n&#34;.format(self.center)
        txt += &#34;u:      {}\n&#34;.format(self.u)
        txt += &#34;v:      {}\n&#34;.format(self.v)
        txt += &#34;w:      {}\n&#34;.format(self.w)
        return txt

    def json_import(self, geometry: dict):
        &#34;&#34;&#34;Set up geometry from a JSON dictionary.

        Parameters
        ----------
        geometry : dict
            A parsed JSON dictionary from a [CTSimU scenario description] file.

        [CTSimU scenario description]: https://bamresearch.github.io/ctsimu-scenarios/

        Raises
        ------
        KeyError
            When expected JSON keys for center and vector x, y, z
            components are not found in the dictionary.
        &#34;&#34;&#34;

        # Get center position from JSON dict:
        if &#34;center&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;center&#34;]:
                cx = in_mm(geometry[&#34;center&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;center&#34;]:
                cy = in_mm(geometry[&#34;center&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;center&#34;]:
                cz = in_mm(geometry[&#34;center&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        # Try old British spelling (up to file format v0.9)
        elif &#34;centre&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;centre&#34;]:
                cx = in_mm(geometry[&#34;centre&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;centre&#34;]:
                cy = in_mm(geometry[&#34;centre&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;centre&#34;]:
                cz = in_mm(geometry[&#34;centre&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;center\&#34; section.&#34;)

        # Get vector u from JSON dict:
        if &#34;vector_u&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_u&#34;]:
                ux = geometry[&#34;vector_u&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector u.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_u&#34;]:
                uy = geometry[&#34;vector_u&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector u.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_u&#34;]:
                uz = geometry[&#34;vector_u&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector u.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_u\&#34; section.&#34;)

        # Get vector w from JSON dict:
        if &#34;vector_w&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_w&#34;]:
                wx = geometry[&#34;vector_w&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector w.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_w&#34;]:
                wy = geometry[&#34;vector_w&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector w.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_w&#34;]:
                wz = geometry[&#34;vector_w&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector w.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_w\&#34; section.&#34;)

        # Set up the geometry from the information given in the JSON file:
        c = Vector(cx, cy, cz)  # center
        u = Vector(ux, uy, uz)  # u basis vector
        w = Vector(wx, wy, wz)  # w basis vector
        v = w.cross(u)
        self.setup(c, u, v, w)
        self.makeUnitCS()

        # Apply deviations from the now-ideal geometry:
        if &#34;deviation&#34; in geometry:
            # Positional deviations:
            if &#34;position&#34; in geometry[&#34;deviation&#34;]:
                if &#34;x&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;] != None:
                        translationX = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;])
                        self.translateX(translationX)
    
                if &#34;y&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;] != None:
                        translationY = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;])
                        self.translateY(translationY)

                if &#34;z&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;] != None:
                        translationZ = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;])
                        self.translateZ(translationZ)

            # Rotations according to w&#39;&#39;v&#39;u convention:
            if &#34;rotation&#34; in geometry[&#34;deviation&#34;]:
                if &#34;w&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;] != None:
                        angleAroundW = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;])
                        self.rotateAroundW(angleAroundW)

                if &#34;v&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;] != None:
                        angleAroundV = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;])
                        self.rotateAroundV(angleAroundV)

                if &#34;u&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;] != None:
                        angleAroundU = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;])
                        self.rotateAroundU(angleAroundU)

    def setup(self, center:Vector, u:Vector, v:Vector, w:Vector):
        &#34;&#34;&#34;Set up center and orientation manually.

        Parameters
        ----------
        center : Vector
            Object&#39;s center point in reference coordinate system,
            origin of local {u,v,w} coordinate system.

        u : Vector
            Basis vector u in terms of reference coordinate system.

        v : Vector
            Basis vector v in terms of reference coordinate system.

        w : Vector
            Basis vector w in terms of reference coordinate system.

        Notes
        -----
        All basis vectors must be orthogonal.
        &#34;&#34;&#34;

        # Create new vectors from given components:
        self.center  = center
        self.u = u
        self.v = v
        self.w = w

    def update(self):
        &#34;&#34;&#34;Signal a manual update to the center position or orientation vectors.&#34;&#34;&#34;
        self.center.update()
        self.u.update()
        self.v.update()
        self.w.update()

    def makeUnitCS(self):
        &#34;&#34;&#34;Convert all basis vectors to unit vectors.&#34;&#34;&#34;
        self.u.makeUnitVector()
        self.v.makeUnitVector()
        self.w.makeUnitVector()

    def translate(self, translationVector: Vector):
        &#34;&#34;&#34;Move object in space.

        Parameters
        ----------
        translationVector : Vector
            Vector by which the object&#39;s center point should be shifted.
            Its components are added to the center&#39;s components.
        &#34;&#34;&#34;
        self.center.add(translationVector)

    def translateX(self, dx: float):
        &#34;&#34;&#34;Move object in x direction.

        Parameters
        ----------
        dx : float
            Shift amount in x direction.
        &#34;&#34;&#34;
        self.center.setx(self.center.x + float(dx))

    def translateY(self, dy: float):
        &#34;&#34;&#34;Move object in y direction.

        Parameters
        ----------
        dy : float
            Shift amount in y direction.
        &#34;&#34;&#34;
        self.center.sety(self.center.y + float(dy))

    def translateZ(self, dz: float):
        &#34;&#34;&#34;Move object in z direction.

        Parameters
        ----------
        dz : float
            Shift amount in z direction.
        &#34;&#34;&#34;
        self.center.setz(self.center.z + float(dz))

    def rotateAroundU(self, angle: float):
        &#34;&#34;&#34;Rotate object around its u axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.v.rotate(self.u, angle)
        self.w.rotate(self.u, angle)

    def rotateAroundV(self, angle: float):
        &#34;&#34;&#34;Rotate object around its v axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(self.v, angle)
        self.w.rotate(self.v, angle)

    def rotateAroundW(self, angle: float):
        &#34;&#34;&#34;Rotate object around its w axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(self.w, angle)
        self.v.rotate(self.w, angle)

    def rotate(self, axis: Vector, angle: float):
        &#34;&#34;&#34;Rotate object around a given axis by the given angle [rad].
        
        Parameters
        ----------
        axis : Vector
            The axis of rotation, in terms of the object&#39;s
            reference coordinate system (e.g. world).
        
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(axis, angle)
        self.v.rotate(axis, angle)
        self.w.rotate(axis, angle)

    def changeReferenceFrame(self, fromCS:&#39;CoordinateSystem&#39;, toCS:&#39;CoordinateSystem&#39;):
        &#34;&#34;&#34;Change the object&#39;s reference coordinate system.
        
        Parameters
        ----------
        fromCS : CoordinateSystem
            Current reference coordinate system.
        
        toCS : CoordinateSystem
            New reference coordinate system.

        Notes
        -----
        Both fromCS and toCS must be in the same reference coordinate system
        (e.g., the world coordinate system).
        &#34;&#34;&#34;

        # Rotate basis vectors into toCS:
        T = basisTransformMatrix(fromCS, toCS)
        self.u = T * self.u
        self.v = T * self.v
        self.w = T * self.w

        world = CoordinateSystem()

        # Move center to toCS:
        # 1. Translate self.center by difference of toCS and fromCS
        #    -&gt; Origins are &#34;superimposed&#34;.
        # 2. Rotate self.center from fromCS to toCS.

        # Translation vector in world coordinates:
        translator = fromCS.center - toCS.center  # in world coordinates
        # Translation vector in fromCS coordinates:
        M = basisTransformMatrix(world, fromCS)
        translator = M*translator
        relCenter = self.center + translator
        self.center = T*relCenter

class Detector(CoordinateSystem):
    &#34;&#34;&#34;Detector as geometrical object.

    With additional attributes for the spatial extension and
    the pixel coordinate system.

    Attributes
    ----------
    pixelsU : int
        Number of pixels in u direction.
    
    pixelsV : int
        Number of pixels in v direction.
    
    pitchU : float
        Size of a pixel in u direction.
        In units of the reference coordinate system.
    
    pitchV : float
        Size of a pixel in v direction.
        In units of the reference coordinate system.
    
    physWidth : float
        Physical size in u direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
    
    physHeight : float
        Physical size in v direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
 
    pixelOrigin : Vector
        Origin of the pixel coordinate system in terms of the reference
        coordinate system. This is the outermost corner of the
        (0,0) pixel of the detector (often the &#34;upper left&#34; corner).
        Computed automatically after calling `setSize()`.

    Notes
    -----
    Use `setSize()` to set the size of the detector, given its number of pixels
    and the pitch. This function automatically computes the physical dimensions
    `physWidth` and `physHeight` and the origin of the pixel coordinate system.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard CoordinateSystem.

        Orientation, position and size must be set up manually afterwards.
        &#34;&#34;&#34;

        # Call init from parent class:
        CoordinateSystem.__init__(self)

        self.pixelsU     = None  # Detector pixels in u direction
        self.pixelsV     = None  # Detector pixels in v direction
        self.pitchU = None  # Size of a pixel in u direction in units of reference coordinate system
        self.pitchV = None  # Size of a pixel in v direction in units of reference coordinate system
        self.physWidth   = 0    # Physical width in units of reference coordinate system
        self.physHeight  = 0    # Physical height in units of reference coordinate system

        self.pixelOrigin = Vector()  # origin of pixel coordinate system in terms of reference coordinate system

    def sizeIsSet(self):
        if (self.pixelsU is None) or (self.pixelsV is None) or (self.pitchU is None) or (self.pitchV is None):
            return False

        return True

    def setSize(self, pixelsU:int = None, pixelsV:int = None, pitchU:float = None, pitchV:float = None):
        &#34;&#34;&#34;Set the physical size of the detector.

        From the given parameters (number of pixels and pitch), the physical
        size of the detector and the position of the origin of the pixel
        coordinate system will be calculated. Make sure that the orientation
        vectors and position of the detector are correct before calling
        `setSize()`, or call `computeGeometryParameters()` if you update
        the detector orientation or position later on.

        Parameters
        ----------
        pixelsU : int
            Number of pixels in u direction.

        pixelsV : int
            Number of pixels in v direction.

        pitchU : float
            Pixel pitch in u direction.

        pitchV : float
            Pixel pitch in v direction.
        &#34;&#34;&#34;

        self.pixelsU = int(pixelsU)
        self.pixelsV = int(pixelsV)
        self.pitchU = float(pitchU)
        self.pitchV = float(pitchV)

        self.computeGeometryParameters()

    def computeGeometryParameters(self):
        &#34;&#34;&#34;Calculate the physical width and height, and the position of the
        pixel coordinate system origin.

        These calculations assume that the size, position and
        orientation of the detector are correctly set up.

        Results are assigned to their member variables (attributes).
        &#34;&#34;&#34;

        if self.sizeIsSet():
            # Physical width and height:
            self.physWidth  = self.pixelsU * self.pitchU
            self.physHeight = self.pixelsV * self.pitchV

            # Vectors of the detector coordinate system:
            ux = self.u.unitVector().x
            uy = self.u.unitVector().y
            uz = self.u.unitVector().z
            vx = self.v.unitVector().x
            vy = self.v.unitVector().y
            vz = self.v.unitVector().z

            # World coordinates of origin (0,0) of detector&#39;s pixel coordinate system:
            self.pixelOrigin.x = self.center.x - 0.5*(ux*self.physWidth + vx*self.physHeight)
            self.pixelOrigin.y = self.center.y - 0.5*(uy*self.physWidth + vy*self.physHeight)
            self.pixelOrigin.z = self.center.z - 0.5*(uz*self.physWidth + vz*self.physHeight)

    def cols(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector columns (i.e., pixels in u direction).

        Returns
        -------
        pixelsU : int
            Number of detector columns (i.e., pixels in u direction).
        &#34;&#34;&#34;
        return self.pixelsU

    def rows(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector rows (i.e., pixels in v direction).

        Returns
        -------
        pixelsV : int
            Number of detector rows (i.e., pixels in v direction).
        &#34;&#34;&#34;
        return self.pixelsV

    def pixelVector(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector for given pixel coordinate.

        The pixel coordinate system has its origin at the detector corner with
        the lowest coordinate in terms of its u and v basis vectors. Typically,
        this is the upper left corner, but your arrangement may differ.

        Integer coordinates always refer to the pixel corner that is closest to
        the origin of the pixel coordinate system, whereas the center of a pixel
        therefore has a &#34;.5&#34; coordinate in the pixel coordinate system.
        For example, the first pixel (0, 0) would have center coordinates
        (0.5, 0.5).

        To get the center coordinates for a given integer pixel location,
        `pixelVectorCenter()` may be used.

        Parameters
        ----------
        x : float
            x position in pixel coordinate system.

        y : float
            y position in pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Pixel position in reference coordinate system (usually world)
            as a 3D vector.
        &#34;&#34;&#34;

        # x, y are coordinates in pixel coordinates system
        px = self.pixelOrigin.x + self.u.x*x*self.pitchU + self.v.x*y*self.pitchV
        py = self.pixelOrigin.y + self.u.y*x*self.pitchU + self.v.y*y*self.pitchV
        pz = self.pixelOrigin.z + self.u.z*x*self.pitchU + self.v.z*y*self.pitchV
        pixelVector = Vector(px, py, pz)
        return pixelVector

    def pixelVectorCenter(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector of pixel center, for a pixel given in integer coordinates.

        Parameters
        ----------
        x : float
            Integer x coordinate, specifies a pixel in the pixel coordinate system.

        y : float
            Integer y coordinate, specifies a pixel in the pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Position of the pixel center in the reference coordinate system
            (usually world) as a 3D vector.

        Notes
        -----
        If `float` coordinates are passed (non-integer),
        they are converted to integers using `math.floor`.
        &#34;&#34;&#34;
        return self.pixelVector(float(math.floor(x))+0.5, float(math.floor(y))+0.5)


class Geometry:
    &#34;&#34;&#34;Bundles geometry information about the complete CT setup.

    Keeps the source, stage and detector as a set and provides methods
    to calculate geometry parameters and projection matrices.
    
    Attributes
    ----------
    detector : Detector
        The detector geometry.

    source : CoordinateSystem
        The source geometry.

    stage : CoordinateSystem
        The stage geometry.

    SDD : float
        Shortest distance between source center and detector plane.
        Calculated automatically by `update()`.

    SOD : float
        Distance between source center and stage center.
        Calculated automatically by `update()`.

    ODD : float
        Shortest distance between stage center and detector plane.
        Calculated automatically by `update()`.

    brightestSpotWorld : Vector
        Location of the intensity maximum on the detector, in world coordinates.
        Assuming an isotropically radiating source.
        Calculated automatically by `update()`.

    brightestSpotDetector : Vector
        Location of the intensity maximum on the detector, in terms of
        detector coordinate system. Assuming an isotropically radiating source.
        Calculated automatically by `update()`.
    &#34;&#34;&#34;

    def __init__(self, jsonFile:str = None, jsonFileFromPkg:str = None):
        &#34;&#34;&#34;Initialize using the provided JSON geometry specification.

        Parameters
        ----------
        jsonFile : str, optional
            Location of a CTSimU scenario description file to
            import the geometry.

        jsonFileFromPkg : str, optional
            Load the geometry from a JSON file included in the package,
            usually for internal purposes only.

        &#34;&#34;&#34;
        self.detector    = Detector()
        self.source      = CoordinateSystem()
        self.stage       = CoordinateSystem()

        # Initialize source and detector to standard CTSimU orientation:
        self.detector.u = Vector(0, -1,  0)
        self.detector.v = Vector(0,  0, -1)
        self.detector.w = Vector(1,  0,  0)
        self.source.u   = Vector(0, -1,  0)
        self.source.v   = Vector(0,  0, -1)
        self.source.w   = Vector(1,  0,  0)

        self.SDD = None
        self.SOD = None
        self.ODD = None
        self.brightestSpotWorld = None
        self.brightestSpotDetector = None

        jsonText = None
        if jsonFileFromPkg is not None:  # from package
            jsonFile = jsonFileFromPkg
            jsonText = pkgutil.get_data(__name__, jsonFileFromPkg).decode()
        elif jsonFile is not None:  # from file
            if os.path.isfile(jsonFile):
                log(&#34;JSON File: {}&#34;.format(jsonFile))
                jsonFilePtr = open(jsonFile, &#34;r&#34;)
                jsonText = jsonFilePtr.read()
                jsonFilePtr.close()
            else:
                raise Exception(&#34;Can&#39;t find &#34; + jsonFile)
        else:
            return

        if(jsonText is not None):
            try:
                jsonDict = json.loads(jsonText)
            except:
                raise Exception(&#34;Error parsing JSON file: {}&#34;.format(jsonFile))

            # Detector size and pixel pitch:
            pixelsU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;columns&#34;, &#34;value&#34;)
            pixelsV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;rows&#34;, &#34;value&#34;)
            pitchU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;u&#34;, &#34;value&#34;)
            pitchV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;v&#34;, &#34;value&#34;)

            try:
                detectorGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;detector&#34;)
                if detectorGeometry != None:
                    self.detector.json_import(detectorGeometry)
                    self.detector.setSize(pixelsU, pixelsV, pitchU, pitchV)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;detector\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the detector geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                sourceGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;source&#34;)
                if sourceGeometry != None:
                    self.source.json_import(sourceGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;source\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the source geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                stageGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;stage&#34;)
                if stageGeometry != None:
                    self.stage.json_import(stageGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;stage\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the stage geometry using the JSON file description.&#34;)
                raise Exception(e)

            self.update()            
        else:
            raise Exception(&#34;JSON scenario file not available.&#34;)

    def __str__(self):
        return self.info()
        
    def update(self):
        &#34;&#34;&#34;Calculate derived geometry parameters.

        Calculates the SOD, SDD, ODD, and location of the intensity maximum
        on the detector (in world and detector coordinates) for the
        curent geometry. Results are stored in the following member variables
        (attributes).

        SDD: Shortest distance between source center and detector plane.

        SOD: Distance between source center and stage center.

        ODD: Shortest distance between stage center and detector plane.

        brightestSpotWorld: Location of the intensity maximum on the detector,
            in world coordinates.  Assuming an isotropically radiating source.

        brightestSpotDetector: Location of the intensity maximum on the
            detector, in terms of detector coordinate system.
            Assuming an isotropically radiating source.
        &#34;&#34;&#34;

        self.source.update()
        self.stage.update()
        self.detector.update()

        # SOD, SDD, ODD
        world = CoordinateSystem()
        source_from_image = copy.deepcopy(self.source)
        stage_from_detector  = copy.deepcopy(self.stage)

        source_from_image.changeReferenceFrame(world, self.detector)
        stage_from_detector.changeReferenceFrame(world, self.detector)

        self.SDD = abs(source_from_image.center.z)
        self.ODD = abs(stage_from_detector.center.z)
        self.SOD = self.source.center.distance(self.stage.center)

        ## Brightest Spot in World Coordinate System:
        self.brightestSpotWorld = copy.deepcopy(self.detector.w)
        self.brightestSpotWorld.scale(self.SDD)
        self.brightestSpotWorld.add(self.source.center)

        ## Brightest Spot in Detector Coordinate System:
        self.brightestSpotDetector = copy.deepcopy(self.brightestSpotWorld)
        self.brightestSpotDetector.subtract(self.detector.center)
        
        pxU = self.brightestSpotDetector.dot(self.detector.u) / self.detector.pitchU + self.detector.cols()/2.0
        pxV = self.brightestSpotDetector.dot(self.detector.v) / self.detector.pitchV + self.detector.rows()/2.0

        self.brightestSpotDetector = Vector(pxU, pxV, 0)

        self.detector.computeGeometryParameters()


    def info(self) -&gt; str:
        &#34;&#34;&#34;Generate an information string about the current geometry.
    
        Returns
        -------
        txt : string
            Information string for humans.
        &#34;&#34;&#34;

        self.update()

        txt  = &#34;Detector\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.detector.center)
        txt += &#34;u:               {}\n&#34;.format(self.detector.u)
        txt += &#34;v:               {}\n&#34;.format(self.detector.v)
        txt += &#34;w:               {}\n&#34;.format(self.detector.w)
        txt += &#34;Pixels:          {cols} x {rows}\n&#34;.format(cols=self.detector.cols(), rows=self.detector.rows())
        txt += &#34;Pitch:           {pitchU} x {pitchV}\n&#34;.format(pitchU=self.detector.pitchU, pitchV=self.detector.pitchV)
        txt += &#34;Physical Size:   {width} x {height}\n&#34;.format(width=self.detector.physWidth, height=self.detector.physHeight)

        txt += &#34;Brightest Spot:\n&#34;
        txt += &#34;  World:         {}\n&#34;.format(self.brightestSpotWorld)
        txt += &#34;  Pixels:        {}\n&#34;.format(self.brightestSpotDetector)

        txt += &#34;\n&#34;
        txt += &#34;Source:\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.source.center)
        txt += &#34;u:               {}\n&#34;.format(self.source.u)
        txt += &#34;v:               {}\n&#34;.format(self.source.v)
        txt += &#34;w:               {}\n&#34;.format(self.source.w)

        txt += &#34;\n&#34;
        txt += &#34;Stage:\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.stage.center)
        txt += &#34;u:               {}\n&#34;.format(self.stage.u)
        txt += &#34;v:               {}\n&#34;.format(self.stage.v)
        txt += &#34;w:               {}\n&#34;.format(self.stage.w)

        txt += &#34;\n&#34;
        txt += &#34;Geometry Parameters:\n&#34;
        txt += &#34;===========================================================\n&#34;
        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        txt += &#34;SDD:             {}\n&#34;.format(self.SDD)
        txt += &#34;ODD:             {}\n&#34;.format(self.ODD)
        txt += &#34;SOD:             {}\n&#34;.format(self.SOD)

        return txt

    def projectionMatrix(self,
                         volumeCS:CoordinateSystem=None,
                         imageCS:CoordinateSystem=None,
                         mode:str=None,
                         mirror:bool=True):
        &#34;&#34;&#34;Calculate a projection matrix for the current geometry.

        Parameters
        ----------
        volumeCS : CoordinateSystem, optional
            Position of the volume coordinate system in terms of the
            stage coordinate system. If `None` is given, the volume
            coordinate system is assumed to be the stage coordinate system.
            See notes for details.

        imageCS : CoordinateSystem, optional
            Position of the image coordinate system in terms of the
            detector coordinate system. If `None` is given, the image
            coordinate system is assumed to be the detector coordinate system.
            See notes for details.

        mode : str, optional
            Pre-defined modes. Either &#34;openCT&#34; or &#34;CERA&#34; are supported.
            They override the `volumeCS` and `imageCS`, which can be set
            to `None` when using one of the pre-defined modes.

        mirror : bool, optional
            Whether or not a mirror operation should be applied to the
            reconstruction volume. For many 3D processing softwares,
            this parameter should be set to `True` to avoid having to
            mirror the volume after loading it into the software.

        Returns
        -------
        P : Matrix
            Projection matrix.

        Notes
        -----
        The image coordinate system (`imageCS`) should match the notation
        used by the reconstruction software, and is expressed in terms of
        the detector coordinate system.

        The detector coordinate system has its origin at the detector center,
        the u unit vector points in the row vector direction, and the
        v unit vector points in column vector direction (they are always assumed
        to be unit vectors).

        The center (origin) of the `imageCS` should be where the reconstruction
        software places the origin of its own projection image coordinate
        system. For example, CERA places it at the center of the lower-left pixel
        of the projection image.
        &#34;&#34;&#34;

        validModes = [&#34;openCT&#34;, &#34;CERA&#34;]

        if mode is not None:
            if mode in validModes:  # Override imageCS
                image = CoordinateSystem()

                if mode == &#34;openCT&#34;:
                    &#34;&#34;&#34;openCT places the origin of the image CS at the detector 
                    center. The constructor places it at (0,0,0) automatically,
                    so there is nothing to do. Comments for illustration.&#34;&#34;&#34;
                    # image.center.x = 0
                    # image.center.y = 0
                    # image.center.z = 0

                    &#34;&#34;&#34;openCT&#39;s image CS is in mm units. We assume that all
                    other coordinate systems are in mm as well here (at least
                    when imported from JSON file). No scaling of the basis vectors is necessary.&#34;&#34;&#34;
                    # image.u.scale(1.0)
                    # image.v.scale(1.0)
                    # image.w.scale(1.0)

                elif mode == &#34;CERA&#34;:
                    if self.detector.sizeIsSet():
                        &#34;&#34;&#34;CERA places the origin of the image CS in the center
                        of the lower left pixel of the projection image.&#34;&#34;&#34;
                        image.center.x = -self.detector.physWidth  / 2.0 + 0.5*self.detector.pitchU
                        image.center.y =  self.detector.physHeight / 2.0 - 0.5*self.detector.pitchV
                        # image.center.z = 0

                        &#34;&#34;&#34;CERA&#39;s unit of the image CS is in px, so we need to
                        scale the image CS basis vectors by the pixel size.
                        Also, v points up instead of down.&#34;&#34;&#34;
                        image.u.scale( self.detector.pitchU)
                        image.v.scale(-self.detector.pitchV)
                        image.w.scale(-1.0)
                    else:
                        raise RuntimeError(&#34;Detector size not set. To calculate a projection matrix for CERA, you need to set the size of the detector. Use the setSize() function of your detector object.&#34;)
            else:
                raise RuntimeError(&#34;Unsupported mode for projection matrix: \&#34;{}\&#34;&#34;.format(mode))
        elif imageCS is not None:
            image = copy.deepcopy(imageCS)
        else:
             # Set a standard coordinate system. Results in pure
             # detector coordinate system after transformation.
            image = CoordinateSystem()

        world    = CoordinateSystem()
        source   = copy.deepcopy(self.source)

        # The 3D volume (reconstruction space).
        volume = None
        if volumeCS is not None:
            volume = copy.deepcopy(volumeCS)
            volume.changeReferenceFrame(self.stage, world)
        else:
            volume = copy.deepcopy(self.stage)

        &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
        vectors of the volume CS .&#34;&#34;&#34;
        scale_volume_u = volume.u.length()
        scale_volume_v = volume.v.length()
        scale_volume_w = volume.w.length()

        # Detach the image CS from the detector CS and
        # express it in terms of the world CS:
        image.changeReferenceFrame(self.detector, world)

        &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
        vectors of the image CS.&#34;&#34;&#34;
        scale_image_u = image.u.length()
        scale_image_v = image.v.length()
        scale_image_w = image.w.length()

        # Save a source CS as seen from the detector CS. This is convenient to
        # later get the SDD, ufoc and vfoc:
        source_from_image = copy.deepcopy(self.source)
        source_from_image.changeReferenceFrame(world, image)

        # Make the volume CS the new world CS:
        source.changeReferenceFrame(world, volume)
        image.changeReferenceFrame(world, volume)
        volume.changeReferenceFrame(world, volume)

        # Translation vector from volume to source:
        rfoc = source.center - volume.center
        xfoc = rfoc.x
        yfoc = rfoc.y
        zfoc = rfoc.z
        SOD = rfoc.length()

        # Focus point on detector: principal, perpendicular ray.
        # In the detector coordinate system, ufoc and vfoc are the u and v coordinates
        # of the source center; SDD (perpendicular to detector plane) is source w coordinate.
        ufoc = source_from_image.center.x / scale_image_u
        vfoc = source_from_image.center.y / scale_image_v
        wfoc = source_from_image.center.z / scale_image_w
        SDD  = abs(source_from_image.center.z)

        # Mirror volume:
        if mirror:
            M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])
        else:
            M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0,  1, 0], [0, 0, 0, 1]])

        # Scale: volume units -&gt; world units
        A = Matrix(values=[[scale_volume_u, 0, 0, 0], [0, scale_volume_v, 0, 0], [0, 0, scale_volume_w, 0], [0, 0, 0, 1]])

        # Move origin to source (the origin of the camera CS)
        F = Matrix(values=[[1, 0, 0, -xfoc], [0, 1, 0, -yfoc], [0, 0, 1, -zfoc]])

        # Rotations:
        R = basisTransformMatrix(volume, image)

        # Projection onto detector and scaling (world units -&gt; volume units):
        S = Matrix(values=[[SDD/scale_image_u, 0, 0], [0, SDD/scale_image_v, 0], [0, 0, 1.0/scale_image_w]])

        # Shift in detector CS: (ufoc and vfoc must be in scaled units)
        T = Matrix(values=[[1, 0, ufoc], [0, 1, vfoc], [0, 0, 1]])

        # Multiply all together:
        P = T * (S * (R * (F * (A*M))))

        # Renormalize:
        lower_right = P.get(col=3, row=2)
        if lower_right != 0:
            P.scale(1.0/lower_right)

        return P

    def createDetectorFlatField_rays(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction. &#34;&#34;&#34;
        width      = self.detector.cols()
        height     = self.detector.rows()
        pixelSizeU = self.detector.pitchU
        pixelSizeV = self.detector.pitchV

        if(width is None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height is None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeU is None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeV is None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        log(&#34;Geometry definition from JSON file:\n\
   Detector Angle:    {}\n\
   Detector Distance: {}\n\
   SDD:               {}\n\
   Pixels U:          {}\n\
   Pixels V:          {}\n\
   Pitch U:           {}\n\
   Pitch V:           {}\n\
   Source:            {}, {}, {}\n\
   Detector:          {}, {}, {}\n\
   Connection Vector: {}, {}, {}\n\
   Detector Vector U: {}, {}, {}\n\
   Detector Vector V: {}, {}, {}\n\
   Detector Vector W: {}, {}, {}&#34;.format(alpha, dist, SDD, width, height, pixelSizeU, pixelSizeV, sx, sy, sz, dx, dy, dz, connectionLine.x, connectionLine.y, connectionLine.z, ux, uy, uz, vx, vy, vz, wx, wy, wz))

        maxIntensity = 0
        maxX = 0
        maxY = 0
        minDistToSource = 0
        brightestIncidenceAngle = 0

        gridSize = 3
        gridSizeSq = gridSize*gridSize

        for x in range(width):
            for y in range(height):
                factorSum = 0
                for gx in range(gridSize):
                    for gy in range(gridSize):
                        # Calculate coordinates of pixel center in mm:
                        # Grid with margin:
                        stepSize = 1.0 / (gridSize+1)
                        pixel = self.detector.pixelVector(x+(gx+1)*stepSize, y+(gy+1)*stepSize)

                        # Grid with no margin:
                        #if gridSize &gt; 1:
                        #    stepSize = 1.0 / (gridSize-1)
                        #    pixel = self.detector.pixelVector(x+gx*stepSize, y+gy*stepSize)
                        #else:
                        #    pixel = self.detector.pixelVectorCenter(x, y)

                        distToSource = self.source.center.distance(pixel)

                        # Angle of incident rays:
                        vecSourceToPixel = Vector(pixel.x-sx, pixel.y-sy, pixel.z-sz)
                        incidenceAngle = abs(self.detector.w.angle(vecSourceToPixel))
                        if incidenceAngle &gt; (math.pi/2):
                            incidenceAngle = math.pi - incidenceAngle

                        intensityFactor = math.cos(incidenceAngle)*math.pow(SDD/distToSource, 2)
                        factorSum += intensityFactor

                intensityWeight = factorSum / gridSizeSq

                if intensityWeight &gt; maxIntensity:
                    maxIntensity = intensityWeight
                    maxX = x
                    maxY = y
                    minDistToSource = distToSource
                    brightestIncidenceAngle = incidenceAngle

                flatField.setPixel(x, y, intensityWeight)

            progress = 100*(float(x+1)/float(width))
            print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        return flatField

    def pixelAreaOnUnitSphere(self, A, B, C, D):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C, D must be vectors pointing to pixel corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()
        
        ACin  = A.cross(C)
        DAin  = D.cross(A)
        CDin  = C.cross(D)
        ACout = ACin.inverse()
        DAout = DAin.inverse()
        CDout = CDin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        # areaABC = alpha + beta + gamma - math.pi

        # Spherical Triangle ACD:
        rho   = ACin.angle(DAout)
        sigma = CDin.angle(ACout)
        tau   = DAin.angle(CDout)

        # areaACD = rho + tau + sigma - math.pi

        pxSphericalArea = (alpha + beta + gamma + rho + sigma + tau) - 2*math.pi

        return pxSphericalArea

    def triangleAreaOnUnitSphere(self, A, B, C):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to ´triangle corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        areaABC = alpha + beta + gamma - math.pi

        return areaABC

    def polygonAreaOnUnitSphere(self, polygon):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        if len(polygon.points) &gt;= 3:
            # Start at first point
            p1 = polygon.points[0]

            area = 0

            for i in range(1, len(polygon.points)-1):
                p2 = polygon.points[i]
                p3 = polygon.points[i+1]

                area += self.triangleAreaOnUnitSphere(p1, p2, p3)

            return area
        else:
            return 0

    &#34;&#34;&#34;
    def createDetectorFlatField_sphere_old(self, clippingPolygon=None):
        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = dist * math.cos(alpha)

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)

        print(&#34;SDD: {}&#34;.format(SDD))
        print(&#34;Pitch: {}, {}&#34;.format(hpu, hpv))
        #print(&#34;Brightest Pixel Area: {}&#34;.format(areaOfBrightestPixel))

        flatField = Image()
        flatField.shape(det.cols(), det.rows(), 0, flatField.getInternalDataType())

        maxArea = 0
        maxX = 0
        maxY = 0
        maxCenter = 0
        # Go through pixels:
        for x in range(det.cols()):
            for y in range(det.rows()):
                # Define Pixel corners:
                A = det.pixelVector(x,   y)
                B = det.pixelVector(x+1, y)
                C = det.pixelVector(x+1, y+1)
                D = det.pixelVector(x,   y+1)

                pxSphericalArea = self.pixelAreaOnUnitSphere(A, B, C, D)
                flatField.setPixel(x, y, pxSphericalArea)

                if pxSphericalArea &gt; maxArea:
                    maxArea = pxSphericalArea
                    maxX = x
                    maxY = y

            progress = 100*(float(x+1)/float(det.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)


        maxCenter = det.pixelVectorCenter(maxX, maxY)
        distToSource = maxCenter.length()
        incidenceAngle = abs(self.detector.w.angle(maxCenter))

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Vector: {}, {}, {}&#34;.format(maxCenter.x, maxCenter.y, maxCenter.z))
        print(&#34;  Distance to Source: {}&#34;.format(distToSource))
        print(&#34;  Spherical Area: {}&#34;.format(maxArea))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(incidenceAngle, 180*incidenceAngle/math.pi))

        return flatField
    &#34;&#34;&#34;

    def createDetectorFlatField_sphere(self, *coverPolygons):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Geometrical approach using spherical geometry. &#34;&#34;&#34;

        # Change to the detector coordinate system:
        D = copy.deepcopy(self.detector)
        S = copy.deepcopy(self.source)
        world = CoordinateSystem()  # will be initialized as world

        S.changeReferenceFrame(world, D)
        D.changeReferenceFrame(world, D)
        D.computeGeometryParameters()

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = abs(S.center.z)

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        pu = D.pitchU
        pv = D.pitchV
        nRows = D.rows()
        nCols = D.cols()

        hpu = 0.5*pu
        hpv = 0.5*pv
        pA = Vector(SDD,  hpu,  hpv)
        pB = Vector(SDD, -hpu,  hpv)
        pC = Vector(SDD, -hpu, -hpv)
        pD = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(pA, pB, pC, pD)

        # Full flat field image (without any clipping bodies):
        flatField = Image()
        flatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # A second image with a clipping body under consideration: (both will be returned)
        clippedFlatField = None
        if len(coverPolygons) &gt; 0:
            clippedFlatField = Image()
            clippedFlatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # Upper left detector corner in world coordinates (remember: world is now the detector CS)
        p00 = D.pixelVector(0, 0)

        stepRight      = Vector(pu, 0,  0)
        stepDown       = Vector(0,  pv, 0)
        stepRightDown  = Vector(pu, pv, 0)

        # Move the clipping polygon to a coordinate system
        # where source is centered:
        for coverPolygon in coverPolygons:
            for p in range(len(coverPolygon.points)):
                coverPolygon.points[p] = coverPolygon.points[p] - S.center

        # Go through pixels:
        for x in range(nCols):
            for y in range(nRows):
                # Pixel in world coordinates (remember: world is now the detector CS)
                shift = Vector(x*pu, y*pv, 0)

                # Define Pixel corners:
                pA = p00 + shift
                pB = pA  + stepRight
                pC = pA  + stepRightDown
                pD = pA  + stepDown

                # Center source at (0, 0, 0):
                pA = pA - S.center
                pB = pB - S.center
                pC = pC - S.center
                pD = pD - S.center

                pixelPolygon = Polygon(pA, pB, pC, pD)
                pxSphericalArea  = self.polygonAreaOnUnitSphere(pixelPolygon)

                flatField.setPixel(x, y, pxSphericalArea)

                if len(coverPolygons) &gt; 0:
                    for coverPolygon in coverPolygons:
                        pixelPolygon = pixelPolygon.clip(coverPolygon)
                        
                    # Remove the intensity covered by the clipping polygon:
                    pixelPolygon.make3D(zComponent=SDD)
                    subarea = self.polygonAreaOnUnitSphere(pixelPolygon)
                    pxSphericalArea -= subarea

                    clippedFlatField.setPixel(x, y, pxSphericalArea)

            progress = 100*(float(x+1)/float(D.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)
        if clippedFlatField != None:
            clippedFlatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)

        return flatField, clippedFlatField

    def solidAngle(self, l, m):
        &#34;&#34;&#34; Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth. &#34;&#34;&#34;
        if l != 0:
            return (l/abs(l)) * math.atan(abs(l)*m/math.sqrt(1.0+l**2+m**2))
        else:
            return 0

    def createDetectorFlatField_analytical(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Analytical approach by Florian Wohlgemuth. &#34;&#34;&#34;

        width  = self.detector.cols()
        height = self.detector.rows()
        pitchU = self.detector.pitchU
        pitchV = self.detector.pitchV

        if(width is None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height is None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchU is None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchV is None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        maxIntensity = 0
        maxX = 0
        maxY = 0

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        upperLeft_u = det.pixelVector(0, 0).dot(self.detector.u)
        upperLeft_v = det.pixelVector(0, 0).dot(self.detector.v)
        upperLeft_w = det.pixelVector(0, 0).dot(self.detector.w)

        if upperLeft_w != 0:   # check if detector is not facing its edge towards the source
            for x in range(width):
                for y in range(height):
                    nu = x
                    nv = y
                    lambda0 = (upperLeft_u + nu*pitchU) / upperLeft_w
                    lambda1 = (upperLeft_u + (nu+1)*pitchU) / upperLeft_w
                    mu0     = (upperLeft_v + nv*pitchV) / upperLeft_w
                    mu1     = (upperLeft_v + (nv+1)*pitchV) / upperLeft_w

                    omega = self.solidAngle(lambda0, mu0) + self.solidAngle(lambda1, mu1) - self.solidAngle(lambda0, mu1) - self.solidAngle(lambda1, mu0)

                    if omega &gt; maxIntensity:
                        maxIntensity = omega
                        maxX = x
                        maxY = y

                    flatField.setPixel(x, y, omega)

                progress = 100*(float(x+1)/float(width))
                print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        # print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        # print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        # Method #1: find hypothetical brightest pixel
        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale actual maximum to 1.
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, dataType=&#34;float32&#34;)
        return flatField


    def createDetectorFlatField(self):
        return createDetectorFlatField_analytical()

def writeCERAconfig(geo, totalAngle, projectionFilePattern, matrices, basename, voxelsX, voxelsY, voxelsZ, i0max=60000):
    now = datetime.now()

    nProjections = len(matrices)
    projTableString = &#34;&#34;&#34;projtable.txt version 3
{timestring}

# format: angle / entries of projection matrices
{nProjections}
&#34;&#34;&#34;.format(
    nProjections=nProjections,
    timestring=now.strftime(&#34;%a %b %d %H:%M:%S %Y&#34;)
    )

    for i in range(nProjections):
        m=matrices[i]
        projTableString += &#34;&#34;&#34;@{nr}
0.0 0.0
{c00} {c01} {c02} {c03}
{c10} {c11} {c12} {c13}
{c20} {c21} {c22} {c23}

&#34;&#34;&#34;.format(
        nr=(i+1),
        c00=m.get(col=0, row=0),
        c01=m.get(col=1, row=0),
        c02=m.get(col=2, row=0),
        c03=m.get(col=3, row=0),
        c10=m.get(col=0, row=1),
        c11=m.get(col=1, row=1),
        c12=m.get(col=2, row=1),
        c13=m.get(col=3, row=1),
        c20=m.get(col=0, row=2),
        c21=m.get(col=1, row=2),
        c22=m.get(col=2, row=2),
        c23=m.get(col=3, row=2)
    )

    with open(&#34;{}_projtable.txt&#34;.format(basename), &#39;w&#39;) as f:
        f.write(projTableString)
        f.close()

    voxelSizeXY = geo.detector.pitchU * geo.SOD / geo.SDD
    voxelSizeZ  = geo.detector.pitchV * geo.SOD / geo.SDD

    configFileString = &#34;&#34;&#34;#CERACONFIG

[Projections]
NumChannelsPerRow = {nCols}
NumRows = {nRows}
PixelSizeU = {psu}
PixelSizeV = {psv}
Rotation = None
FlipU = false
FlipV = true
Padding = 0
BigEndian = false
CropBorderRight = 0
CropBorderLeft = 0
CropBorderTop = 0
CropBorderBottom = 0
BinningFactor = None
SkipProjectionInterval = 1
ProjectionDataDomain = Intensity
RawHeaderSize = 0

[Volume]
SizeX = {volx}
SizeY = {voly}
SizeZ = {volz}
# Midpoints are only necessary for reconstructions
# without projection matrices.
MidpointX = {midpointx}
MidpointY = {midpointy}
MidpointZ = {midpointz}
VoxelSizeX = {vsx}
VoxelSizeY = {vsy}
VoxelSizeZ = {vsz}
Datatype = float

[CustomKeys]
NumProjections = {nProjections}    
ProjectionFileType = tiff
VolumeOutputPath = {basename}.raw
ProjectionStartNum = 0
ProjectionFilenameMask = {projFilePattern}

[CustomKeys.ProjectionMatrices]
SourceObjectDistance = {SOD}
SourceImageDistance = {SDD}
DetectorOffsetU = {offu}
DetectorOffsetV = {offv}
StartAngle = {startAngle}
ScanAngle = {scanAngle}
AquisitionDirection = CW
a = {a}
b = {b}
c = {c}
ProjectionMatrixFilename = {basename}_projtable.txt

[Backprojection]
ClearOutOfRegionVoxels = false
InterpolationMode = bilinear
FloatingPointPrecision = half
Enabled = true

[Filtering]
Enabled = true
Kernel = shepp

[I0Log]
Enabled = true
Epsilon = 1.0E-5
GlobalI0Value = {i0max}
&#34;&#34;&#34;.format(
    basename=basename,
    nCols=int(geo.detector.cols()),
    nRows=int(geo.detector.rows()),
    psu=geo.detector.pitchU,
    psv=geo.detector.pitchV,
    volx=int(voxelsX),
    voly=int(voxelsY),
    volz=int(voxelsZ),
    midpointx=0, #!
    midpointy=0, #!
    midpointz=0, #!
    vsx=voxelSizeXY,
    vsy=voxelSizeXY,
    vsz=voxelSizeZ,
    nProjections=int(nProjections),
    projFilePattern=projectionFilePattern,
    SOD=geo.SOD,
    SDD=geo.SDD,
    offu=0, #!
    offv=0, #!
    startAngle=0, #!
    scanAngle=totalAngle,
    a=0, #!
    b=0, #!
    c=0, #!
    i0max=i0max
    )

    with open(&#34;{}.config&#34;.format(basename), &#39;w&#39;) as f:
        f.write(configFileString)
        f.close()


def writeOpenCTFile(geo, totalAngle, boundingBoxX, boundingBoxY, boundingBoxZ, matrices, filename, volumename, projectionFilenames):
    nProjections = len(matrices)
    matrixString = &#34;&#34;

    i = 0
    for m in matrices:
        if i&gt;0:
            matrixString += &#34;,\n\n            &#34;

        matrixString += &#34;[ &#34;
        for row in range(m.rows):
            if row &gt; 0:
                matrixString += &#34;,\n              &#34;
            matrixString += &#34;[&#34;
            for col in range(m.cols):
                if col &gt; 0:
                    matrixString += &#34;, &#34;

                matrixString += &#34;{}&#34;.format(m.get(col=col, row=row))
            matrixString += &#34;]&#34;
        matrixString += &#34; ]&#34;
        i += 1

    filesString = &#34;&#34;
    if len(matrices) == len(projectionFilenames):
        for i in range(len(matrices)):
            if i &gt; 0:
                filesString += &#34;,\n                &#34;
            #filesString += &#39;&#34;{:05d}.tif&#34;&#39;.format(i)
            filesString += &#39;&#34;{}&#34;&#39;.format(projectionFilenames[i])
    else:
        raise Exception(&#34;The number of projection matrices ({}) does not match the number of projection file names ({}).&#34;.format(len(matrices), len(projectionFilenames)))


    content = &#34;&#34;&#34;{{
    &#34;version&#34;: {{&#34;major&#34;:1, &#34;minor&#34;:0}},
    &#34;openCTJSON&#34;:     {{
        &#34;versionMajor&#34;: 1,
        &#34;versionMinor&#34;: 0,
        &#34;revisionNumber&#34;: 0,
        &#34;variant&#34;: &#34;FreeTrajectoryCBCTScan&#34;
    }},
    &#34;units&#34;: {{
        &#34;length&#34;: &#34;Millimeter&#34;
    }},
    &#34;volumeName&#34;:  &#34;{volumeName}&#34;,
    &#34;projections&#34;: {{
        &#34;numProjections&#34;:  {nProjections},
        &#34;intensityDomain&#34;: true,
        &#34;images&#34;:          {{
            &#34;directory&#34;: &#34;.&#34;,
            &#34;dataType&#34;:  &#34;UInt16&#34;,
            &#34;fileType&#34;:  &#34;TIFF&#34;,
            &#34;files&#34;:     [
                {filesString}
            ]
        }},
        &#34;matrices&#34;: [
            {matrixString}
        ]
    }},
    &#34;geometry&#34;:    {{
        &#34;totalAngle&#34;:           {totalAngle},
        &#34;skipAngle&#34;:            0,
        &#34;detectorPixel&#34;:        [
            {nPixelsX},
            {nPixelsY}
        ],
        &#34;detectorSize&#34;:         [
            {detectorSizeX},
            {detectorSizeY}
        ],
        &#34;mirrorDetectorAxis&#34;:   &#34;&#34;,
        &#34;distanceSourceObject&#34;: {SOD},
        &#34;distanceObjectDetector&#34;: {ODD},
        &#34;objectBoundingBox&#34;:    [
            [
                {bbx},
                0.0,
                0.0,
                0.0
            ],
            [
                0.0,
                {bby},
                0.0,
                0.0
            ],
            [
                0.0,
                0.0,
                {bbz},
                0.0
            ],
            [
                0.0,
                0.0,
                0.0,
                1.0
            ]
        ]
    }},
    &#34;corrections&#34;: {{
        &#34;brightImages&#34;: {{
            &#34;directory&#34;: &#34;&#34;,
            &#34;dataType&#34;:  &#34;&#34;,
            &#34;fileType&#34;:  &#34;&#34;,
            &#34;files&#34;:     []
        }},
        &#34;darkImage&#34;:    {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;badPixelMask&#34;: {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;intensities&#34;:  []
    }}
}}&#34;&#34;&#34;.format(
    nProjections=nProjections,
    matrixString=matrixString,
    nPixelsX=int(geo.detector.cols()),
    nPixelsY=int(geo.detector.rows()),
    detectorSizeX=geo.detector.physWidth,
    detectorSizeY=geo.detector.physHeight,
    SOD=geo.SOD,
    ODD=geo.ODD,
    totalAngle=totalAngle,
    bbx=boundingBoxX,
    bby=boundingBoxY,
    bbz=boundingBoxZ,
    filesString=filesString,
    volumeName=volumename
    )

    with open(filename, &#39;w&#39;) as f:
        f.write(content)
        f.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctsimu.geometry.basisTransformMatrix"><code class="name flex">
<span>def <span class="ident">basisTransformMatrix</span></span>(<span>fromCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>, toCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>) ‑> <a title="ctsimu.primitives.Matrix" href="primitives.html#ctsimu.primitives.Matrix">Matrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a matrix that transforms coordinates from <code>fromCS</code> to <code>toCS</code>.</p>
<p><code>fromCS</code> and <code>toCS</code> must have the same common reference frame
(e.g. the world coordinate system).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The origin coordinate system.</dd>
<dt><strong><code>toCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The target coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>The 3x3 basis transformation matrix.</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li>S. Widnall: <a href="https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec03.pdf">Lecture L3 - Vectors, Matrices and Coordinate Transformations</a></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def basisTransformMatrix(fromCS:&#39;CoordinateSystem&#39;, toCS:&#39;CoordinateSystem&#39;) -&gt; Matrix:
    &#34;&#34;&#34;Calculate a matrix that transforms coordinates from `fromCS` to `toCS`.

    `fromCS` and `toCS` must have the same common reference frame
    (e.g. the world coordinate system).

    Parameters
    ----------
    fromCS : CoordinateSystem
        The origin coordinate system.

    toCS : CoordinateSystem
        The target coordinate system.

    Returns
    -------
    T : Matrix
        The 3x3 basis transformation matrix.

    References
    ----------
    * S. Widnall: [Lecture L3 - Vectors, Matrices and Coordinate Transformations]
    [Lecture L3 - Vectors, Matrices and Coordinate Transformations]: https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec03.pdf
    &#34;&#34;&#34;

    T = Matrix(3, 3)

    # Row 1:
    T.value[0][0] = toCS.u.unitVector().dot(fromCS.u.unitVector())
    T.value[0][1] = toCS.u.unitVector().dot(fromCS.v.unitVector())
    T.value[0][2] = toCS.u.unitVector().dot(fromCS.w.unitVector())

    # Row 2:
    T.value[1][0] = toCS.v.unitVector().dot(fromCS.u.unitVector())
    T.value[1][1] = toCS.v.unitVector().dot(fromCS.v.unitVector())
    T.value[1][2] = toCS.v.unitVector().dot(fromCS.w.unitVector())

    # Row 3:
    T.value[2][0] = toCS.w.unitVector().dot(fromCS.u.unitVector())
    T.value[2][1] = toCS.w.unitVector().dot(fromCS.v.unitVector())
    T.value[2][2] = toCS.w.unitVector().dot(fromCS.w.unitVector())

    return T</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.writeCERAconfig"><code class="name flex">
<span>def <span class="ident">writeCERAconfig</span></span>(<span>geo, totalAngle, projectionFilePattern, matrices, basename, voxelsX, voxelsY, voxelsZ, i0max=60000)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeCERAconfig(geo, totalAngle, projectionFilePattern, matrices, basename, voxelsX, voxelsY, voxelsZ, i0max=60000):
    now = datetime.now()

    nProjections = len(matrices)
    projTableString = &#34;&#34;&#34;projtable.txt version 3
{timestring}

# format: angle / entries of projection matrices
{nProjections}
&#34;&#34;&#34;.format(
    nProjections=nProjections,
    timestring=now.strftime(&#34;%a %b %d %H:%M:%S %Y&#34;)
    )

    for i in range(nProjections):
        m=matrices[i]
        projTableString += &#34;&#34;&#34;@{nr}
0.0 0.0
{c00} {c01} {c02} {c03}
{c10} {c11} {c12} {c13}
{c20} {c21} {c22} {c23}

&#34;&#34;&#34;.format(
        nr=(i+1),
        c00=m.get(col=0, row=0),
        c01=m.get(col=1, row=0),
        c02=m.get(col=2, row=0),
        c03=m.get(col=3, row=0),
        c10=m.get(col=0, row=1),
        c11=m.get(col=1, row=1),
        c12=m.get(col=2, row=1),
        c13=m.get(col=3, row=1),
        c20=m.get(col=0, row=2),
        c21=m.get(col=1, row=2),
        c22=m.get(col=2, row=2),
        c23=m.get(col=3, row=2)
    )

    with open(&#34;{}_projtable.txt&#34;.format(basename), &#39;w&#39;) as f:
        f.write(projTableString)
        f.close()

    voxelSizeXY = geo.detector.pitchU * geo.SOD / geo.SDD
    voxelSizeZ  = geo.detector.pitchV * geo.SOD / geo.SDD

    configFileString = &#34;&#34;&#34;#CERACONFIG

[Projections]
NumChannelsPerRow = {nCols}
NumRows = {nRows}
PixelSizeU = {psu}
PixelSizeV = {psv}
Rotation = None
FlipU = false
FlipV = true
Padding = 0
BigEndian = false
CropBorderRight = 0
CropBorderLeft = 0
CropBorderTop = 0
CropBorderBottom = 0
BinningFactor = None
SkipProjectionInterval = 1
ProjectionDataDomain = Intensity
RawHeaderSize = 0

[Volume]
SizeX = {volx}
SizeY = {voly}
SizeZ = {volz}
# Midpoints are only necessary for reconstructions
# without projection matrices.
MidpointX = {midpointx}
MidpointY = {midpointy}
MidpointZ = {midpointz}
VoxelSizeX = {vsx}
VoxelSizeY = {vsy}
VoxelSizeZ = {vsz}
Datatype = float

[CustomKeys]
NumProjections = {nProjections}    
ProjectionFileType = tiff
VolumeOutputPath = {basename}.raw
ProjectionStartNum = 0
ProjectionFilenameMask = {projFilePattern}

[CustomKeys.ProjectionMatrices]
SourceObjectDistance = {SOD}
SourceImageDistance = {SDD}
DetectorOffsetU = {offu}
DetectorOffsetV = {offv}
StartAngle = {startAngle}
ScanAngle = {scanAngle}
AquisitionDirection = CW
a = {a}
b = {b}
c = {c}
ProjectionMatrixFilename = {basename}_projtable.txt

[Backprojection]
ClearOutOfRegionVoxels = false
InterpolationMode = bilinear
FloatingPointPrecision = half
Enabled = true

[Filtering]
Enabled = true
Kernel = shepp

[I0Log]
Enabled = true
Epsilon = 1.0E-5
GlobalI0Value = {i0max}
&#34;&#34;&#34;.format(
    basename=basename,
    nCols=int(geo.detector.cols()),
    nRows=int(geo.detector.rows()),
    psu=geo.detector.pitchU,
    psv=geo.detector.pitchV,
    volx=int(voxelsX),
    voly=int(voxelsY),
    volz=int(voxelsZ),
    midpointx=0, #!
    midpointy=0, #!
    midpointz=0, #!
    vsx=voxelSizeXY,
    vsy=voxelSizeXY,
    vsz=voxelSizeZ,
    nProjections=int(nProjections),
    projFilePattern=projectionFilePattern,
    SOD=geo.SOD,
    SDD=geo.SDD,
    offu=0, #!
    offv=0, #!
    startAngle=0, #!
    scanAngle=totalAngle,
    a=0, #!
    b=0, #!
    c=0, #!
    i0max=i0max
    )

    with open(&#34;{}.config&#34;.format(basename), &#39;w&#39;) as f:
        f.write(configFileString)
        f.close()</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.writeOpenCTFile"><code class="name flex">
<span>def <span class="ident">writeOpenCTFile</span></span>(<span>geo, totalAngle, boundingBoxX, boundingBoxY, boundingBoxZ, matrices, filename, volumename, projectionFilenames)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeOpenCTFile(geo, totalAngle, boundingBoxX, boundingBoxY, boundingBoxZ, matrices, filename, volumename, projectionFilenames):
    nProjections = len(matrices)
    matrixString = &#34;&#34;

    i = 0
    for m in matrices:
        if i&gt;0:
            matrixString += &#34;,\n\n            &#34;

        matrixString += &#34;[ &#34;
        for row in range(m.rows):
            if row &gt; 0:
                matrixString += &#34;,\n              &#34;
            matrixString += &#34;[&#34;
            for col in range(m.cols):
                if col &gt; 0:
                    matrixString += &#34;, &#34;

                matrixString += &#34;{}&#34;.format(m.get(col=col, row=row))
            matrixString += &#34;]&#34;
        matrixString += &#34; ]&#34;
        i += 1

    filesString = &#34;&#34;
    if len(matrices) == len(projectionFilenames):
        for i in range(len(matrices)):
            if i &gt; 0:
                filesString += &#34;,\n                &#34;
            #filesString += &#39;&#34;{:05d}.tif&#34;&#39;.format(i)
            filesString += &#39;&#34;{}&#34;&#39;.format(projectionFilenames[i])
    else:
        raise Exception(&#34;The number of projection matrices ({}) does not match the number of projection file names ({}).&#34;.format(len(matrices), len(projectionFilenames)))


    content = &#34;&#34;&#34;{{
    &#34;version&#34;: {{&#34;major&#34;:1, &#34;minor&#34;:0}},
    &#34;openCTJSON&#34;:     {{
        &#34;versionMajor&#34;: 1,
        &#34;versionMinor&#34;: 0,
        &#34;revisionNumber&#34;: 0,
        &#34;variant&#34;: &#34;FreeTrajectoryCBCTScan&#34;
    }},
    &#34;units&#34;: {{
        &#34;length&#34;: &#34;Millimeter&#34;
    }},
    &#34;volumeName&#34;:  &#34;{volumeName}&#34;,
    &#34;projections&#34;: {{
        &#34;numProjections&#34;:  {nProjections},
        &#34;intensityDomain&#34;: true,
        &#34;images&#34;:          {{
            &#34;directory&#34;: &#34;.&#34;,
            &#34;dataType&#34;:  &#34;UInt16&#34;,
            &#34;fileType&#34;:  &#34;TIFF&#34;,
            &#34;files&#34;:     [
                {filesString}
            ]
        }},
        &#34;matrices&#34;: [
            {matrixString}
        ]
    }},
    &#34;geometry&#34;:    {{
        &#34;totalAngle&#34;:           {totalAngle},
        &#34;skipAngle&#34;:            0,
        &#34;detectorPixel&#34;:        [
            {nPixelsX},
            {nPixelsY}
        ],
        &#34;detectorSize&#34;:         [
            {detectorSizeX},
            {detectorSizeY}
        ],
        &#34;mirrorDetectorAxis&#34;:   &#34;&#34;,
        &#34;distanceSourceObject&#34;: {SOD},
        &#34;distanceObjectDetector&#34;: {ODD},
        &#34;objectBoundingBox&#34;:    [
            [
                {bbx},
                0.0,
                0.0,
                0.0
            ],
            [
                0.0,
                {bby},
                0.0,
                0.0
            ],
            [
                0.0,
                0.0,
                {bbz},
                0.0
            ],
            [
                0.0,
                0.0,
                0.0,
                1.0
            ]
        ]
    }},
    &#34;corrections&#34;: {{
        &#34;brightImages&#34;: {{
            &#34;directory&#34;: &#34;&#34;,
            &#34;dataType&#34;:  &#34;&#34;,
            &#34;fileType&#34;:  &#34;&#34;,
            &#34;files&#34;:     []
        }},
        &#34;darkImage&#34;:    {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;badPixelMask&#34;: {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;intensities&#34;:  []
    }}
}}&#34;&#34;&#34;.format(
    nProjections=nProjections,
    matrixString=matrixString,
    nPixelsX=int(geo.detector.cols()),
    nPixelsY=int(geo.detector.rows()),
    detectorSizeX=geo.detector.physWidth,
    detectorSizeY=geo.detector.physHeight,
    SOD=geo.SOD,
    ODD=geo.ODD,
    totalAngle=totalAngle,
    bbx=boundingBoxX,
    bby=boundingBoxY,
    bbz=boundingBoxZ,
    filesString=filesString,
    volumeName=volumename
    )

    with open(filename, &#39;w&#39;) as f:
        f.write(content)
        f.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.geometry.CoordinateSystem"><code class="flex name class">
<span>class <span class="ident">CoordinateSystem</span></span>
</code></dt>
<dd>
<div class="desc"><p>Coordinate system: center point and axis vectors.</p>
<p>An object according to the CTSimU scenario specification,
containing a center coordinate and an orientation in 3D space.</p>
<p>The center and axis vectors are expressed in terms of the
object's reference coordinate system, which must be known implicitly
when objects of this class are used.</p>
<p>Geometrical objects could be source, stage or detector.
Samples would need additional attention due to possible attachment
to stage coordinate system (instead of world).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>Vector</code></dt>
<dd>The location of the center point in a reference
coordinate system (usually world or stage).</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector for the u axis.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector for the v axis.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector for the w axis.</dd>
</dl>
<p>Initialize as a standard world coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoordinateSystem:
    &#34;&#34;&#34;Coordinate system: center point and axis vectors.

    An object according to the CTSimU scenario specification,
    containing a center coordinate and an orientation in 3D space.
    
    The center and axis vectors are expressed in terms of the
    object&#39;s reference coordinate system, which must be known implicitly
    when objects of this class are used.

    Geometrical objects could be source, stage or detector.
    Samples would need additional attention due to possible attachment
    to stage coordinate system (instead of world).

    Attributes
    ----------
    center : Vector
        The location of the center point in a reference
        coordinate system (usually world or stage).

    u : Vector
        Basis vector for the u axis.

    v : Vector
        Basis vector for the v axis.

    w : Vector
        Basis vector for the w axis.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard world coordinate system.&#34;&#34;&#34;
        self.center  = Vector(0, 0, 0)
        self.u = Vector(1, 0, 0)
        self.v = Vector(0, 1, 0)
        self.w = Vector(0, 0, 1)

    def __str__(self):
        &#34;&#34;&#34;Information string for easy printing.&#34;&#34;&#34;

        txt  = &#34;Center: {}\n&#34;.format(self.center)
        txt += &#34;u:      {}\n&#34;.format(self.u)
        txt += &#34;v:      {}\n&#34;.format(self.v)
        txt += &#34;w:      {}\n&#34;.format(self.w)
        return txt

    def json_import(self, geometry: dict):
        &#34;&#34;&#34;Set up geometry from a JSON dictionary.

        Parameters
        ----------
        geometry : dict
            A parsed JSON dictionary from a [CTSimU scenario description] file.

        [CTSimU scenario description]: https://bamresearch.github.io/ctsimu-scenarios/

        Raises
        ------
        KeyError
            When expected JSON keys for center and vector x, y, z
            components are not found in the dictionary.
        &#34;&#34;&#34;

        # Get center position from JSON dict:
        if &#34;center&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;center&#34;]:
                cx = in_mm(geometry[&#34;center&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;center&#34;]:
                cy = in_mm(geometry[&#34;center&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;center&#34;]:
                cz = in_mm(geometry[&#34;center&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        # Try old British spelling (up to file format v0.9)
        elif &#34;centre&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;centre&#34;]:
                cx = in_mm(geometry[&#34;centre&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;centre&#34;]:
                cy = in_mm(geometry[&#34;centre&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;centre&#34;]:
                cz = in_mm(geometry[&#34;centre&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;center\&#34; section.&#34;)

        # Get vector u from JSON dict:
        if &#34;vector_u&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_u&#34;]:
                ux = geometry[&#34;vector_u&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector u.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_u&#34;]:
                uy = geometry[&#34;vector_u&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector u.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_u&#34;]:
                uz = geometry[&#34;vector_u&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector u.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_u\&#34; section.&#34;)

        # Get vector w from JSON dict:
        if &#34;vector_w&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_w&#34;]:
                wx = geometry[&#34;vector_w&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector w.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_w&#34;]:
                wy = geometry[&#34;vector_w&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector w.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_w&#34;]:
                wz = geometry[&#34;vector_w&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector w.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_w\&#34; section.&#34;)

        # Set up the geometry from the information given in the JSON file:
        c = Vector(cx, cy, cz)  # center
        u = Vector(ux, uy, uz)  # u basis vector
        w = Vector(wx, wy, wz)  # w basis vector
        v = w.cross(u)
        self.setup(c, u, v, w)
        self.makeUnitCS()

        # Apply deviations from the now-ideal geometry:
        if &#34;deviation&#34; in geometry:
            # Positional deviations:
            if &#34;position&#34; in geometry[&#34;deviation&#34;]:
                if &#34;x&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;] != None:
                        translationX = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;])
                        self.translateX(translationX)
    
                if &#34;y&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;] != None:
                        translationY = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;])
                        self.translateY(translationY)

                if &#34;z&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;] != None:
                        translationZ = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;])
                        self.translateZ(translationZ)

            # Rotations according to w&#39;&#39;v&#39;u convention:
            if &#34;rotation&#34; in geometry[&#34;deviation&#34;]:
                if &#34;w&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;] != None:
                        angleAroundW = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;])
                        self.rotateAroundW(angleAroundW)

                if &#34;v&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;] != None:
                        angleAroundV = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;])
                        self.rotateAroundV(angleAroundV)

                if &#34;u&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;] != None:
                        angleAroundU = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;])
                        self.rotateAroundU(angleAroundU)

    def setup(self, center:Vector, u:Vector, v:Vector, w:Vector):
        &#34;&#34;&#34;Set up center and orientation manually.

        Parameters
        ----------
        center : Vector
            Object&#39;s center point in reference coordinate system,
            origin of local {u,v,w} coordinate system.

        u : Vector
            Basis vector u in terms of reference coordinate system.

        v : Vector
            Basis vector v in terms of reference coordinate system.

        w : Vector
            Basis vector w in terms of reference coordinate system.

        Notes
        -----
        All basis vectors must be orthogonal.
        &#34;&#34;&#34;

        # Create new vectors from given components:
        self.center  = center
        self.u = u
        self.v = v
        self.w = w

    def update(self):
        &#34;&#34;&#34;Signal a manual update to the center position or orientation vectors.&#34;&#34;&#34;
        self.center.update()
        self.u.update()
        self.v.update()
        self.w.update()

    def makeUnitCS(self):
        &#34;&#34;&#34;Convert all basis vectors to unit vectors.&#34;&#34;&#34;
        self.u.makeUnitVector()
        self.v.makeUnitVector()
        self.w.makeUnitVector()

    def translate(self, translationVector: Vector):
        &#34;&#34;&#34;Move object in space.

        Parameters
        ----------
        translationVector : Vector
            Vector by which the object&#39;s center point should be shifted.
            Its components are added to the center&#39;s components.
        &#34;&#34;&#34;
        self.center.add(translationVector)

    def translateX(self, dx: float):
        &#34;&#34;&#34;Move object in x direction.

        Parameters
        ----------
        dx : float
            Shift amount in x direction.
        &#34;&#34;&#34;
        self.center.setx(self.center.x + float(dx))

    def translateY(self, dy: float):
        &#34;&#34;&#34;Move object in y direction.

        Parameters
        ----------
        dy : float
            Shift amount in y direction.
        &#34;&#34;&#34;
        self.center.sety(self.center.y + float(dy))

    def translateZ(self, dz: float):
        &#34;&#34;&#34;Move object in z direction.

        Parameters
        ----------
        dz : float
            Shift amount in z direction.
        &#34;&#34;&#34;
        self.center.setz(self.center.z + float(dz))

    def rotateAroundU(self, angle: float):
        &#34;&#34;&#34;Rotate object around its u axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.v.rotate(self.u, angle)
        self.w.rotate(self.u, angle)

    def rotateAroundV(self, angle: float):
        &#34;&#34;&#34;Rotate object around its v axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(self.v, angle)
        self.w.rotate(self.v, angle)

    def rotateAroundW(self, angle: float):
        &#34;&#34;&#34;Rotate object around its w axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(self.w, angle)
        self.v.rotate(self.w, angle)

    def rotate(self, axis: Vector, angle: float):
        &#34;&#34;&#34;Rotate object around a given axis by the given angle [rad].
        
        Parameters
        ----------
        axis : Vector
            The axis of rotation, in terms of the object&#39;s
            reference coordinate system (e.g. world).
        
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(axis, angle)
        self.v.rotate(axis, angle)
        self.w.rotate(axis, angle)

    def changeReferenceFrame(self, fromCS:&#39;CoordinateSystem&#39;, toCS:&#39;CoordinateSystem&#39;):
        &#34;&#34;&#34;Change the object&#39;s reference coordinate system.
        
        Parameters
        ----------
        fromCS : CoordinateSystem
            Current reference coordinate system.
        
        toCS : CoordinateSystem
            New reference coordinate system.

        Notes
        -----
        Both fromCS and toCS must be in the same reference coordinate system
        (e.g., the world coordinate system).
        &#34;&#34;&#34;

        # Rotate basis vectors into toCS:
        T = basisTransformMatrix(fromCS, toCS)
        self.u = T * self.u
        self.v = T * self.v
        self.w = T * self.w

        world = CoordinateSystem()

        # Move center to toCS:
        # 1. Translate self.center by difference of toCS and fromCS
        #    -&gt; Origins are &#34;superimposed&#34;.
        # 2. Rotate self.center from fromCS to toCS.

        # Translation vector in world coordinates:
        translator = fromCS.center - toCS.center  # in world coordinates
        # Translation vector in fromCS coordinates:
        M = basisTransformMatrix(world, fromCS)
        translator = M*translator
        relCenter = self.center + translator
        self.center = T*relCenter</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ctsimu.geometry.Detector" href="#ctsimu.geometry.Detector">Detector</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.CoordinateSystem.changeReferenceFrame"><code class="name flex">
<span>def <span class="ident">changeReferenceFrame</span></span>(<span>self, fromCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>, toCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the object's reference coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>Current reference coordinate system.</dd>
<dt><strong><code>toCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>New reference coordinate system.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Both fromCS and toCS must be in the same reference coordinate system
(e.g., the world coordinate system).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeReferenceFrame(self, fromCS:&#39;CoordinateSystem&#39;, toCS:&#39;CoordinateSystem&#39;):
    &#34;&#34;&#34;Change the object&#39;s reference coordinate system.
    
    Parameters
    ----------
    fromCS : CoordinateSystem
        Current reference coordinate system.
    
    toCS : CoordinateSystem
        New reference coordinate system.

    Notes
    -----
    Both fromCS and toCS must be in the same reference coordinate system
    (e.g., the world coordinate system).
    &#34;&#34;&#34;

    # Rotate basis vectors into toCS:
    T = basisTransformMatrix(fromCS, toCS)
    self.u = T * self.u
    self.v = T * self.v
    self.w = T * self.w

    world = CoordinateSystem()

    # Move center to toCS:
    # 1. Translate self.center by difference of toCS and fromCS
    #    -&gt; Origins are &#34;superimposed&#34;.
    # 2. Rotate self.center from fromCS to toCS.

    # Translation vector in world coordinates:
    translator = fromCS.center - toCS.center  # in world coordinates
    # Translation vector in fromCS coordinates:
    M = basisTransformMatrix(world, fromCS)
    translator = M*translator
    relCenter = self.center + translator
    self.center = T*relCenter</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.json_import"><code class="name flex">
<span>def <span class="ident">json_import</span></span>(<span>self, geometry: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up geometry from a JSON dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>dict</code></dt>
<dd>A parsed JSON dictionary from a <a href="https://bamresearch.github.io/ctsimu-scenarios/">CTSimU scenario description</a> file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>When expected JSON keys for center and vector x, y, z
components are not found in the dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_import(self, geometry: dict):
    &#34;&#34;&#34;Set up geometry from a JSON dictionary.

    Parameters
    ----------
    geometry : dict
        A parsed JSON dictionary from a [CTSimU scenario description] file.

    [CTSimU scenario description]: https://bamresearch.github.io/ctsimu-scenarios/

    Raises
    ------
    KeyError
        When expected JSON keys for center and vector x, y, z
        components are not found in the dictionary.
    &#34;&#34;&#34;

    # Get center position from JSON dict:
    if &#34;center&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;center&#34;]:
            cx = in_mm(geometry[&#34;center&#34;][&#34;x&#34;])
        else:
            raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

        if &#34;y&#34; in geometry[&#34;center&#34;]:
            cy = in_mm(geometry[&#34;center&#34;][&#34;y&#34;])
        else:
            raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
        
        if &#34;z&#34; in geometry[&#34;center&#34;]:
            cz = in_mm(geometry[&#34;center&#34;][&#34;z&#34;])
        else:
            raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

        self.center.set(cx, cy, cz)
    # Try old British spelling (up to file format v0.9)
    elif &#34;centre&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;centre&#34;]:
            cx = in_mm(geometry[&#34;centre&#34;][&#34;x&#34;])
        else:
            raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

        if &#34;y&#34; in geometry[&#34;centre&#34;]:
            cy = in_mm(geometry[&#34;centre&#34;][&#34;y&#34;])
        else:
            raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
        
        if &#34;z&#34; in geometry[&#34;centre&#34;]:
            cz = in_mm(geometry[&#34;centre&#34;][&#34;z&#34;])
        else:
            raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

        self.center.set(cx, cy, cz)
    else:
        raise KeyError(&#34;JSON file is missing a geometry \&#34;center\&#34; section.&#34;)

    # Get vector u from JSON dict:
    if &#34;vector_u&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;vector_u&#34;]:
            ux = geometry[&#34;vector_u&#34;][&#34;x&#34;]
        else:
            raise KeyError(&#34;No \&#34;x\&#34; component found for vector u.&#34;)

        if &#34;y&#34; in geometry[&#34;vector_u&#34;]:
            uy = geometry[&#34;vector_u&#34;][&#34;y&#34;]
        else:
            raise KeyError(&#34;No \&#34;y\&#34; component found for vector u.&#34;)

        if &#34;z&#34; in geometry[&#34;vector_u&#34;]:
            uz = geometry[&#34;vector_u&#34;][&#34;z&#34;]
        else:
            raise KeyError(&#34;No \&#34;z\&#34; component found for vector u.&#34;)
    else:
        raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_u\&#34; section.&#34;)

    # Get vector w from JSON dict:
    if &#34;vector_w&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;vector_w&#34;]:
            wx = geometry[&#34;vector_w&#34;][&#34;x&#34;]
        else:
            raise KeyError(&#34;No \&#34;x\&#34; component found for vector w.&#34;)

        if &#34;y&#34; in geometry[&#34;vector_w&#34;]:
            wy = geometry[&#34;vector_w&#34;][&#34;y&#34;]
        else:
            raise KeyError(&#34;No \&#34;y\&#34; component found for vector w.&#34;)

        if &#34;z&#34; in geometry[&#34;vector_w&#34;]:
            wz = geometry[&#34;vector_w&#34;][&#34;z&#34;]
        else:
            raise KeyError(&#34;No \&#34;z\&#34; component found for vector w.&#34;)
    else:
        raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_w\&#34; section.&#34;)

    # Set up the geometry from the information given in the JSON file:
    c = Vector(cx, cy, cz)  # center
    u = Vector(ux, uy, uz)  # u basis vector
    w = Vector(wx, wy, wz)  # w basis vector
    v = w.cross(u)
    self.setup(c, u, v, w)
    self.makeUnitCS()

    # Apply deviations from the now-ideal geometry:
    if &#34;deviation&#34; in geometry:
        # Positional deviations:
        if &#34;position&#34; in geometry[&#34;deviation&#34;]:
            if &#34;x&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;] != None:
                    translationX = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;])
                    self.translateX(translationX)

            if &#34;y&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;] != None:
                    translationY = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;])
                    self.translateY(translationY)

            if &#34;z&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;] != None:
                    translationZ = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;])
                    self.translateZ(translationZ)

        # Rotations according to w&#39;&#39;v&#39;u convention:
        if &#34;rotation&#34; in geometry[&#34;deviation&#34;]:
            if &#34;w&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;] != None:
                    angleAroundW = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;])
                    self.rotateAroundW(angleAroundW)

            if &#34;v&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;] != None:
                    angleAroundV = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;])
                    self.rotateAroundV(angleAroundV)

            if &#34;u&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;] != None:
                    angleAroundU = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;])
                    self.rotateAroundU(angleAroundU)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.makeUnitCS"><code class="name flex">
<span>def <span class="ident">makeUnitCS</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all basis vectors to unit vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeUnitCS(self):
    &#34;&#34;&#34;Convert all basis vectors to unit vectors.&#34;&#34;&#34;
    self.u.makeUnitVector()
    self.v.makeUnitVector()
    self.w.makeUnitVector()</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, axis: <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around a given axis by the given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>Vector</code></dt>
<dd>The axis of rotation, in terms of the object's
reference coordinate system (e.g. world).</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, axis: Vector, angle: float):
    &#34;&#34;&#34;Rotate object around a given axis by the given angle [rad].
    
    Parameters
    ----------
    axis : Vector
        The axis of rotation, in terms of the object&#39;s
        reference coordinate system (e.g. world).
    
    angle : float
        Rotation angle in rad, mathematically positive direction (right-hand rule).
    &#34;&#34;&#34;
    self.u.rotate(axis, angle)
    self.v.rotate(axis, angle)
    self.w.rotate(axis, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotateAroundU"><code class="name flex">
<span>def <span class="ident">rotateAroundU</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its u axis by given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotateAroundU(self, angle: float):
    &#34;&#34;&#34;Rotate object around its u axis by given angle [rad].
    
    Parameters
    ----------
    angle : float
        Rotation angle in rad, mathematically positive direction (right-hand rule).
    &#34;&#34;&#34;
    self.v.rotate(self.u, angle)
    self.w.rotate(self.u, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotateAroundV"><code class="name flex">
<span>def <span class="ident">rotateAroundV</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its v axis by given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotateAroundV(self, angle: float):
    &#34;&#34;&#34;Rotate object around its v axis by given angle [rad].
    
    Parameters
    ----------
    angle : float
        Rotation angle in rad, mathematically positive direction (right-hand rule).
    &#34;&#34;&#34;
    self.u.rotate(self.v, angle)
    self.w.rotate(self.v, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotateAroundW"><code class="name flex">
<span>def <span class="ident">rotateAroundW</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its w axis by given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotateAroundW(self, angle: float):
    &#34;&#34;&#34;Rotate object around its w axis by given angle [rad].
    
    Parameters
    ----------
    angle : float
        Rotation angle in rad, mathematically positive direction (right-hand rule).
    &#34;&#34;&#34;
    self.u.rotate(self.w, angle)
    self.v.rotate(self.w, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, center: <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, u: <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, v: <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, w: <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up center and orientation manually.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Object's center point in reference coordinate system,
origin of local {u,v,w} coordinate system.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector u in terms of reference coordinate system.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector v in terms of reference coordinate system.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector w in terms of reference coordinate system.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>All basis vectors must be orthogonal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, center:Vector, u:Vector, v:Vector, w:Vector):
    &#34;&#34;&#34;Set up center and orientation manually.

    Parameters
    ----------
    center : Vector
        Object&#39;s center point in reference coordinate system,
        origin of local {u,v,w} coordinate system.

    u : Vector
        Basis vector u in terms of reference coordinate system.

    v : Vector
        Basis vector v in terms of reference coordinate system.

    w : Vector
        Basis vector w in terms of reference coordinate system.

    Notes
    -----
    All basis vectors must be orthogonal.
    &#34;&#34;&#34;

    # Create new vectors from given components:
    self.center  = center
    self.u = u
    self.v = v
    self.w = w</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, translationVector: <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>translationVector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Vector by which the object's center point should be shifted.
Its components are added to the center's components.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, translationVector: Vector):
    &#34;&#34;&#34;Move object in space.

    Parameters
    ----------
    translationVector : Vector
        Vector by which the object&#39;s center point should be shifted.
        Its components are added to the center&#39;s components.
    &#34;&#34;&#34;
    self.center.add(translationVector)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translateX"><code class="name flex">
<span>def <span class="ident">translateX</span></span>(<span>self, dx: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in x direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in x direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateX(self, dx: float):
    &#34;&#34;&#34;Move object in x direction.

    Parameters
    ----------
    dx : float
        Shift amount in x direction.
    &#34;&#34;&#34;
    self.center.setx(self.center.x + float(dx))</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translateY"><code class="name flex">
<span>def <span class="ident">translateY</span></span>(<span>self, dy: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in y direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in y direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateY(self, dy: float):
    &#34;&#34;&#34;Move object in y direction.

    Parameters
    ----------
    dy : float
        Shift amount in y direction.
    &#34;&#34;&#34;
    self.center.sety(self.center.y + float(dy))</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translateZ"><code class="name flex">
<span>def <span class="ident">translateZ</span></span>(<span>self, dz: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in z direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in z direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateZ(self, dz: float):
    &#34;&#34;&#34;Move object in z direction.

    Parameters
    ----------
    dz : float
        Shift amount in z direction.
    &#34;&#34;&#34;
    self.center.setz(self.center.z + float(dz))</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal a manual update to the center position or orientation vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Signal a manual update to the center position or orientation vectors.&#34;&#34;&#34;
    self.center.update()
    self.u.update()
    self.v.update()
    self.w.update()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.geometry.Detector"><code class="flex name class">
<span>class <span class="ident">Detector</span></span>
</code></dt>
<dd>
<div class="desc"><p>Detector as geometrical object.</p>
<p>With additional attributes for the spatial extension and
the pixel coordinate system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pixelsU</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in u direction.</dd>
<dt><strong><code>pixelsV</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in v direction.</dd>
<dt><strong><code>pitchU</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of a pixel in u direction.
In units of the reference coordinate system.</dd>
<dt><strong><code>pitchV</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of a pixel in v direction.
In units of the reference coordinate system.</dd>
<dt><strong><code>physWidth</code></strong> :&ensp;<code>float</code></dt>
<dd>Physical size in u direction.
In units of the reference coordinate system.
Computed automatically after calling <code>setSize()</code>.</dd>
<dt><strong><code>physHeight</code></strong> :&ensp;<code>float</code></dt>
<dd>Physical size in v direction.
In units of the reference coordinate system.
Computed automatically after calling <code>setSize()</code>.</dd>
<dt><strong><code>pixelOrigin</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Origin of the pixel coordinate system in terms of the reference
coordinate system. This is the outermost corner of the
(0,0) pixel of the detector (often the "upper left" corner).
Computed automatically after calling <code>setSize()</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Use <code>setSize()</code> to set the size of the detector, given its number of pixels
and the pitch. This function automatically computes the physical dimensions
<code>physWidth</code> and <code>physHeight</code> and the origin of the pixel coordinate system.</p>
<p>Initialize as a standard CoordinateSystem.</p>
<p>Orientation, position and size must be set up manually afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Detector(CoordinateSystem):
    &#34;&#34;&#34;Detector as geometrical object.

    With additional attributes for the spatial extension and
    the pixel coordinate system.

    Attributes
    ----------
    pixelsU : int
        Number of pixels in u direction.
    
    pixelsV : int
        Number of pixels in v direction.
    
    pitchU : float
        Size of a pixel in u direction.
        In units of the reference coordinate system.
    
    pitchV : float
        Size of a pixel in v direction.
        In units of the reference coordinate system.
    
    physWidth : float
        Physical size in u direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
    
    physHeight : float
        Physical size in v direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
 
    pixelOrigin : Vector
        Origin of the pixel coordinate system in terms of the reference
        coordinate system. This is the outermost corner of the
        (0,0) pixel of the detector (often the &#34;upper left&#34; corner).
        Computed automatically after calling `setSize()`.

    Notes
    -----
    Use `setSize()` to set the size of the detector, given its number of pixels
    and the pitch. This function automatically computes the physical dimensions
    `physWidth` and `physHeight` and the origin of the pixel coordinate system.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard CoordinateSystem.

        Orientation, position and size must be set up manually afterwards.
        &#34;&#34;&#34;

        # Call init from parent class:
        CoordinateSystem.__init__(self)

        self.pixelsU     = None  # Detector pixels in u direction
        self.pixelsV     = None  # Detector pixels in v direction
        self.pitchU = None  # Size of a pixel in u direction in units of reference coordinate system
        self.pitchV = None  # Size of a pixel in v direction in units of reference coordinate system
        self.physWidth   = 0    # Physical width in units of reference coordinate system
        self.physHeight  = 0    # Physical height in units of reference coordinate system

        self.pixelOrigin = Vector()  # origin of pixel coordinate system in terms of reference coordinate system

    def sizeIsSet(self):
        if (self.pixelsU is None) or (self.pixelsV is None) or (self.pitchU is None) or (self.pitchV is None):
            return False

        return True

    def setSize(self, pixelsU:int = None, pixelsV:int = None, pitchU:float = None, pitchV:float = None):
        &#34;&#34;&#34;Set the physical size of the detector.

        From the given parameters (number of pixels and pitch), the physical
        size of the detector and the position of the origin of the pixel
        coordinate system will be calculated. Make sure that the orientation
        vectors and position of the detector are correct before calling
        `setSize()`, or call `computeGeometryParameters()` if you update
        the detector orientation or position later on.

        Parameters
        ----------
        pixelsU : int
            Number of pixels in u direction.

        pixelsV : int
            Number of pixels in v direction.

        pitchU : float
            Pixel pitch in u direction.

        pitchV : float
            Pixel pitch in v direction.
        &#34;&#34;&#34;

        self.pixelsU = int(pixelsU)
        self.pixelsV = int(pixelsV)
        self.pitchU = float(pitchU)
        self.pitchV = float(pitchV)

        self.computeGeometryParameters()

    def computeGeometryParameters(self):
        &#34;&#34;&#34;Calculate the physical width and height, and the position of the
        pixel coordinate system origin.

        These calculations assume that the size, position and
        orientation of the detector are correctly set up.

        Results are assigned to their member variables (attributes).
        &#34;&#34;&#34;

        if self.sizeIsSet():
            # Physical width and height:
            self.physWidth  = self.pixelsU * self.pitchU
            self.physHeight = self.pixelsV * self.pitchV

            # Vectors of the detector coordinate system:
            ux = self.u.unitVector().x
            uy = self.u.unitVector().y
            uz = self.u.unitVector().z
            vx = self.v.unitVector().x
            vy = self.v.unitVector().y
            vz = self.v.unitVector().z

            # World coordinates of origin (0,0) of detector&#39;s pixel coordinate system:
            self.pixelOrigin.x = self.center.x - 0.5*(ux*self.physWidth + vx*self.physHeight)
            self.pixelOrigin.y = self.center.y - 0.5*(uy*self.physWidth + vy*self.physHeight)
            self.pixelOrigin.z = self.center.z - 0.5*(uz*self.physWidth + vz*self.physHeight)

    def cols(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector columns (i.e., pixels in u direction).

        Returns
        -------
        pixelsU : int
            Number of detector columns (i.e., pixels in u direction).
        &#34;&#34;&#34;
        return self.pixelsU

    def rows(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector rows (i.e., pixels in v direction).

        Returns
        -------
        pixelsV : int
            Number of detector rows (i.e., pixels in v direction).
        &#34;&#34;&#34;
        return self.pixelsV

    def pixelVector(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector for given pixel coordinate.

        The pixel coordinate system has its origin at the detector corner with
        the lowest coordinate in terms of its u and v basis vectors. Typically,
        this is the upper left corner, but your arrangement may differ.

        Integer coordinates always refer to the pixel corner that is closest to
        the origin of the pixel coordinate system, whereas the center of a pixel
        therefore has a &#34;.5&#34; coordinate in the pixel coordinate system.
        For example, the first pixel (0, 0) would have center coordinates
        (0.5, 0.5).

        To get the center coordinates for a given integer pixel location,
        `pixelVectorCenter()` may be used.

        Parameters
        ----------
        x : float
            x position in pixel coordinate system.

        y : float
            y position in pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Pixel position in reference coordinate system (usually world)
            as a 3D vector.
        &#34;&#34;&#34;

        # x, y are coordinates in pixel coordinates system
        px = self.pixelOrigin.x + self.u.x*x*self.pitchU + self.v.x*y*self.pitchV
        py = self.pixelOrigin.y + self.u.y*x*self.pitchU + self.v.y*y*self.pitchV
        pz = self.pixelOrigin.z + self.u.z*x*self.pitchU + self.v.z*y*self.pitchV
        pixelVector = Vector(px, py, pz)
        return pixelVector

    def pixelVectorCenter(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector of pixel center, for a pixel given in integer coordinates.

        Parameters
        ----------
        x : float
            Integer x coordinate, specifies a pixel in the pixel coordinate system.

        y : float
            Integer y coordinate, specifies a pixel in the pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Position of the pixel center in the reference coordinate system
            (usually world) as a 3D vector.

        Notes
        -----
        If `float` coordinates are passed (non-integer),
        they are converted to integers using `math.floor`.
        &#34;&#34;&#34;
        return self.pixelVector(float(math.floor(x))+0.5, float(math.floor(y))+0.5)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.Detector.cols"><code class="name flex">
<span>def <span class="ident">cols</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of detector columns (i.e., pixels in u direction).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelsU</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of detector columns (i.e., pixels in u direction).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cols(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of detector columns (i.e., pixels in u direction).

    Returns
    -------
    pixelsU : int
        Number of detector columns (i.e., pixels in u direction).
    &#34;&#34;&#34;
    return self.pixelsU</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.computeGeometryParameters"><code class="name flex">
<span>def <span class="ident">computeGeometryParameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the physical width and height, and the position of the
pixel coordinate system origin.</p>
<p>These calculations assume that the size, position and
orientation of the detector are correctly set up.</p>
<p>Results are assigned to their member variables (attributes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeGeometryParameters(self):
    &#34;&#34;&#34;Calculate the physical width and height, and the position of the
    pixel coordinate system origin.

    These calculations assume that the size, position and
    orientation of the detector are correctly set up.

    Results are assigned to their member variables (attributes).
    &#34;&#34;&#34;

    if self.sizeIsSet():
        # Physical width and height:
        self.physWidth  = self.pixelsU * self.pitchU
        self.physHeight = self.pixelsV * self.pitchV

        # Vectors of the detector coordinate system:
        ux = self.u.unitVector().x
        uy = self.u.unitVector().y
        uz = self.u.unitVector().z
        vx = self.v.unitVector().x
        vy = self.v.unitVector().y
        vz = self.v.unitVector().z

        # World coordinates of origin (0,0) of detector&#39;s pixel coordinate system:
        self.pixelOrigin.x = self.center.x - 0.5*(ux*self.physWidth + vx*self.physHeight)
        self.pixelOrigin.y = self.center.y - 0.5*(uy*self.physWidth + vy*self.physHeight)
        self.pixelOrigin.z = self.center.z - 0.5*(uz*self.physWidth + vz*self.physHeight)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.pixelVector"><code class="name flex">
<span>def <span class="ident">pixelVector</span></span>(<span>self, x: float, y: float) ‑> <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>World position vector for given pixel coordinate.</p>
<p>The pixel coordinate system has its origin at the detector corner with
the lowest coordinate in terms of its u and v basis vectors. Typically,
this is the upper left corner, but your arrangement may differ.</p>
<p>Integer coordinates always refer to the pixel corner that is closest to
the origin of the pixel coordinate system, whereas the center of a pixel
therefore has a ".5" coordinate in the pixel coordinate system.
For example, the first pixel (0, 0) would have center coordinates
(0.5, 0.5).</p>
<p>To get the center coordinates for a given integer pixel location,
<code>pixelVectorCenter()</code> may be used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>x position in pixel coordinate system.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>y position in pixel coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelVector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Pixel position in reference coordinate system (usually world)
as a 3D vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixelVector(self, x: float, y: float) -&gt; Vector:
    &#34;&#34;&#34;World position vector for given pixel coordinate.

    The pixel coordinate system has its origin at the detector corner with
    the lowest coordinate in terms of its u and v basis vectors. Typically,
    this is the upper left corner, but your arrangement may differ.

    Integer coordinates always refer to the pixel corner that is closest to
    the origin of the pixel coordinate system, whereas the center of a pixel
    therefore has a &#34;.5&#34; coordinate in the pixel coordinate system.
    For example, the first pixel (0, 0) would have center coordinates
    (0.5, 0.5).

    To get the center coordinates for a given integer pixel location,
    `pixelVectorCenter()` may be used.

    Parameters
    ----------
    x : float
        x position in pixel coordinate system.

    y : float
        y position in pixel coordinate system.

    Returns
    -------
    pixelVector : Vector
        Pixel position in reference coordinate system (usually world)
        as a 3D vector.
    &#34;&#34;&#34;

    # x, y are coordinates in pixel coordinates system
    px = self.pixelOrigin.x + self.u.x*x*self.pitchU + self.v.x*y*self.pitchV
    py = self.pixelOrigin.y + self.u.y*x*self.pitchU + self.v.y*y*self.pitchV
    pz = self.pixelOrigin.z + self.u.z*x*self.pitchU + self.v.z*y*self.pitchV
    pixelVector = Vector(px, py, pz)
    return pixelVector</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.pixelVectorCenter"><code class="name flex">
<span>def <span class="ident">pixelVectorCenter</span></span>(<span>self, x: float, y: float) ‑> <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>World position vector of pixel center, for a pixel given in integer coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Integer x coordinate, specifies a pixel in the pixel coordinate system.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Integer y coordinate, specifies a pixel in the pixel coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelVector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Position of the pixel center in the reference coordinate system
(usually world) as a 3D vector.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If <code>float</code> coordinates are passed (non-integer),
they are converted to integers using <code>math.floor</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixelVectorCenter(self, x: float, y: float) -&gt; Vector:
    &#34;&#34;&#34;World position vector of pixel center, for a pixel given in integer coordinates.

    Parameters
    ----------
    x : float
        Integer x coordinate, specifies a pixel in the pixel coordinate system.

    y : float
        Integer y coordinate, specifies a pixel in the pixel coordinate system.

    Returns
    -------
    pixelVector : Vector
        Position of the pixel center in the reference coordinate system
        (usually world) as a 3D vector.

    Notes
    -----
    If `float` coordinates are passed (non-integer),
    they are converted to integers using `math.floor`.
    &#34;&#34;&#34;
    return self.pixelVector(float(math.floor(x))+0.5, float(math.floor(y))+0.5)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.rows"><code class="name flex">
<span>def <span class="ident">rows</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of detector rows (i.e., pixels in v direction).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelsV</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of detector rows (i.e., pixels in v direction).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rows(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of detector rows (i.e., pixels in v direction).

    Returns
    -------
    pixelsV : int
        Number of detector rows (i.e., pixels in v direction).
    &#34;&#34;&#34;
    return self.pixelsV</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.setSize"><code class="name flex">
<span>def <span class="ident">setSize</span></span>(<span>self, pixelsU: int = None, pixelsV: int = None, pitchU: float = None, pitchV: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the physical size of the detector.</p>
<p>From the given parameters (number of pixels and pitch), the physical
size of the detector and the position of the origin of the pixel
coordinate system will be calculated. Make sure that the orientation
vectors and position of the detector are correct before calling
<code>setSize()</code>, or call <code>computeGeometryParameters()</code> if you update
the detector orientation or position later on.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixelsU</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in u direction.</dd>
<dt><strong><code>pixelsV</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in v direction.</dd>
<dt><strong><code>pitchU</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel pitch in u direction.</dd>
<dt><strong><code>pitchV</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel pitch in v direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSize(self, pixelsU:int = None, pixelsV:int = None, pitchU:float = None, pitchV:float = None):
    &#34;&#34;&#34;Set the physical size of the detector.

    From the given parameters (number of pixels and pitch), the physical
    size of the detector and the position of the origin of the pixel
    coordinate system will be calculated. Make sure that the orientation
    vectors and position of the detector are correct before calling
    `setSize()`, or call `computeGeometryParameters()` if you update
    the detector orientation or position later on.

    Parameters
    ----------
    pixelsU : int
        Number of pixels in u direction.

    pixelsV : int
        Number of pixels in v direction.

    pitchU : float
        Pixel pitch in u direction.

    pitchV : float
        Pixel pitch in v direction.
    &#34;&#34;&#34;

    self.pixelsU = int(pixelsU)
    self.pixelsV = int(pixelsV)
    self.pitchU = float(pitchU)
    self.pitchV = float(pitchV)

    self.computeGeometryParameters()</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.sizeIsSet"><code class="name flex">
<span>def <span class="ident">sizeIsSet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sizeIsSet(self):
    if (self.pixelsU is None) or (self.pixelsV is None) or (self.pitchU is None) or (self.pitchV is None):
        return False

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></b></code>:
<ul class="hlist">
<li><code><a title="ctsimu.geometry.CoordinateSystem.changeReferenceFrame" href="#ctsimu.geometry.CoordinateSystem.changeReferenceFrame">changeReferenceFrame</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.json_import" href="#ctsimu.geometry.CoordinateSystem.json_import">json_import</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.makeUnitCS" href="#ctsimu.geometry.CoordinateSystem.makeUnitCS">makeUnitCS</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate" href="#ctsimu.geometry.CoordinateSystem.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotateAroundU" href="#ctsimu.geometry.CoordinateSystem.rotateAroundU">rotateAroundU</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotateAroundV" href="#ctsimu.geometry.CoordinateSystem.rotateAroundV">rotateAroundV</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotateAroundW" href="#ctsimu.geometry.CoordinateSystem.rotateAroundW">rotateAroundW</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.setup" href="#ctsimu.geometry.CoordinateSystem.setup">setup</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate" href="#ctsimu.geometry.CoordinateSystem.translate">translate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translateX" href="#ctsimu.geometry.CoordinateSystem.translateX">translateX</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translateY" href="#ctsimu.geometry.CoordinateSystem.translateY">translateY</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translateZ" href="#ctsimu.geometry.CoordinateSystem.translateZ">translateZ</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.update" href="#ctsimu.geometry.CoordinateSystem.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ctsimu.geometry.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
<span>(</span><span>jsonFile: str = None, jsonFileFromPkg: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bundles geometry information about the complete CT setup.</p>
<p>Keeps the source, stage and detector as a set and provides methods
to calculate geometry parameters and projection matrices.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>detector</code></strong> :&ensp;<code><a title="ctsimu.geometry.Detector" href="#ctsimu.geometry.Detector">Detector</a></code></dt>
<dd>The detector geometry.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The source geometry.</dd>
<dt><strong><code>stage</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The stage geometry.</dd>
<dt><strong><code>SDD</code></strong> :&ensp;<code>float</code></dt>
<dd>Shortest distance between source center and detector plane.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>SOD</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance between source center and stage center.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>ODD</code></strong> :&ensp;<code>float</code></dt>
<dd>Shortest distance between stage center and detector plane.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>brightestSpotWorld</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Location of the intensity maximum on the detector, in world coordinates.
Assuming an isotropically radiating source.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>brightestSpotDetector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Location of the intensity maximum on the detector, in terms of
detector coordinate system. Assuming an isotropically radiating source.
Calculated automatically by <code>update()</code>.</dd>
</dl>
<p>Initialize using the provided JSON geometry specification.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>jsonFile</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Location of a CTSimU scenario description file to
import the geometry.</dd>
<dt><strong><code>jsonFileFromPkg</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Load the geometry from a JSON file included in the package,
usually for internal purposes only.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry:
    &#34;&#34;&#34;Bundles geometry information about the complete CT setup.

    Keeps the source, stage and detector as a set and provides methods
    to calculate geometry parameters and projection matrices.
    
    Attributes
    ----------
    detector : Detector
        The detector geometry.

    source : CoordinateSystem
        The source geometry.

    stage : CoordinateSystem
        The stage geometry.

    SDD : float
        Shortest distance between source center and detector plane.
        Calculated automatically by `update()`.

    SOD : float
        Distance between source center and stage center.
        Calculated automatically by `update()`.

    ODD : float
        Shortest distance between stage center and detector plane.
        Calculated automatically by `update()`.

    brightestSpotWorld : Vector
        Location of the intensity maximum on the detector, in world coordinates.
        Assuming an isotropically radiating source.
        Calculated automatically by `update()`.

    brightestSpotDetector : Vector
        Location of the intensity maximum on the detector, in terms of
        detector coordinate system. Assuming an isotropically radiating source.
        Calculated automatically by `update()`.
    &#34;&#34;&#34;

    def __init__(self, jsonFile:str = None, jsonFileFromPkg:str = None):
        &#34;&#34;&#34;Initialize using the provided JSON geometry specification.

        Parameters
        ----------
        jsonFile : str, optional
            Location of a CTSimU scenario description file to
            import the geometry.

        jsonFileFromPkg : str, optional
            Load the geometry from a JSON file included in the package,
            usually for internal purposes only.

        &#34;&#34;&#34;
        self.detector    = Detector()
        self.source      = CoordinateSystem()
        self.stage       = CoordinateSystem()

        # Initialize source and detector to standard CTSimU orientation:
        self.detector.u = Vector(0, -1,  0)
        self.detector.v = Vector(0,  0, -1)
        self.detector.w = Vector(1,  0,  0)
        self.source.u   = Vector(0, -1,  0)
        self.source.v   = Vector(0,  0, -1)
        self.source.w   = Vector(1,  0,  0)

        self.SDD = None
        self.SOD = None
        self.ODD = None
        self.brightestSpotWorld = None
        self.brightestSpotDetector = None

        jsonText = None
        if jsonFileFromPkg is not None:  # from package
            jsonFile = jsonFileFromPkg
            jsonText = pkgutil.get_data(__name__, jsonFileFromPkg).decode()
        elif jsonFile is not None:  # from file
            if os.path.isfile(jsonFile):
                log(&#34;JSON File: {}&#34;.format(jsonFile))
                jsonFilePtr = open(jsonFile, &#34;r&#34;)
                jsonText = jsonFilePtr.read()
                jsonFilePtr.close()
            else:
                raise Exception(&#34;Can&#39;t find &#34; + jsonFile)
        else:
            return

        if(jsonText is not None):
            try:
                jsonDict = json.loads(jsonText)
            except:
                raise Exception(&#34;Error parsing JSON file: {}&#34;.format(jsonFile))

            # Detector size and pixel pitch:
            pixelsU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;columns&#34;, &#34;value&#34;)
            pixelsV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;rows&#34;, &#34;value&#34;)
            pitchU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;u&#34;, &#34;value&#34;)
            pitchV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;v&#34;, &#34;value&#34;)

            try:
                detectorGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;detector&#34;)
                if detectorGeometry != None:
                    self.detector.json_import(detectorGeometry)
                    self.detector.setSize(pixelsU, pixelsV, pitchU, pitchV)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;detector\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the detector geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                sourceGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;source&#34;)
                if sourceGeometry != None:
                    self.source.json_import(sourceGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;source\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the source geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                stageGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;stage&#34;)
                if stageGeometry != None:
                    self.stage.json_import(stageGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;stage\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the stage geometry using the JSON file description.&#34;)
                raise Exception(e)

            self.update()            
        else:
            raise Exception(&#34;JSON scenario file not available.&#34;)

    def __str__(self):
        return self.info()
        
    def update(self):
        &#34;&#34;&#34;Calculate derived geometry parameters.

        Calculates the SOD, SDD, ODD, and location of the intensity maximum
        on the detector (in world and detector coordinates) for the
        curent geometry. Results are stored in the following member variables
        (attributes).

        SDD: Shortest distance between source center and detector plane.

        SOD: Distance between source center and stage center.

        ODD: Shortest distance between stage center and detector plane.

        brightestSpotWorld: Location of the intensity maximum on the detector,
            in world coordinates.  Assuming an isotropically radiating source.

        brightestSpotDetector: Location of the intensity maximum on the
            detector, in terms of detector coordinate system.
            Assuming an isotropically radiating source.
        &#34;&#34;&#34;

        self.source.update()
        self.stage.update()
        self.detector.update()

        # SOD, SDD, ODD
        world = CoordinateSystem()
        source_from_image = copy.deepcopy(self.source)
        stage_from_detector  = copy.deepcopy(self.stage)

        source_from_image.changeReferenceFrame(world, self.detector)
        stage_from_detector.changeReferenceFrame(world, self.detector)

        self.SDD = abs(source_from_image.center.z)
        self.ODD = abs(stage_from_detector.center.z)
        self.SOD = self.source.center.distance(self.stage.center)

        ## Brightest Spot in World Coordinate System:
        self.brightestSpotWorld = copy.deepcopy(self.detector.w)
        self.brightestSpotWorld.scale(self.SDD)
        self.brightestSpotWorld.add(self.source.center)

        ## Brightest Spot in Detector Coordinate System:
        self.brightestSpotDetector = copy.deepcopy(self.brightestSpotWorld)
        self.brightestSpotDetector.subtract(self.detector.center)
        
        pxU = self.brightestSpotDetector.dot(self.detector.u) / self.detector.pitchU + self.detector.cols()/2.0
        pxV = self.brightestSpotDetector.dot(self.detector.v) / self.detector.pitchV + self.detector.rows()/2.0

        self.brightestSpotDetector = Vector(pxU, pxV, 0)

        self.detector.computeGeometryParameters()


    def info(self) -&gt; str:
        &#34;&#34;&#34;Generate an information string about the current geometry.
    
        Returns
        -------
        txt : string
            Information string for humans.
        &#34;&#34;&#34;

        self.update()

        txt  = &#34;Detector\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.detector.center)
        txt += &#34;u:               {}\n&#34;.format(self.detector.u)
        txt += &#34;v:               {}\n&#34;.format(self.detector.v)
        txt += &#34;w:               {}\n&#34;.format(self.detector.w)
        txt += &#34;Pixels:          {cols} x {rows}\n&#34;.format(cols=self.detector.cols(), rows=self.detector.rows())
        txt += &#34;Pitch:           {pitchU} x {pitchV}\n&#34;.format(pitchU=self.detector.pitchU, pitchV=self.detector.pitchV)
        txt += &#34;Physical Size:   {width} x {height}\n&#34;.format(width=self.detector.physWidth, height=self.detector.physHeight)

        txt += &#34;Brightest Spot:\n&#34;
        txt += &#34;  World:         {}\n&#34;.format(self.brightestSpotWorld)
        txt += &#34;  Pixels:        {}\n&#34;.format(self.brightestSpotDetector)

        txt += &#34;\n&#34;
        txt += &#34;Source:\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.source.center)
        txt += &#34;u:               {}\n&#34;.format(self.source.u)
        txt += &#34;v:               {}\n&#34;.format(self.source.v)
        txt += &#34;w:               {}\n&#34;.format(self.source.w)

        txt += &#34;\n&#34;
        txt += &#34;Stage:\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.stage.center)
        txt += &#34;u:               {}\n&#34;.format(self.stage.u)
        txt += &#34;v:               {}\n&#34;.format(self.stage.v)
        txt += &#34;w:               {}\n&#34;.format(self.stage.w)

        txt += &#34;\n&#34;
        txt += &#34;Geometry Parameters:\n&#34;
        txt += &#34;===========================================================\n&#34;
        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        txt += &#34;SDD:             {}\n&#34;.format(self.SDD)
        txt += &#34;ODD:             {}\n&#34;.format(self.ODD)
        txt += &#34;SOD:             {}\n&#34;.format(self.SOD)

        return txt

    def projectionMatrix(self,
                         volumeCS:CoordinateSystem=None,
                         imageCS:CoordinateSystem=None,
                         mode:str=None,
                         mirror:bool=True):
        &#34;&#34;&#34;Calculate a projection matrix for the current geometry.

        Parameters
        ----------
        volumeCS : CoordinateSystem, optional
            Position of the volume coordinate system in terms of the
            stage coordinate system. If `None` is given, the volume
            coordinate system is assumed to be the stage coordinate system.
            See notes for details.

        imageCS : CoordinateSystem, optional
            Position of the image coordinate system in terms of the
            detector coordinate system. If `None` is given, the image
            coordinate system is assumed to be the detector coordinate system.
            See notes for details.

        mode : str, optional
            Pre-defined modes. Either &#34;openCT&#34; or &#34;CERA&#34; are supported.
            They override the `volumeCS` and `imageCS`, which can be set
            to `None` when using one of the pre-defined modes.

        mirror : bool, optional
            Whether or not a mirror operation should be applied to the
            reconstruction volume. For many 3D processing softwares,
            this parameter should be set to `True` to avoid having to
            mirror the volume after loading it into the software.

        Returns
        -------
        P : Matrix
            Projection matrix.

        Notes
        -----
        The image coordinate system (`imageCS`) should match the notation
        used by the reconstruction software, and is expressed in terms of
        the detector coordinate system.

        The detector coordinate system has its origin at the detector center,
        the u unit vector points in the row vector direction, and the
        v unit vector points in column vector direction (they are always assumed
        to be unit vectors).

        The center (origin) of the `imageCS` should be where the reconstruction
        software places the origin of its own projection image coordinate
        system. For example, CERA places it at the center of the lower-left pixel
        of the projection image.
        &#34;&#34;&#34;

        validModes = [&#34;openCT&#34;, &#34;CERA&#34;]

        if mode is not None:
            if mode in validModes:  # Override imageCS
                image = CoordinateSystem()

                if mode == &#34;openCT&#34;:
                    &#34;&#34;&#34;openCT places the origin of the image CS at the detector 
                    center. The constructor places it at (0,0,0) automatically,
                    so there is nothing to do. Comments for illustration.&#34;&#34;&#34;
                    # image.center.x = 0
                    # image.center.y = 0
                    # image.center.z = 0

                    &#34;&#34;&#34;openCT&#39;s image CS is in mm units. We assume that all
                    other coordinate systems are in mm as well here (at least
                    when imported from JSON file). No scaling of the basis vectors is necessary.&#34;&#34;&#34;
                    # image.u.scale(1.0)
                    # image.v.scale(1.0)
                    # image.w.scale(1.0)

                elif mode == &#34;CERA&#34;:
                    if self.detector.sizeIsSet():
                        &#34;&#34;&#34;CERA places the origin of the image CS in the center
                        of the lower left pixel of the projection image.&#34;&#34;&#34;
                        image.center.x = -self.detector.physWidth  / 2.0 + 0.5*self.detector.pitchU
                        image.center.y =  self.detector.physHeight / 2.0 - 0.5*self.detector.pitchV
                        # image.center.z = 0

                        &#34;&#34;&#34;CERA&#39;s unit of the image CS is in px, so we need to
                        scale the image CS basis vectors by the pixel size.
                        Also, v points up instead of down.&#34;&#34;&#34;
                        image.u.scale( self.detector.pitchU)
                        image.v.scale(-self.detector.pitchV)
                        image.w.scale(-1.0)
                    else:
                        raise RuntimeError(&#34;Detector size not set. To calculate a projection matrix for CERA, you need to set the size of the detector. Use the setSize() function of your detector object.&#34;)
            else:
                raise RuntimeError(&#34;Unsupported mode for projection matrix: \&#34;{}\&#34;&#34;.format(mode))
        elif imageCS is not None:
            image = copy.deepcopy(imageCS)
        else:
             # Set a standard coordinate system. Results in pure
             # detector coordinate system after transformation.
            image = CoordinateSystem()

        world    = CoordinateSystem()
        source   = copy.deepcopy(self.source)

        # The 3D volume (reconstruction space).
        volume = None
        if volumeCS is not None:
            volume = copy.deepcopy(volumeCS)
            volume.changeReferenceFrame(self.stage, world)
        else:
            volume = copy.deepcopy(self.stage)

        &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
        vectors of the volume CS .&#34;&#34;&#34;
        scale_volume_u = volume.u.length()
        scale_volume_v = volume.v.length()
        scale_volume_w = volume.w.length()

        # Detach the image CS from the detector CS and
        # express it in terms of the world CS:
        image.changeReferenceFrame(self.detector, world)

        &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
        vectors of the image CS.&#34;&#34;&#34;
        scale_image_u = image.u.length()
        scale_image_v = image.v.length()
        scale_image_w = image.w.length()

        # Save a source CS as seen from the detector CS. This is convenient to
        # later get the SDD, ufoc and vfoc:
        source_from_image = copy.deepcopy(self.source)
        source_from_image.changeReferenceFrame(world, image)

        # Make the volume CS the new world CS:
        source.changeReferenceFrame(world, volume)
        image.changeReferenceFrame(world, volume)
        volume.changeReferenceFrame(world, volume)

        # Translation vector from volume to source:
        rfoc = source.center - volume.center
        xfoc = rfoc.x
        yfoc = rfoc.y
        zfoc = rfoc.z
        SOD = rfoc.length()

        # Focus point on detector: principal, perpendicular ray.
        # In the detector coordinate system, ufoc and vfoc are the u and v coordinates
        # of the source center; SDD (perpendicular to detector plane) is source w coordinate.
        ufoc = source_from_image.center.x / scale_image_u
        vfoc = source_from_image.center.y / scale_image_v
        wfoc = source_from_image.center.z / scale_image_w
        SDD  = abs(source_from_image.center.z)

        # Mirror volume:
        if mirror:
            M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])
        else:
            M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0,  1, 0], [0, 0, 0, 1]])

        # Scale: volume units -&gt; world units
        A = Matrix(values=[[scale_volume_u, 0, 0, 0], [0, scale_volume_v, 0, 0], [0, 0, scale_volume_w, 0], [0, 0, 0, 1]])

        # Move origin to source (the origin of the camera CS)
        F = Matrix(values=[[1, 0, 0, -xfoc], [0, 1, 0, -yfoc], [0, 0, 1, -zfoc]])

        # Rotations:
        R = basisTransformMatrix(volume, image)

        # Projection onto detector and scaling (world units -&gt; volume units):
        S = Matrix(values=[[SDD/scale_image_u, 0, 0], [0, SDD/scale_image_v, 0], [0, 0, 1.0/scale_image_w]])

        # Shift in detector CS: (ufoc and vfoc must be in scaled units)
        T = Matrix(values=[[1, 0, ufoc], [0, 1, vfoc], [0, 0, 1]])

        # Multiply all together:
        P = T * (S * (R * (F * (A*M))))

        # Renormalize:
        lower_right = P.get(col=3, row=2)
        if lower_right != 0:
            P.scale(1.0/lower_right)

        return P

    def createDetectorFlatField_rays(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction. &#34;&#34;&#34;
        width      = self.detector.cols()
        height     = self.detector.rows()
        pixelSizeU = self.detector.pitchU
        pixelSizeV = self.detector.pitchV

        if(width is None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height is None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeU is None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeV is None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        log(&#34;Geometry definition from JSON file:\n\
   Detector Angle:    {}\n\
   Detector Distance: {}\n\
   SDD:               {}\n\
   Pixels U:          {}\n\
   Pixels V:          {}\n\
   Pitch U:           {}\n\
   Pitch V:           {}\n\
   Source:            {}, {}, {}\n\
   Detector:          {}, {}, {}\n\
   Connection Vector: {}, {}, {}\n\
   Detector Vector U: {}, {}, {}\n\
   Detector Vector V: {}, {}, {}\n\
   Detector Vector W: {}, {}, {}&#34;.format(alpha, dist, SDD, width, height, pixelSizeU, pixelSizeV, sx, sy, sz, dx, dy, dz, connectionLine.x, connectionLine.y, connectionLine.z, ux, uy, uz, vx, vy, vz, wx, wy, wz))

        maxIntensity = 0
        maxX = 0
        maxY = 0
        minDistToSource = 0
        brightestIncidenceAngle = 0

        gridSize = 3
        gridSizeSq = gridSize*gridSize

        for x in range(width):
            for y in range(height):
                factorSum = 0
                for gx in range(gridSize):
                    for gy in range(gridSize):
                        # Calculate coordinates of pixel center in mm:
                        # Grid with margin:
                        stepSize = 1.0 / (gridSize+1)
                        pixel = self.detector.pixelVector(x+(gx+1)*stepSize, y+(gy+1)*stepSize)

                        # Grid with no margin:
                        #if gridSize &gt; 1:
                        #    stepSize = 1.0 / (gridSize-1)
                        #    pixel = self.detector.pixelVector(x+gx*stepSize, y+gy*stepSize)
                        #else:
                        #    pixel = self.detector.pixelVectorCenter(x, y)

                        distToSource = self.source.center.distance(pixel)

                        # Angle of incident rays:
                        vecSourceToPixel = Vector(pixel.x-sx, pixel.y-sy, pixel.z-sz)
                        incidenceAngle = abs(self.detector.w.angle(vecSourceToPixel))
                        if incidenceAngle &gt; (math.pi/2):
                            incidenceAngle = math.pi - incidenceAngle

                        intensityFactor = math.cos(incidenceAngle)*math.pow(SDD/distToSource, 2)
                        factorSum += intensityFactor

                intensityWeight = factorSum / gridSizeSq

                if intensityWeight &gt; maxIntensity:
                    maxIntensity = intensityWeight
                    maxX = x
                    maxY = y
                    minDistToSource = distToSource
                    brightestIncidenceAngle = incidenceAngle

                flatField.setPixel(x, y, intensityWeight)

            progress = 100*(float(x+1)/float(width))
            print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        return flatField

    def pixelAreaOnUnitSphere(self, A, B, C, D):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C, D must be vectors pointing to pixel corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()
        
        ACin  = A.cross(C)
        DAin  = D.cross(A)
        CDin  = C.cross(D)
        ACout = ACin.inverse()
        DAout = DAin.inverse()
        CDout = CDin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        # areaABC = alpha + beta + gamma - math.pi

        # Spherical Triangle ACD:
        rho   = ACin.angle(DAout)
        sigma = CDin.angle(ACout)
        tau   = DAin.angle(CDout)

        # areaACD = rho + tau + sigma - math.pi

        pxSphericalArea = (alpha + beta + gamma + rho + sigma + tau) - 2*math.pi

        return pxSphericalArea

    def triangleAreaOnUnitSphere(self, A, B, C):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to ´triangle corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        areaABC = alpha + beta + gamma - math.pi

        return areaABC

    def polygonAreaOnUnitSphere(self, polygon):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        if len(polygon.points) &gt;= 3:
            # Start at first point
            p1 = polygon.points[0]

            area = 0

            for i in range(1, len(polygon.points)-1):
                p2 = polygon.points[i]
                p3 = polygon.points[i+1]

                area += self.triangleAreaOnUnitSphere(p1, p2, p3)

            return area
        else:
            return 0

    &#34;&#34;&#34;
    def createDetectorFlatField_sphere_old(self, clippingPolygon=None):
        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = dist * math.cos(alpha)

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)

        print(&#34;SDD: {}&#34;.format(SDD))
        print(&#34;Pitch: {}, {}&#34;.format(hpu, hpv))
        #print(&#34;Brightest Pixel Area: {}&#34;.format(areaOfBrightestPixel))

        flatField = Image()
        flatField.shape(det.cols(), det.rows(), 0, flatField.getInternalDataType())

        maxArea = 0
        maxX = 0
        maxY = 0
        maxCenter = 0
        # Go through pixels:
        for x in range(det.cols()):
            for y in range(det.rows()):
                # Define Pixel corners:
                A = det.pixelVector(x,   y)
                B = det.pixelVector(x+1, y)
                C = det.pixelVector(x+1, y+1)
                D = det.pixelVector(x,   y+1)

                pxSphericalArea = self.pixelAreaOnUnitSphere(A, B, C, D)
                flatField.setPixel(x, y, pxSphericalArea)

                if pxSphericalArea &gt; maxArea:
                    maxArea = pxSphericalArea
                    maxX = x
                    maxY = y

            progress = 100*(float(x+1)/float(det.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)


        maxCenter = det.pixelVectorCenter(maxX, maxY)
        distToSource = maxCenter.length()
        incidenceAngle = abs(self.detector.w.angle(maxCenter))

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Vector: {}, {}, {}&#34;.format(maxCenter.x, maxCenter.y, maxCenter.z))
        print(&#34;  Distance to Source: {}&#34;.format(distToSource))
        print(&#34;  Spherical Area: {}&#34;.format(maxArea))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(incidenceAngle, 180*incidenceAngle/math.pi))

        return flatField
    &#34;&#34;&#34;

    def createDetectorFlatField_sphere(self, *coverPolygons):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Geometrical approach using spherical geometry. &#34;&#34;&#34;

        # Change to the detector coordinate system:
        D = copy.deepcopy(self.detector)
        S = copy.deepcopy(self.source)
        world = CoordinateSystem()  # will be initialized as world

        S.changeReferenceFrame(world, D)
        D.changeReferenceFrame(world, D)
        D.computeGeometryParameters()

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = abs(S.center.z)

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        pu = D.pitchU
        pv = D.pitchV
        nRows = D.rows()
        nCols = D.cols()

        hpu = 0.5*pu
        hpv = 0.5*pv
        pA = Vector(SDD,  hpu,  hpv)
        pB = Vector(SDD, -hpu,  hpv)
        pC = Vector(SDD, -hpu, -hpv)
        pD = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(pA, pB, pC, pD)

        # Full flat field image (without any clipping bodies):
        flatField = Image()
        flatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # A second image with a clipping body under consideration: (both will be returned)
        clippedFlatField = None
        if len(coverPolygons) &gt; 0:
            clippedFlatField = Image()
            clippedFlatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # Upper left detector corner in world coordinates (remember: world is now the detector CS)
        p00 = D.pixelVector(0, 0)

        stepRight      = Vector(pu, 0,  0)
        stepDown       = Vector(0,  pv, 0)
        stepRightDown  = Vector(pu, pv, 0)

        # Move the clipping polygon to a coordinate system
        # where source is centered:
        for coverPolygon in coverPolygons:
            for p in range(len(coverPolygon.points)):
                coverPolygon.points[p] = coverPolygon.points[p] - S.center

        # Go through pixels:
        for x in range(nCols):
            for y in range(nRows):
                # Pixel in world coordinates (remember: world is now the detector CS)
                shift = Vector(x*pu, y*pv, 0)

                # Define Pixel corners:
                pA = p00 + shift
                pB = pA  + stepRight
                pC = pA  + stepRightDown
                pD = pA  + stepDown

                # Center source at (0, 0, 0):
                pA = pA - S.center
                pB = pB - S.center
                pC = pC - S.center
                pD = pD - S.center

                pixelPolygon = Polygon(pA, pB, pC, pD)
                pxSphericalArea  = self.polygonAreaOnUnitSphere(pixelPolygon)

                flatField.setPixel(x, y, pxSphericalArea)

                if len(coverPolygons) &gt; 0:
                    for coverPolygon in coverPolygons:
                        pixelPolygon = pixelPolygon.clip(coverPolygon)
                        
                    # Remove the intensity covered by the clipping polygon:
                    pixelPolygon.make3D(zComponent=SDD)
                    subarea = self.polygonAreaOnUnitSphere(pixelPolygon)
                    pxSphericalArea -= subarea

                    clippedFlatField.setPixel(x, y, pxSphericalArea)

            progress = 100*(float(x+1)/float(D.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)
        if clippedFlatField != None:
            clippedFlatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)

        return flatField, clippedFlatField

    def solidAngle(self, l, m):
        &#34;&#34;&#34; Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth. &#34;&#34;&#34;
        if l != 0:
            return (l/abs(l)) * math.atan(abs(l)*m/math.sqrt(1.0+l**2+m**2))
        else:
            return 0

    def createDetectorFlatField_analytical(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Analytical approach by Florian Wohlgemuth. &#34;&#34;&#34;

        width  = self.detector.cols()
        height = self.detector.rows()
        pitchU = self.detector.pitchU
        pitchV = self.detector.pitchV

        if(width is None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height is None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchU is None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchV is None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        maxIntensity = 0
        maxX = 0
        maxY = 0

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        upperLeft_u = det.pixelVector(0, 0).dot(self.detector.u)
        upperLeft_v = det.pixelVector(0, 0).dot(self.detector.v)
        upperLeft_w = det.pixelVector(0, 0).dot(self.detector.w)

        if upperLeft_w != 0:   # check if detector is not facing its edge towards the source
            for x in range(width):
                for y in range(height):
                    nu = x
                    nv = y
                    lambda0 = (upperLeft_u + nu*pitchU) / upperLeft_w
                    lambda1 = (upperLeft_u + (nu+1)*pitchU) / upperLeft_w
                    mu0     = (upperLeft_v + nv*pitchV) / upperLeft_w
                    mu1     = (upperLeft_v + (nv+1)*pitchV) / upperLeft_w

                    omega = self.solidAngle(lambda0, mu0) + self.solidAngle(lambda1, mu1) - self.solidAngle(lambda0, mu1) - self.solidAngle(lambda1, mu0)

                    if omega &gt; maxIntensity:
                        maxIntensity = omega
                        maxX = x
                        maxY = y

                    flatField.setPixel(x, y, omega)

                progress = 100*(float(x+1)/float(width))
                print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        # print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        # print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        # Method #1: find hypothetical brightest pixel
        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale actual maximum to 1.
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, dataType=&#34;float32&#34;)
        return flatField


    def createDetectorFlatField(self):
        return createDetectorFlatField_analytical()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createDetectorFlatField(self):
    return createDetectorFlatField_analytical()</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField_analytical"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField_analytical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p>
<p>Analytical approach by Florian Wohlgemuth.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createDetectorFlatField_analytical(self):
    &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
        picture for the given detector, to be used for an
        ideal flat field correction.

        Analytical approach by Florian Wohlgemuth. &#34;&#34;&#34;

    width  = self.detector.cols()
    height = self.detector.rows()
    pitchU = self.detector.pitchU
    pitchV = self.detector.pitchV

    if(width is None):
        raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
    if(height is None):
        raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
    if(pitchU is None):
        raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
    if(pitchV is None):
        raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

    flatField = Image()
    flatField.shape(width, height, 0, flatField.getInternalDataType())

    # Positions of detector and source center:
    dx = self.detector.center.x
    dy = self.detector.center.y
    dz = self.detector.center.z

    sx = self.source.center.x
    sy = self.source.center.y
    sz = self.source.center.z

    # Vectors of the detector coordinate system:
    ux = self.detector.u.x
    uy = self.detector.u.y
    uz = self.detector.u.z

    vx = self.detector.v.x
    vy = self.detector.v.y
    vz = self.detector.v.z

    wx = self.detector.w.x
    wy = self.detector.w.y
    wz = self.detector.w.z


    # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
    connectionLine = Vector(dx-sx, dy-sy, dz-sz)

    alpha = abs(self.detector.w.angle(connectionLine))
    if alpha &gt; (math.pi/2):
        alpha = math.pi - alpha

    # Distance between source center and detector center:
    dist = self.detector.center.distance(self.source.center)

    # Source - Detector distance (SDD) defined by shortest distance between source and detector:
    SDD = dist * math.cos(alpha)

    maxIntensity = 0
    maxX = 0
    maxY = 0

    # Create a new detector in a coordinate system where source is at (0, 0, 0):
    det = copy.deepcopy(self.detector)
    translationVector = Vector(-sx, -sy, -sz)
    det.translate(translationVector)
    det.computeGeometryParameters()

    upperLeft_u = det.pixelVector(0, 0).dot(self.detector.u)
    upperLeft_v = det.pixelVector(0, 0).dot(self.detector.v)
    upperLeft_w = det.pixelVector(0, 0).dot(self.detector.w)

    if upperLeft_w != 0:   # check if detector is not facing its edge towards the source
        for x in range(width):
            for y in range(height):
                nu = x
                nv = y
                lambda0 = (upperLeft_u + nu*pitchU) / upperLeft_w
                lambda1 = (upperLeft_u + (nu+1)*pitchU) / upperLeft_w
                mu0     = (upperLeft_v + nv*pitchV) / upperLeft_w
                mu1     = (upperLeft_v + (nv+1)*pitchV) / upperLeft_w

                omega = self.solidAngle(lambda0, mu0) + self.solidAngle(lambda1, mu1) - self.solidAngle(lambda0, mu1) - self.solidAngle(lambda1, mu0)

                if omega &gt; maxIntensity:
                    maxIntensity = omega
                    maxX = x
                    maxY = y

                flatField.setPixel(x, y, omega)

            progress = 100*(float(x+1)/float(width))
            print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

    print(&#34;\rCalculating analytical flat field... 100%  &#34;)

    #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
    # print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
    # print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

    # Method #1: find hypothetical brightest pixel
    # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
    hpu = 0.5*det.pitchU
    hpv = 0.5*det.pitchV
    A = Vector(SDD,  hpu,  hpv)
    B = Vector(SDD, -hpu,  hpv)
    C = Vector(SDD, -hpu, -hpv)
    D = Vector(SDD,  hpu, -hpv)
    areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)
    flatField.divide(areaOfBrightestPixel)

    # Method #2: rescale actual maximum to 1.
    #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

    #flatField.save(&#34;ff.tif&#34;, dataType=&#34;float32&#34;)
    return flatField</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField_rays"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField_rays</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"> def createDetectorFlatField_rays(self):
     &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
         picture for the given detector, to be used for an
         ideal flat field correction. &#34;&#34;&#34;
     width      = self.detector.cols()
     height     = self.detector.rows()
     pixelSizeU = self.detector.pitchU
     pixelSizeV = self.detector.pitchV

     if(width is None):
         raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
     if(height is None):
         raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
     if(pixelSizeU is None):
         raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
     if(pixelSizeV is None):
         raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

     flatField = Image()
     flatField.shape(width, height, 0, flatField.getInternalDataType())

     # Positions of detector and source center:
     dx = self.detector.center.x
     dy = self.detector.center.y
     dz = self.detector.center.z

     sx = self.source.center.x
     sy = self.source.center.y
     sz = self.source.center.z

     # Vectors of the detector coordinate system:
     ux = self.detector.u.x
     uy = self.detector.u.y
     uz = self.detector.u.z

     vx = self.detector.v.x
     vy = self.detector.v.y
     vz = self.detector.v.z

     wx = self.detector.w.x
     wy = self.detector.w.y
     wz = self.detector.w.z


     # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
     connectionLine = Vector(dx-sx, dy-sy, dz-sz)

     alpha = abs(self.detector.w.angle(connectionLine))
     if alpha &gt; (math.pi/2):
         alpha = math.pi - alpha

     # Distance between source center and detector center:
     dist = self.detector.center.distance(self.source.center)

     # Source - Detector distance (SDD) defined by shortest distance between source and detector:
     SDD = dist * math.cos(alpha)

     log(&#34;Geometry definition from JSON file:\n\
Detector Angle:    {}\n\
Detector Distance: {}\n\
SDD:               {}\n\
Pixels U:          {}\n\
Pixels V:          {}\n\
Pitch U:           {}\n\
Pitch V:           {}\n\
Source:            {}, {}, {}\n\
Detector:          {}, {}, {}\n\
Connection Vector: {}, {}, {}\n\
Detector Vector U: {}, {}, {}\n\
Detector Vector V: {}, {}, {}\n\
Detector Vector W: {}, {}, {}&#34;.format(alpha, dist, SDD, width, height, pixelSizeU, pixelSizeV, sx, sy, sz, dx, dy, dz, connectionLine.x, connectionLine.y, connectionLine.z, ux, uy, uz, vx, vy, vz, wx, wy, wz))

     maxIntensity = 0
     maxX = 0
     maxY = 0
     minDistToSource = 0
     brightestIncidenceAngle = 0

     gridSize = 3
     gridSizeSq = gridSize*gridSize

     for x in range(width):
         for y in range(height):
             factorSum = 0
             for gx in range(gridSize):
                 for gy in range(gridSize):
                     # Calculate coordinates of pixel center in mm:
                     # Grid with margin:
                     stepSize = 1.0 / (gridSize+1)
                     pixel = self.detector.pixelVector(x+(gx+1)*stepSize, y+(gy+1)*stepSize)

                     # Grid with no margin:
                     #if gridSize &gt; 1:
                     #    stepSize = 1.0 / (gridSize-1)
                     #    pixel = self.detector.pixelVector(x+gx*stepSize, y+gy*stepSize)
                     #else:
                     #    pixel = self.detector.pixelVectorCenter(x, y)

                     distToSource = self.source.center.distance(pixel)

                     # Angle of incident rays:
                     vecSourceToPixel = Vector(pixel.x-sx, pixel.y-sy, pixel.z-sz)
                     incidenceAngle = abs(self.detector.w.angle(vecSourceToPixel))
                     if incidenceAngle &gt; (math.pi/2):
                         incidenceAngle = math.pi - incidenceAngle

                     intensityFactor = math.cos(incidenceAngle)*math.pow(SDD/distToSource, 2)
                     factorSum += intensityFactor

             intensityWeight = factorSum / gridSizeSq

             if intensityWeight &gt; maxIntensity:
                 maxIntensity = intensityWeight
                 maxX = x
                 maxY = y
                 minDistToSource = distToSource
                 brightestIncidenceAngle = incidenceAngle

             flatField.setPixel(x, y, intensityWeight)

         progress = 100*(float(x+1)/float(width))
         print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

     print(&#34;\rCalculating analytical flat field... 100%  &#34;)

     #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
     print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
     print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

     return flatField</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField_sphere"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField_sphere</span></span>(<span>self, *coverPolygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p>
<p>Geometrical approach using spherical geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createDetectorFlatField_sphere(self, *coverPolygons):
    &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
        picture for the given detector, to be used for an
        ideal flat field correction.

        Geometrical approach using spherical geometry. &#34;&#34;&#34;

    # Change to the detector coordinate system:
    D = copy.deepcopy(self.detector)
    S = copy.deepcopy(self.source)
    world = CoordinateSystem()  # will be initialized as world

    S.changeReferenceFrame(world, D)
    D.changeReferenceFrame(world, D)
    D.computeGeometryParameters()

    # Source - Detector distance (SDD) defined by shortest distance between source and detector,
    # or distance between source and spot of highest intensity on detector.
    SDD = abs(S.center.z)

    # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
    pu = D.pitchU
    pv = D.pitchV
    nRows = D.rows()
    nCols = D.cols()

    hpu = 0.5*pu
    hpv = 0.5*pv
    pA = Vector(SDD,  hpu,  hpv)
    pB = Vector(SDD, -hpu,  hpv)
    pC = Vector(SDD, -hpu, -hpv)
    pD = Vector(SDD,  hpu, -hpv)
    areaOfBrightestPixel = self.pixelAreaOnUnitSphere(pA, pB, pC, pD)

    # Full flat field image (without any clipping bodies):
    flatField = Image()
    flatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

    # A second image with a clipping body under consideration: (both will be returned)
    clippedFlatField = None
    if len(coverPolygons) &gt; 0:
        clippedFlatField = Image()
        clippedFlatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

    # Upper left detector corner in world coordinates (remember: world is now the detector CS)
    p00 = D.pixelVector(0, 0)

    stepRight      = Vector(pu, 0,  0)
    stepDown       = Vector(0,  pv, 0)
    stepRightDown  = Vector(pu, pv, 0)

    # Move the clipping polygon to a coordinate system
    # where source is centered:
    for coverPolygon in coverPolygons:
        for p in range(len(coverPolygon.points)):
            coverPolygon.points[p] = coverPolygon.points[p] - S.center

    # Go through pixels:
    for x in range(nCols):
        for y in range(nRows):
            # Pixel in world coordinates (remember: world is now the detector CS)
            shift = Vector(x*pu, y*pv, 0)

            # Define Pixel corners:
            pA = p00 + shift
            pB = pA  + stepRight
            pC = pA  + stepRightDown
            pD = pA  + stepDown

            # Center source at (0, 0, 0):
            pA = pA - S.center
            pB = pB - S.center
            pC = pC - S.center
            pD = pD - S.center

            pixelPolygon = Polygon(pA, pB, pC, pD)
            pxSphericalArea  = self.polygonAreaOnUnitSphere(pixelPolygon)

            flatField.setPixel(x, y, pxSphericalArea)

            if len(coverPolygons) &gt; 0:
                for coverPolygon in coverPolygons:
                    pixelPolygon = pixelPolygon.clip(coverPolygon)
                    
                # Remove the intensity covered by the clipping polygon:
                pixelPolygon.make3D(zComponent=SDD)
                subarea = self.polygonAreaOnUnitSphere(pixelPolygon)
                pxSphericalArea -= subarea

                clippedFlatField.setPixel(x, y, pxSphericalArea)

        progress = 100*(float(x+1)/float(D.cols()))
        print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

    # Method #1: renormalize to area of theoretically brightest pixel:
    flatField.divide(areaOfBrightestPixel)
    if clippedFlatField != None:
        clippedFlatField.divide(areaOfBrightestPixel)

    # Method #2: rescale maximum of actual brightest pixel to 1.0:
    #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

    #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

    print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)

    return flatField, clippedFlatField</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an information string about the current geometry.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>txt</code></strong> :&ensp;<code>string</code></dt>
<dd>Information string for humans.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Generate an information string about the current geometry.

    Returns
    -------
    txt : string
        Information string for humans.
    &#34;&#34;&#34;

    self.update()

    txt  = &#34;Detector\n&#34;
    txt += &#34;===========================================================\n&#34;
    txt += &#34;Center:          {}\n&#34;.format(self.detector.center)
    txt += &#34;u:               {}\n&#34;.format(self.detector.u)
    txt += &#34;v:               {}\n&#34;.format(self.detector.v)
    txt += &#34;w:               {}\n&#34;.format(self.detector.w)
    txt += &#34;Pixels:          {cols} x {rows}\n&#34;.format(cols=self.detector.cols(), rows=self.detector.rows())
    txt += &#34;Pitch:           {pitchU} x {pitchV}\n&#34;.format(pitchU=self.detector.pitchU, pitchV=self.detector.pitchV)
    txt += &#34;Physical Size:   {width} x {height}\n&#34;.format(width=self.detector.physWidth, height=self.detector.physHeight)

    txt += &#34;Brightest Spot:\n&#34;
    txt += &#34;  World:         {}\n&#34;.format(self.brightestSpotWorld)
    txt += &#34;  Pixels:        {}\n&#34;.format(self.brightestSpotDetector)

    txt += &#34;\n&#34;
    txt += &#34;Source:\n&#34;
    txt += &#34;===========================================================\n&#34;
    txt += &#34;Center:          {}\n&#34;.format(self.source.center)
    txt += &#34;u:               {}\n&#34;.format(self.source.u)
    txt += &#34;v:               {}\n&#34;.format(self.source.v)
    txt += &#34;w:               {}\n&#34;.format(self.source.w)

    txt += &#34;\n&#34;
    txt += &#34;Stage:\n&#34;
    txt += &#34;===========================================================\n&#34;
    txt += &#34;Center:          {}\n&#34;.format(self.stage.center)
    txt += &#34;u:               {}\n&#34;.format(self.stage.u)
    txt += &#34;v:               {}\n&#34;.format(self.stage.v)
    txt += &#34;w:               {}\n&#34;.format(self.stage.w)

    txt += &#34;\n&#34;
    txt += &#34;Geometry Parameters:\n&#34;
    txt += &#34;===========================================================\n&#34;
    # Source - Detector distance (SDD) defined by shortest distance between source and detector:
    txt += &#34;SDD:             {}\n&#34;.format(self.SDD)
    txt += &#34;ODD:             {}\n&#34;.format(self.ODD)
    txt += &#34;SOD:             {}\n&#34;.format(self.SOD)

    return txt</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.pixelAreaOnUnitSphere"><code class="name flex">
<span>def <span class="ident">pixelAreaOnUnitSphere</span></span>(<span>self, A, B, C, D)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixelAreaOnUnitSphere(self, A, B, C, D):
    # Source must be at (0, 0, 0) relative to given detector,
    # and A, B, C, D must be vectors pointing to pixel corners in
    # world coordinate system.

    # Define normals of circular planes, pointing into the
    # triangle or out of the triangle:
    ABin  = A.cross(B)
    BCin  = B.cross(C)
    CAin  = C.cross(A)
    ABout = ABin.inverse()
    BCout = BCin.inverse()
    CAout = CAin.inverse()
    
    ACin  = A.cross(C)
    DAin  = D.cross(A)
    CDin  = C.cross(D)
    ACout = ACin.inverse()
    DAout = DAin.inverse()
    CDout = CDin.inverse()

    # Spherical Triangle ABC:
    alpha = ABin.angle(CAout)
    beta  = BCin.angle(ABout)
    gamma = CAin.angle(BCout)

    # areaABC = alpha + beta + gamma - math.pi

    # Spherical Triangle ACD:
    rho   = ACin.angle(DAout)
    sigma = CDin.angle(ACout)
    tau   = DAin.angle(CDout)

    # areaACD = rho + tau + sigma - math.pi

    pxSphericalArea = (alpha + beta + gamma + rho + sigma + tau) - 2*math.pi

    return pxSphericalArea</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.polygonAreaOnUnitSphere"><code class="name flex">
<span>def <span class="ident">polygonAreaOnUnitSphere</span></span>(<span>self, polygon)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygonAreaOnUnitSphere(self, polygon):
    # Source must be at (0, 0, 0) relative to given detector,
    # and A, B, C must be vectors pointing to triangle corners in
    # world coordinate system.

    if len(polygon.points) &gt;= 3:
        # Start at first point
        p1 = polygon.points[0]

        area = 0

        for i in range(1, len(polygon.points)-1):
            p2 = polygon.points[i]
            p3 = polygon.points[i+1]

            area += self.triangleAreaOnUnitSphere(p1, p2, p3)

        return area
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.projectionMatrix"><code class="name flex">
<span>def <span class="ident">projectionMatrix</span></span>(<span>self, volumeCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a> = None, imageCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a> = None, mode: str = None, mirror: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a projection matrix for the current geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>volumeCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>, optional</dt>
<dd>Position of the volume coordinate system in terms of the
stage coordinate system. If <code>None</code> is given, the volume
coordinate system is assumed to be the stage coordinate system.
See notes for details.</dd>
<dt><strong><code>imageCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>, optional</dt>
<dd>Position of the image coordinate system in terms of the
detector coordinate system. If <code>None</code> is given, the image
coordinate system is assumed to be the detector coordinate system.
See notes for details.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Pre-defined modes. Either "openCT" or "CERA" are supported.
They override the <code>volumeCS</code> and <code>imageCS</code>, which can be set
to <code>None</code> when using one of the pre-defined modes.</dd>
<dt><strong><code>mirror</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not a mirror operation should be applied to the
reconstruction volume. For many 3D processing softwares,
this parameter should be set to <code>True</code> to avoid having to
mirror the volume after loading it into the software.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>Projection matrix.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The image coordinate system (<code>imageCS</code>) should match the notation
used by the reconstruction software, and is expressed in terms of
the detector coordinate system.</p>
<p>The detector coordinate system has its origin at the detector center,
the u unit vector points in the row vector direction, and the
v unit vector points in column vector direction (they are always assumed
to be unit vectors).</p>
<p>The center (origin) of the <code>imageCS</code> should be where the reconstruction
software places the origin of its own projection image coordinate
system. For example, CERA places it at the center of the lower-left pixel
of the projection image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projectionMatrix(self,
                     volumeCS:CoordinateSystem=None,
                     imageCS:CoordinateSystem=None,
                     mode:str=None,
                     mirror:bool=True):
    &#34;&#34;&#34;Calculate a projection matrix for the current geometry.

    Parameters
    ----------
    volumeCS : CoordinateSystem, optional
        Position of the volume coordinate system in terms of the
        stage coordinate system. If `None` is given, the volume
        coordinate system is assumed to be the stage coordinate system.
        See notes for details.

    imageCS : CoordinateSystem, optional
        Position of the image coordinate system in terms of the
        detector coordinate system. If `None` is given, the image
        coordinate system is assumed to be the detector coordinate system.
        See notes for details.

    mode : str, optional
        Pre-defined modes. Either &#34;openCT&#34; or &#34;CERA&#34; are supported.
        They override the `volumeCS` and `imageCS`, which can be set
        to `None` when using one of the pre-defined modes.

    mirror : bool, optional
        Whether or not a mirror operation should be applied to the
        reconstruction volume. For many 3D processing softwares,
        this parameter should be set to `True` to avoid having to
        mirror the volume after loading it into the software.

    Returns
    -------
    P : Matrix
        Projection matrix.

    Notes
    -----
    The image coordinate system (`imageCS`) should match the notation
    used by the reconstruction software, and is expressed in terms of
    the detector coordinate system.

    The detector coordinate system has its origin at the detector center,
    the u unit vector points in the row vector direction, and the
    v unit vector points in column vector direction (they are always assumed
    to be unit vectors).

    The center (origin) of the `imageCS` should be where the reconstruction
    software places the origin of its own projection image coordinate
    system. For example, CERA places it at the center of the lower-left pixel
    of the projection image.
    &#34;&#34;&#34;

    validModes = [&#34;openCT&#34;, &#34;CERA&#34;]

    if mode is not None:
        if mode in validModes:  # Override imageCS
            image = CoordinateSystem()

            if mode == &#34;openCT&#34;:
                &#34;&#34;&#34;openCT places the origin of the image CS at the detector 
                center. The constructor places it at (0,0,0) automatically,
                so there is nothing to do. Comments for illustration.&#34;&#34;&#34;
                # image.center.x = 0
                # image.center.y = 0
                # image.center.z = 0

                &#34;&#34;&#34;openCT&#39;s image CS is in mm units. We assume that all
                other coordinate systems are in mm as well here (at least
                when imported from JSON file). No scaling of the basis vectors is necessary.&#34;&#34;&#34;
                # image.u.scale(1.0)
                # image.v.scale(1.0)
                # image.w.scale(1.0)

            elif mode == &#34;CERA&#34;:
                if self.detector.sizeIsSet():
                    &#34;&#34;&#34;CERA places the origin of the image CS in the center
                    of the lower left pixel of the projection image.&#34;&#34;&#34;
                    image.center.x = -self.detector.physWidth  / 2.0 + 0.5*self.detector.pitchU
                    image.center.y =  self.detector.physHeight / 2.0 - 0.5*self.detector.pitchV
                    # image.center.z = 0

                    &#34;&#34;&#34;CERA&#39;s unit of the image CS is in px, so we need to
                    scale the image CS basis vectors by the pixel size.
                    Also, v points up instead of down.&#34;&#34;&#34;
                    image.u.scale( self.detector.pitchU)
                    image.v.scale(-self.detector.pitchV)
                    image.w.scale(-1.0)
                else:
                    raise RuntimeError(&#34;Detector size not set. To calculate a projection matrix for CERA, you need to set the size of the detector. Use the setSize() function of your detector object.&#34;)
        else:
            raise RuntimeError(&#34;Unsupported mode for projection matrix: \&#34;{}\&#34;&#34;.format(mode))
    elif imageCS is not None:
        image = copy.deepcopy(imageCS)
    else:
         # Set a standard coordinate system. Results in pure
         # detector coordinate system after transformation.
        image = CoordinateSystem()

    world    = CoordinateSystem()
    source   = copy.deepcopy(self.source)

    # The 3D volume (reconstruction space).
    volume = None
    if volumeCS is not None:
        volume = copy.deepcopy(volumeCS)
        volume.changeReferenceFrame(self.stage, world)
    else:
        volume = copy.deepcopy(self.stage)

    &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
    vectors of the volume CS .&#34;&#34;&#34;
    scale_volume_u = volume.u.length()
    scale_volume_v = volume.v.length()
    scale_volume_w = volume.w.length()

    # Detach the image CS from the detector CS and
    # express it in terms of the world CS:
    image.changeReferenceFrame(self.detector, world)

    &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
    vectors of the image CS.&#34;&#34;&#34;
    scale_image_u = image.u.length()
    scale_image_v = image.v.length()
    scale_image_w = image.w.length()

    # Save a source CS as seen from the detector CS. This is convenient to
    # later get the SDD, ufoc and vfoc:
    source_from_image = copy.deepcopy(self.source)
    source_from_image.changeReferenceFrame(world, image)

    # Make the volume CS the new world CS:
    source.changeReferenceFrame(world, volume)
    image.changeReferenceFrame(world, volume)
    volume.changeReferenceFrame(world, volume)

    # Translation vector from volume to source:
    rfoc = source.center - volume.center
    xfoc = rfoc.x
    yfoc = rfoc.y
    zfoc = rfoc.z
    SOD = rfoc.length()

    # Focus point on detector: principal, perpendicular ray.
    # In the detector coordinate system, ufoc and vfoc are the u and v coordinates
    # of the source center; SDD (perpendicular to detector plane) is source w coordinate.
    ufoc = source_from_image.center.x / scale_image_u
    vfoc = source_from_image.center.y / scale_image_v
    wfoc = source_from_image.center.z / scale_image_w
    SDD  = abs(source_from_image.center.z)

    # Mirror volume:
    if mirror:
        M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])
    else:
        M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0,  1, 0], [0, 0, 0, 1]])

    # Scale: volume units -&gt; world units
    A = Matrix(values=[[scale_volume_u, 0, 0, 0], [0, scale_volume_v, 0, 0], [0, 0, scale_volume_w, 0], [0, 0, 0, 1]])

    # Move origin to source (the origin of the camera CS)
    F = Matrix(values=[[1, 0, 0, -xfoc], [0, 1, 0, -yfoc], [0, 0, 1, -zfoc]])

    # Rotations:
    R = basisTransformMatrix(volume, image)

    # Projection onto detector and scaling (world units -&gt; volume units):
    S = Matrix(values=[[SDD/scale_image_u, 0, 0], [0, SDD/scale_image_v, 0], [0, 0, 1.0/scale_image_w]])

    # Shift in detector CS: (ufoc and vfoc must be in scaled units)
    T = Matrix(values=[[1, 0, ufoc], [0, 1, vfoc], [0, 0, 1]])

    # Multiply all together:
    P = T * (S * (R * (F * (A*M))))

    # Renormalize:
    lower_right = P.get(col=3, row=2)
    if lower_right != 0:
        P.scale(1.0/lower_right)

    return P</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.solidAngle"><code class="name flex">
<span>def <span class="ident">solidAngle</span></span>(<span>self, l, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solidAngle(self, l, m):
    &#34;&#34;&#34; Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth. &#34;&#34;&#34;
    if l != 0:
        return (l/abs(l)) * math.atan(abs(l)*m/math.sqrt(1.0+l**2+m**2))
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.triangleAreaOnUnitSphere"><code class="name flex">
<span>def <span class="ident">triangleAreaOnUnitSphere</span></span>(<span>self, A, B, C)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangleAreaOnUnitSphere(self, A, B, C):
    # Source must be at (0, 0, 0) relative to given detector,
    # and A, B, C must be vectors pointing to ´triangle corners in
    # world coordinate system.

    # Define normals of circular planes, pointing into the
    # triangle or out of the triangle:
    ABin  = A.cross(B)
    BCin  = B.cross(C)
    CAin  = C.cross(A)
    ABout = ABin.inverse()
    BCout = BCin.inverse()
    CAout = CAin.inverse()

    # Spherical Triangle ABC:
    alpha = ABin.angle(CAout)
    beta  = BCin.angle(ABout)
    gamma = CAin.angle(BCout)

    areaABC = alpha + beta + gamma - math.pi

    return areaABC</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate derived geometry parameters.</p>
<p>Calculates the SOD, SDD, ODD, and location of the intensity maximum
on the detector (in world and detector coordinates) for the
curent geometry. Results are stored in the following member variables
(attributes).</p>
<p>SDD: Shortest distance between source center and detector plane.</p>
<p>SOD: Distance between source center and stage center.</p>
<p>ODD: Shortest distance between stage center and detector plane.</p>
<p>brightestSpotWorld: Location of the intensity maximum on the detector,
in world coordinates.
Assuming an isotropically radiating source.</p>
<p>brightestSpotDetector: Location of the intensity maximum on the
detector, in terms of detector coordinate system.
Assuming an isotropically radiating source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Calculate derived geometry parameters.

    Calculates the SOD, SDD, ODD, and location of the intensity maximum
    on the detector (in world and detector coordinates) for the
    curent geometry. Results are stored in the following member variables
    (attributes).

    SDD: Shortest distance between source center and detector plane.

    SOD: Distance between source center and stage center.

    ODD: Shortest distance between stage center and detector plane.

    brightestSpotWorld: Location of the intensity maximum on the detector,
        in world coordinates.  Assuming an isotropically radiating source.

    brightestSpotDetector: Location of the intensity maximum on the
        detector, in terms of detector coordinate system.
        Assuming an isotropically radiating source.
    &#34;&#34;&#34;

    self.source.update()
    self.stage.update()
    self.detector.update()

    # SOD, SDD, ODD
    world = CoordinateSystem()
    source_from_image = copy.deepcopy(self.source)
    stage_from_detector  = copy.deepcopy(self.stage)

    source_from_image.changeReferenceFrame(world, self.detector)
    stage_from_detector.changeReferenceFrame(world, self.detector)

    self.SDD = abs(source_from_image.center.z)
    self.ODD = abs(stage_from_detector.center.z)
    self.SOD = self.source.center.distance(self.stage.center)

    ## Brightest Spot in World Coordinate System:
    self.brightestSpotWorld = copy.deepcopy(self.detector.w)
    self.brightestSpotWorld.scale(self.SDD)
    self.brightestSpotWorld.add(self.source.center)

    ## Brightest Spot in Detector Coordinate System:
    self.brightestSpotDetector = copy.deepcopy(self.brightestSpotWorld)
    self.brightestSpotDetector.subtract(self.detector.center)
    
    pxU = self.brightestSpotDetector.dot(self.detector.u) / self.detector.pitchU + self.detector.cols()/2.0
    pxV = self.brightestSpotDetector.dot(self.detector.v) / self.detector.pitchV + self.detector.rows()/2.0

    self.brightestSpotDetector = Vector(pxU, pxV, 0)

    self.detector.computeGeometryParameters()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#coordinate-systems">Coordinate Systems</a></li>
<li><a href="#full-ct-geometry">Full CT Geometry</a><ul>
<li><a href="#detector-convention">Detector convention</a></li>
<li><a href="#stage-convention">Stage convention</a></li>
<li><a href="#source-convention">Source convention</a></li>
<li><a href="#example-setup">Example Setup</a></li>
</ul>
</li>
<li><a href="#reference-frames">Reference Frames</a></li>
<li><a href="#projection-matrices">Projection Matrices</a><ul>
<li><a href="#mathematical-background">Mathematical Background</a></li>
<li><a href="#generating-projection-matrices">Generating Projection Matrices</a><ul>
<li><a href="#openct-cera">openCT &amp; CERA</a></li>
<li><a href="#image-volume-coordinate-systems">Image &amp; Volume Coordinate Systems</a><ul>
<li><a href="#example-1-cera">Example 1: CERA</a></li>
<li><a href="#example-2-openct">Example 2: openCT</a></li>
<li><a href="#example-3">Example 3</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu" href="index.html">ctsimu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctsimu.geometry.basisTransformMatrix" href="#ctsimu.geometry.basisTransformMatrix">basisTransformMatrix</a></code></li>
<li><code><a title="ctsimu.geometry.writeCERAconfig" href="#ctsimu.geometry.writeCERAconfig">writeCERAconfig</a></code></li>
<li><code><a title="ctsimu.geometry.writeOpenCTFile" href="#ctsimu.geometry.writeOpenCTFile">writeOpenCTFile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.CoordinateSystem.changeReferenceFrame" href="#ctsimu.geometry.CoordinateSystem.changeReferenceFrame">changeReferenceFrame</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.json_import" href="#ctsimu.geometry.CoordinateSystem.json_import">json_import</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.makeUnitCS" href="#ctsimu.geometry.CoordinateSystem.makeUnitCS">makeUnitCS</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate" href="#ctsimu.geometry.CoordinateSystem.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotateAroundU" href="#ctsimu.geometry.CoordinateSystem.rotateAroundU">rotateAroundU</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotateAroundV" href="#ctsimu.geometry.CoordinateSystem.rotateAroundV">rotateAroundV</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotateAroundW" href="#ctsimu.geometry.CoordinateSystem.rotateAroundW">rotateAroundW</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.setup" href="#ctsimu.geometry.CoordinateSystem.setup">setup</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate" href="#ctsimu.geometry.CoordinateSystem.translate">translate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translateX" href="#ctsimu.geometry.CoordinateSystem.translateX">translateX</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translateY" href="#ctsimu.geometry.CoordinateSystem.translateY">translateY</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translateZ" href="#ctsimu.geometry.CoordinateSystem.translateZ">translateZ</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.update" href="#ctsimu.geometry.CoordinateSystem.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.geometry.Detector" href="#ctsimu.geometry.Detector">Detector</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.Detector.cols" href="#ctsimu.geometry.Detector.cols">cols</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.computeGeometryParameters" href="#ctsimu.geometry.Detector.computeGeometryParameters">computeGeometryParameters</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.pixelVector" href="#ctsimu.geometry.Detector.pixelVector">pixelVector</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.pixelVectorCenter" href="#ctsimu.geometry.Detector.pixelVectorCenter">pixelVectorCenter</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.rows" href="#ctsimu.geometry.Detector.rows">rows</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.setSize" href="#ctsimu.geometry.Detector.setSize">setSize</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.sizeIsSet" href="#ctsimu.geometry.Detector.sizeIsSet">sizeIsSet</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField" href="#ctsimu.geometry.Geometry.createDetectorFlatField">createDetectorFlatField</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField_analytical" href="#ctsimu.geometry.Geometry.createDetectorFlatField_analytical">createDetectorFlatField_analytical</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField_rays" href="#ctsimu.geometry.Geometry.createDetectorFlatField_rays">createDetectorFlatField_rays</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField_sphere" href="#ctsimu.geometry.Geometry.createDetectorFlatField_sphere">createDetectorFlatField_sphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.info" href="#ctsimu.geometry.Geometry.info">info</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.pixelAreaOnUnitSphere" href="#ctsimu.geometry.Geometry.pixelAreaOnUnitSphere">pixelAreaOnUnitSphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.polygonAreaOnUnitSphere" href="#ctsimu.geometry.Geometry.polygonAreaOnUnitSphere">polygonAreaOnUnitSphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.projectionMatrix" href="#ctsimu.geometry.Geometry.projectionMatrix">projectionMatrix</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.solidAngle" href="#ctsimu.geometry.Geometry.solidAngle">solidAngle</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.triangleAreaOnUnitSphere" href="#ctsimu.geometry.Geometry.triangleAreaOnUnitSphere">triangleAreaOnUnitSphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.update" href="#ctsimu.geometry.Geometry.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>