<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>ctsimu.geometry API documentation</title>
<meta name="description" content="Coordinate systems, transformations and projection matrix functionality …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.geometry</code></h1>
</header>
<section id="section-intro">
<p>Coordinate systems, transformations and projection matrix functionality.</p>
<h1 id="coordinate-systems">Coordinate Systems</h1>
<p>The geometry subpackage provides a <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code> class that lets you create and manipulate objects in a virtual CT scene. Such an oject has a position (<code>center</code>) and three basis vectors (<code>u</code>, <code>v</code>, <code>w</code>). These basis vectors are assumed to be orthogonal, but they do not have to be unit vectors. The <code>center</code> acts as the pivot point for rotations if no other pivot is specified.</p>
<p>Example for creating and manipulating an object:</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/01_coordinate_systems.py

import math
from ctsimu.geometry import *

mySpecimen = CoordinateSystem()

# Set position and orientation:
mySpecimen.center = Vector(250, 0, 0)
mySpecimen.u = Vector(0, -1,  0)
mySpecimen.v = Vector(0,  0, -1)
mySpecimen.w = Vector(1,  0,  0)

# Manipulate:
mySpecimen.translate(translation_vector=Vector(5.2, 0, 4.3))
mySpecimen.rotate_around_u(angle=math.radians(2.0))
mySpecimen.rotate(axis=Vector(1, 1, 1), angle=math.radians(5.0))

print(&quot;My specimen's new location and orientation:&quot;)
print(mySpecimen)

&quot;&quot;&quot;
My specimen's new location and orientation:
Center: [255.2   0.    4.3]
u:      [ 0.04905096 -0.99746313 -0.05158783]
v:      [-0.01674544  0.05082147 -0.99856736]
w:      [ 0.99865589  0.04984455 -0.01421012]

&quot;&quot;&quot;
</code></pre>
<h1 id="full-ct-geometry">Full CT Geometry</h1>
<p>For a full CT, we need an X-ray source, a stage for the specimens, and a detector. The <code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code> class bundles three coordinate systems (one for each of those components) and additional information about the detector (using the <code><a title="ctsimu.geometry.DetectorGeometry" href="#ctsimu.geometry.DetectorGeometry">DetectorGeometry</a></code> class, an extension of a regular <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>). The following figure shows their standard orientations when a CT geometry is initialized.</p>
<p><img alt="Standard coordinate system" src="pictures/geometry.png" title="Standard coordinate system"></p>
<p>The orientation of the coordinate system and all components can be changed by rotations or by manually setting the object basis vectors. However, it is important to keep the following conventions.</p>
<h2 id="detector-convention">Detector convention</h2>
<ul>
<li>The detector's <code>u</code> vector is its row vector.</li>
<li>The detector's <code>v</code> vector is its column vector.</li>
<li>The detector's <code>w</code> vector has no special meaning. It is a planar normal that must be chosen such that the detector's coordinate system remains right-handed.</li>
</ul>
<h2 id="stage-convention">Stage convention</h2>
<ul>
<li>The stage's <code>w</code> vector is its axis of CT rotation.</li>
<li>The stage's <code>center</code> typically refers to the center of the reconstructed volume (possibly the center of the specimen) and is <em>not</em> meant to describe the location of the turntable (which would normally be at a lower position).</li>
</ul>
<h2 id="source-convention">Source convention</h2>
<p>There is currently no restriction on the source coordinate system. We usually assume its <code>w</code> axis to be the direction of the principal ray, but this is not a necessity.</p>
<p>In the following examples, the source will be located at the origin <code>(0, 0, 0)</code> of the world coordinate system, whereas stage and detector are placed in positive <em>x</em> direction (see figure above).</p>
<h2 id="example-setup">Example Setup</h2>
<p>In the following example, we set up a standard CT geometry.</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/02_simple_CT_geometry.py

from ctsimu.geometry import *

# General CT parameters:
SOD = 250.0 # mm
SDD = 800.0 # mm

pixelSize = 0.2 # mm
pixelColumns = 2000
pixelRows = 1000

# Create a CT geometry object:
myCT = Geometry()

# Stage:
myCT.stage.center.set_x(SOD)

# Detector:
myCT.detector.center.set_x(SDD)
myCT.detector.set_size(
    pixels_u = pixelColumns,
    pixels_v = pixelRows,
    pitch_u = pixelSize,
    pitch_v = pixelSize
)

myCT.update() # calculates derived geometry parameters

print(myCT.info())
</code></pre>
<h1 id="reference-frames">Reference Frames</h1>
<p>Implicitly, each coordinate system has a reference coordinate system (its <em>reference frame</em>) in which its <code>center</code> and <code>u</code>, <code>v</code>, <code>w</code> basis vectors are located and described. Typically, we assume that this is a right-handed standard coordinate system. It does not necessarily have to be the world coordinate system. For example, you might want to attach a specimen to the sample stage by implicitly making the stage coordinate system its reference coordinate system. You, the programmer, have to know the reference coordinate system of your objects, as this information is not explicitly stored by the toolbox.</p>
<p>Any new <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code> object is initialized to be a right-handed standard coordinate system with its center at <code>(0, 0, 0)</code>:</p>
<pre><code class="language-python">from ctsimu.geometry import *

myWorld = CoordinateSystem()

print(&quot;My World:&quot;)
print(myWorld)

&quot;&quot;&quot;
My World:
Center: ( 0.0000000,  0.0000000,  0.0000000)
u:      ( 1.0000000,  0.0000000,  0.0000000)
v:      ( 0.0000000,  1.0000000,  0.0000000)
w:      ( 0.0000000,  0.0000000,  1.0000000)
&quot;&quot;&quot;
</code></pre>
<p>You can change the reference frame of a <code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>. In the following example, we set up a CT geometry with a stage that is tilted by 2°. We place a specimen object in the stage coordinate system and move it "upwards" by 5 mm along the (now tilted) axis of rotation. Afterwards, we change the specimen's reference frame to see where it is actually located in the world coordinate system. Refer to the image of the standard orientations above to see what is going on with the coordinate systems.</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/03_reference_frames.py

import math
from ctsimu.geometry import * # also contains ctsimu_world

# Set up a quick CT geometry with a tilted stage axis:
myCT = Geometry()
myCT.stage.center.set_x(250)  # SOD
myCT.stage.rotate_around_u(angle = math.radians(2.0))
myCT.detector.center.set_x(800)  # SDD

# Assume a specimen in the (tilted) stage
# coordinate system, shifted 5 mm &quot;upwards&quot;
# along the axis of rotation:
mySpecimen = CoordinateSystem()
mySpecimen.translate_z(5.0)

# Change the specimen's reference frame to
# the world coordinate system:
mySpecimen.change_reference_frame(
    cs_from = myCT.stage,
    cs_to = ctsimu_world
)

print(&quot;The specimen's world coordinates:&quot;)
print(mySpecimen)

&quot;&quot;&quot;
The specimen's world coordinates:
Center: ( 250.0000000, -0.1744975,  4.9969541)
u:      ( 1.0000000,  0.0000000,  0.0000000)
v:      ( 0.0000000,  0.9993908,  0.0348995)
w:      ( 0.0000000, -0.0348995,  0.9993908)
&quot;&quot;&quot;
</code></pre>
<p><strong>Note:</strong> When changing reference frames, the original (<code>cs_from</code>) and the target reference frame (<code>cs_to</code>) must both have the same common reference frame for themselves. In the example above, we change the reference frame from the stage coordinate system to the world coordinate system. Both of them have the same reference frame: the world coordinate system (which is special, because it is also a reference for itself).</p>
<h1 id="projection-matrices">Projection Matrices</h1>
<p>A projection matrix maps a 3D point coordinate <code>(x, y, z)</code> from the stage coordinate system to a 2D point coordinate <code>(u, v)</code> in the detector coordinate system. They are used by some reconstruction softwares to describe arbitrary scan trajectories. For such a reconstruction, we need one projection matrix for each projection image.</p>
<p><img alt="Euclidean Mapping" src="pictures/pmatrix_mapping_euclidean.png" title="Mapping a coordinate from the stage coordinate system to a coordinate in the detector coordinate system"></p>
<h2 id="mathematical-background">Mathematical Background</h2>
<p>We operate in <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">homogeneous coordinates</a> because we are in a projective geometry and this concept allows us to describe translations in space by a matrix. Homogeneous coordinates describe rays in a space and are therefore only defined up to a scale factor, which is carried as an additional coordinate. This way, a Euclidean 3-vector turns into a homogeneous 4-vector. Our mapping becomes:</p>
<p><img alt="Homogeneous Mapping" src="pictures/pmatrix_mapping_homogeneous.png" title="Mapping in homogeneous coordinates"></p>
<p>The following picture illustrates a 1D projective geometry. The <em>h</em> axis is our scale factor for the homogeneous coordinates. In this geometry, all points on a ray are equivalent. The points at <em>h</em>=1 are the normalized homogeneous coordinates.</p>
<p><img alt="Projective geometry for a 1D Euclidean space" src="pictures/hom_coords.png" title="Projective geometry for a 1D Euclidean space"></p>
<p>We can use this concept to describe translations in space with a matrix multiplication:</p>
<p><img alt="Translation Matrix" src="pictures/pmatrix_translation.png" title="Translation Matrix"></p>
<p>We now consider two coordinate systems: the stage coordinate system (our origin) and the detector coordinate system (our target). The world coordinate system is not important in this context. In the following picture, 3D coordinates (x, y, z) are expressed in terms of the stage coordinate system and 2D coordinates (u, v) are expressed in terms of the detector coordinate system (ignoring its <em>w</em> axis).</p>
<p><img alt="Projective system" src="pictures/geometry_stage_projection.png" title="Projective system"></p>
<p>To calculate a projection matrix for the current geometry, we have to consider five subsequent transformations. Each transformation is expressed by a matrix. The final projection matrix is then the product of these five transformation matrices.</p>
<ol>
<li>
<p>We shift the origin of the coordinate system from the stage to the source, which is our center of projection. The scaling factors s<sub>x</sub>, s<sub>y</sub> and s<sub>z</sub> take care of converting the volume units into the units of the world coordinate system, for example from voxels to millimeters.</p>
<p><img alt="Shifting the origin to the source" src="pictures/pmatrix_F.png" title="Shifting the origin to the source"></p>
</li>
<li>
<p>We perform a basis transformation to express the 3D coordinates in terms of the axes of the detector coordinate system. The origin remains at the source. You can also think of this transformation as a rotation into the detector coordinate system.</p>
<p><img alt="Rotation into detector coordinate system" src="pictures/pmatrix_R.png" title="Rotation into detector coordinate system"></p>
<p>All basis vectors in this matrix are assumed to be unit vectors.</p>
<p>This matrix takes care of any stage or detector tilts.</p>
<p>After this transformation, the third (<em>"z"</em>) coordinate in a vector now refers to its position on the detector normal (its <em>w</em> axis). Therefore, this third coordinate now contains something similar to what we would normally call the SOD (source-object distance) of that point. The fourth coordinate of our homogeneous vector has not been scaled so far (α=1), which means we have not left the projective plane which we call home (our real world). This is important to keep in mind for the next step.</p>
</li>
<li>
<p>We use a matrix that reduces the dimension of our vector by one (from a homogeneous 4-vector to a homogeneous 3-vector). This step is sometimes called the actual <em>projection</em>.</p>
<p><img alt="Projection reduces dimension" src="pictures/pmatrix_D.png" title="Projection reduces dimension"></p>
<p>In the previous step, the third component of the 4-vector used to be something similar to the SOD. This has now become the <em>scale component</em> β of our homogeneous 3-vector (because a multiplication with this matrix throws away the fourth vector component, which has still been α=1). This means we are now in a projective plane β=SOD, away from the detector plane of our home world (which would be at β=1).</p>
<p>This problem is solved in the end by a simple renormalization of the matrix and implicitly will give us the correct magnification factor. Stay tuned!</p>
</li>
<li>
<p>We take care of the magnification and any additional scaling.</p>
<p><img alt="Scaling" src="pictures/pmatrix_S.png" title="Scaling"></p>
<p>The SDD (source-detector distance) in this case means the length of the principal ray from source to detector (i.e., the ray that is parallel to the detector normal <em>w</em> and orthogonally hits the detector plane).</p>
<p>This matrix simply scales any image at the projective plane β=1 such that its <em>u</em> and <em>v</em> component will obey the magnification by the SDD (source-detector distance). The scaling factors s<sub>u</sub> and s<sub>v</sub> take care of the unit conversion from the world coordinate system to the image coordinate system, e.g. from millimeters to pixels. The scaling factor s<sub>w</sub> for the image's normal vector is usually <code>1</code> or <code>-1</code>, depending on which kind of image coordinate system is expected by the reconstruction software.</p>
<p>Note that the final renormalization will turn out to be a division by the SOD (as mentioned in the previous step). This will convert the SDD-factors of this matrix into the actual magnification: M=SDD/SOD. We do not incorporate this here because the SOD as a parameter is not well-defined and might lead to confusion in a non-standard geometry.</p>
</li>
<li>
<p>The origin of the detector coordinate system might not be where the principal ray hits the detector (i.e., the center of projection projected onto the detector). We need to take care of this additional shift:</p>
<p><img alt="Translation on detector" src="pictures/pmatrix_T.png" title="Translation on detector"></p>
</li>
</ol>
<p>The final projection matrix is a 3×4 matrix that results from a multiplication of these five matrices and a renormalization by the lower-right component (p<sub>23</sub>) to get back to the projective plane of our home world (see step 3).</p>
<p><img alt="Final projection matrix" src="pictures/pmatrix_P.png" title="Final projection matrix"></p>
<h2 id="generating-projection-matrices">Generating Projection Matrices</h2>
<p>You can call the function <code><a title="ctsimu.geometry.Geometry.projection_matrix" href="#ctsimu.geometry.Geometry.projection_matrix">Geometry.projection_matrix()</a></code> to get a projection matrix for the geometry's current configuration.</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/04_projection_matrix.py

from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.set_x(250)    # SOD
myCT.detector.center.set_x(800) # SDD

# Calculate the projection matrix:
P = myCT.projection_matrix()

print(&quot;Projection Matrix:&quot;)
print(P)

&quot;&quot;&quot;
Projection Matrix:
[[ 0.     3.2    0.     0.   ]
 [ 0.     0.     3.2    0.   ]
 [-0.004  0.     0.     1.   ]]
&quot;&quot;&quot;
</code></pre>
<h3 id="openct-cera">openCT &amp; CERA</h3>
<p>The toolbox provides two pre-configured modes to calculate projection matrices for openCT (which can be used in VGSTUDIO MAX) and for SIEMENS CERA. Each software needs slightly different projection matrices, because they define their detector coordinate system in different ways. See the next section about the image and volume coordinate system for details.</p>
<p>In the following example, we calculate a projection matrix for each software by defining the <code>mode</code> when calling the <code><a title="ctsimu.geometry.Geometry.projection_matrix" href="#ctsimu.geometry.Geometry.projection_matrix">Geometry.projection_matrix()</a></code> function.</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/05_projection_matrix_modes.py

from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.set_x(250)    # SOD
myCT.detector.center.set_x(800) # SDD

# Set the detector size:
myCT.detector.set_size(
    pixels_u = 2000,
    pixels_v = 1000,
    pitch_u  = 0.2,
    pitch_v  = 0.2)

# Calculate the projection matrix:
P_openCT = myCT.projection_matrix(mode=&quot;OpenCT&quot;)
P_CERA   = myCT.projection_matrix(mode=&quot;CERA&quot;)

print(&quot;OpenCT:&quot;)
print(P_openCT)

print(&quot;CERA:&quot;)
print(P_CERA)
</code></pre>
<h3 id="image-volume-coordinate-systems">Image &amp; Volume Coordinate Systems</h3>
<p>Depending on the reconstruction software, the <strong>image coordinate system</strong> of the projection image does not have to match our standard detector coordinate system. Also, the <strong>volume coordinate system</strong> of the reconstructed volume does not have to match the stage coordinate system.</p>
<p>In the following three examples, we will show how to use the parameters <code>imageCS</code> and <code>volumeCS</code> to define our own image and volume coordinate systems.</p>
<p><img alt="Image and volume coordinate system" src="pictures/image_stage_cs.png" title="Image and volume coordinate system"></p>
<p><strong>Note:</strong> The image coordinate system is expressed in terms of the detector coordinate system (its reference coordinate system). Similarly, the volume coordinate system is expressed in terms of the stage coordinate system. To set the scale factor for the image or volume coordinate system, we set the lengths of their basis vectors to the correct conversion factor (e.g., the pixel size in mm/px or the voxel size in mm/voxel).</p>
<h4 id="example-1-cera">Example 1: CERA</h4>
<p>Even though we have a pre-defined mode for CERA, we will use its image coordinate system (illustrated above) to show how to set up an image coordinate system for CERA manually.</p>
<p>CERA's volume coordinate system matches our stage coordinate system, but we flip
the volume's w axis. Usually, this helps importing the volume into third-party
3D volumetric processing software. If we wouldn't do this step, the volume
is usually flipped (mirrored) in common visualizers.</p>
<p>CERA's image coordinate system has its origin in the center of the lower left pixel of the detector. This means we have to move its origin by half the detector's physical width to the left and half the detector's physical height downwards from the origin of the detector coordinate system, and then back by half a physical pixel size (the detector pitch). We can use the attributes <code>phys_width</code> and <code>phys_height</code>, which are automatically calculated when calling <code><a title="ctsimu.geometry.DetectorGeometry.set_size" href="#ctsimu.geometry.DetectorGeometry.set_size">DetectorGeometry.set_size()</a></code>.</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/06_projection_matrix_cera.py

from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.set_x(250)    # SOD
myCT.detector.center.set_x(800) # SDD

# Set the detector size:
myCT.detector.set_size(
    pixels_u = 2000,
    pixels_v = 1000,
    pitch_u  = 0.2,
    pitch_v  = 0.2)

# Set up a new image coordinate system,
# relative to the detector coordinate system:
image = CoordinateSystem()

# CERA places the origin of the image CS in the center
# of the lower left pixel of the projection image.
image.center.set_x(-(myCT.detector.phys_width  / 2.0) + 0.5*myCT.detector.pitch_u)
image.center.set_y( (myCT.detector.phys_height / 2.0) - 0.5*myCT.detector.pitch_v)

# CERA's unit of the image CS is in px, so we need to
# scale the image CS basis vectors by the pixel size.
# Also, v points up instead of down. This also flips
# the w axis to keep a right-handed coordinate system.
image.u.scale( myCT.detector.pitch_u)
image.v.scale(-myCT.detector.pitch_v)

# CERA's volume coordinate system is equivalent to the CTSimU stage coordinate
# coordinate system, but flipped vertically. Therefore, we need to
# invert the volume's w axis.
volume = CoordinateSystem()
volume.w.invert()

# Calculate the projection matrix:
P = myCT.projection_matrix(imageCS=image, volumeCS=volume)

print(&quot;CERA projection matrix:&quot;)
print(P)

&quot;&quot;&quot;
CERA projection matrix:
[[-3.998e+00  1.600e+01  0.000e+00  9.995e+02]
 [-1.998e+00  0.000e+00  1.600e+01  4.995e+02]
 [-4.000e-03  0.000e+00  0.000e+00  1.000e+00]]
&quot;&quot;&quot;
</code></pre>
<h4 id="example-2-openct">Example 2: openCT</h4>
<p>In the case of openCT, the image coordinate system matches our detector coordinate system. Also, the volume coordinate system matches our definition of the stage coordinate system. However, as in the case of CERA, we will flip the reconstruction volume to make it easier to import it into 3D visualization software.</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/07_projection_matrix_openCT.py

from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.set_x(250)    # SOD
myCT.detector.center.set_x(800) # SDD

# Set the detector size:
myCT.detector.set_size(
    pixels_u = 2000,
    pixels_v = 1000,
    pitch_u  = 0.2,
    pitch_v  = 0.2)

# Set up a new volume coordinate system
# as a standard coordinate system,
# relative to the stage coordinate system:
volume = CoordinateSystem()
volume.w.invert()  # mirror reconstruction volume

# Calculate the projection matrix:
P = myCT.projection_matrix(volumeCS = volume)

print(&quot;openCT projection matrix:&quot;)
print(P)

&quot;&quot;&quot;
openCT projection matrix:
[[ 0.     3.2    0.     0.   ]
 [ 0.     0.    -3.2    0.   ]
 [-0.004  0.     0.     1.   ]]
&quot;&quot;&quot;
</code></pre>
<h4 id="example-3">Example 3</h4>
<p>For the third example (see illustration), we will have to move the origin of the image coordinate system to the upper left corner of the detector and scale its basis vectors by the pixel size because its units are pixels.</p>
<p>The volume coordinate system has its origin at the front lower right corner of the reconstruction volume. Because it is no longer at the stage's center, we will actually have to define the volume's physical size in order to correctly calculate the corner coordinate in terms of the stage coordinate system.</p>
<p>We also scale the basis vectors of the volume coordinate system by the voxel size, because we assume that our reconstruction software expresses its volume coordinates in voxel units instead of world units (mm).</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/08_projection_matrix_example3.py

from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.set_x(250)     # SOD in mm
myCT.detector.center.set_x(800)  # SDD in mm

# Set the detector size:
myCT.detector.set_size(
    pixels_u = 2000,
    pixels_v = 1000,
    pitch_u  = 0.2,
    pitch_v  = 0.2)

# Define the size of the reconstruction volume:
volume_size_x = 2000 # voxels
volume_size_y = 2000 # voxels
volume_size_z = 1000 # voxels
voxel_size = 0.0625  # mm/voxel

# Set up a new image coordinate system,
# relative to the detector coordinate system:
image = CoordinateSystem()

# Move the image origin to the upper left corner
# of the detector coordinate system:
image.center.set_x(-myCT.detector.phys_width  / 2.0)
image.center.set_y(-myCT.detector.phys_height / 2.0)

# Our unit of the image CS is in px, so we need to
# scale the image CS basis vectors by the pixel size.
image.u.scale(myCT.detector.pitch_u)
image.v.scale(myCT.detector.pitch_v)

# Set up a new volume coordinate system,
# relative to the stage coordinate system:
volume = CoordinateSystem()

# Move the volume origin to the front lower right
# corner of the reconstruction volume:
volume.center.set_x(-volume_size_x * voxel_size / 2.0)
volume.center.set_y(-volume_size_y * voxel_size / 2.0)
volume.center.set_z(-volume_size_z * voxel_size / 2.0)

# Our unit of the volume CS is in voxels, so we need to
# scale the volume CS basis vectors by the voxel size.
volume.u.scale(voxel_size)
volume.v.scale(voxel_size)
volume.w.scale(voxel_size)

# Calculate the projection matrix:
P = myCT.projection_matrix(imageCS=image, volumeCS=volume)

print(&quot;My projection matrix:&quot;)
print(P)

&quot;&quot;&quot;
My projection matrix:
[[-3.33333333e-01  1.33333333e+00  0.00000000e+00  2.33333333e+03]
 [-1.66666667e-01  0.00000000e+00  1.33333333e+00  1.16666667e+03]
 [-3.33333333e-04  0.00000000e+00  0.00000000e+00  1.00000000e+00]]
&quot;&quot;&quot;
</code></pre>
<h2 id="simulating-a-complete-ct-scan">Simulating a complete CT scan</h2>
<p>A single projection matrix is not enough to describe a full CT scan. We need one projection matrix for each frame (i.e., for each projection image).</p>
<p>We can use a loop to set up each frame and collect the projection matrices in a list. Afterwards, we can pass this list of matrices to the function <code><a title="ctsimu.geometry.create_OpenCT_config" href="#ctsimu.geometry.create_OpenCT_config">create_OpenCT_config()</a></code> or <code><a title="ctsimu.geometry.create_CERA_config" href="#ctsimu.geometry.create_CERA_config">create_CERA_config()</a></code> to create specific reconstruction configuration files for each reconstruction software.</p>
<p>In the loop, it is advisable not to rotate the stage incrementally for each frame by a certain angular increment. This could lead to the accumulation of small floating-point rounding inaccuracies. Instead, we create a backup of the initial setup (at frame zero) using the <code><a title="ctsimu.geometry.Geometry.store" href="#ctsimu.geometry.Geometry.store">Geometry.store()</a></code> function. In each step of the loop, we restore this initial configuration by calling <code><a title="ctsimu.geometry.Geometry.restore" href="#ctsimu.geometry.Geometry.restore">Geometry.restore()</a></code> and then rotate the stage to its current absolute angle. This approach parameterizes the whole CT trajectory as a deterministic function that only depends on the initial configuration and the current frame number. It is preferred over incremental changes in a loop, but might not always be feasible.</p>
<p>The following example shows how to simulate a simple CT scan (one full stage rotation with 3000 equidistant projection images) and how to create configuration files for the reconstruction.</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# File: examples/geometry/09_projection_matrix_full_CT.py

import math
from ctsimu.geometry import *

# Set up a quick CT geometry:
myCT = Geometry()
myCT.stage.center.set_x(250)     # SOD in mm
myCT.detector.center.set_x(800)  # SDD in mm

# Set the detector size:
myCT.detector.set_size(
    pixels_u = 2000,
    pixels_v = 1000,
    pitch_u  = 0.2,
    pitch_v  = 0.2)

myCT.update() # signal that we made manual changes
myCT.store()  # backup the initial configuration

# Scan configuration:
projections = 3000   # number of projections or angular steps
scan_range  = 360.0  # degrees. One full CT rotation.

# We assume that the projections are stored in single TIFF image files,
# sequentially numbered with four digits, starting at &quot;img_0000.tif&quot;.
projection_filename = &quot;img_{:04d}.tif&quot;   # for OpenCT
projection_file_pattern = &quot;img_%04d.tif&quot; # for CERA

# The following two lists will store the projection matrices
# for openCT and for CERA:
matrices_openCT = []
matrices_CERA   = []

# For openCT, we also need to create a list of projection file names:
projection_filenames = []

# Loop over each frame:
for p in range(projections):
    # Restore the initial configuration from the backup,
    # i.e. the situation before the stage was rotated:
    myCT.restore()

    # Rotate the stage to its current angle:
    current_angle = float(p) * float(scan_range) / float(projections)
    myCT.stage.rotate_around_w(angle=math.radians(current_angle))
    myCT.update()

    # Calculate a projection matrix for this frame:
    P_openCT = myCT.projection_matrix(mode=&quot;OpenCT&quot;)
    P_CERA   = myCT.projection_matrix(mode=&quot;CERA&quot;)

    # Add to list of projection matrices:
    matrices_openCT.append(P_openCT)
    matrices_CERA.append(P_CERA)

    # Store the current projection filename for openCT:
    projection_filenames.append(projection_filename.format(p))

# Restore CT setup for frame zero:
myCT.restore()

# openCT configuration:
# ----------------------
# Write the openCT configuration file, including the projection matrices:
create_OpenCT_config(
    geo=myCT,
    filename=&quot;example_09/recon_openCT.json&quot;,
    projection_files=projection_filenames,
    matrices=matrices_openCT,
    volumename=&quot;recon_openCT&quot;
)

# CERA configuration:
# -------------------
# Write the CERA configuration file, including the projection matrices:
create_CERA_config(
    geo=myCT,
    total_angle=scan_range,
    projection_file_pattern=projection_file_pattern,
    matrices=matrices_CERA,
    basename=&quot;recon_CERA&quot;,
    save_dir=&quot;example_09&quot;,
    i0max=44000  # maximum free-beam intensity
)
</code></pre>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctsimu.geometry.basis_transform_matrix"><code class="name flex">
<span>def <span class="ident">basis_transform_matrix</span></span>(<span>cs_from: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>, cs_to: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>) ‑> <a title="ctsimu.primitives.Matrix" href="primitives.html#ctsimu.primitives.Matrix">Matrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>A matrix that transforms coordinates from <code>cs_from</code> to <code>cs_to</code>.</p>
<p><code>cs_from</code> and <code>cs_to</code> must have the same common reference frame
(e.g. the world coordinate system). A shift in origins is not
taken into account, i.e., their origins are assumed to be at
the same position.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cs_from</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The origin coordinate system.</dd>
<dt><strong><code>cs_to</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The target coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="primitives.html#ctsimu.primitives.Matrix">Matrix</a></code></dt>
<dd>The 3x3 basis transformation matrix.</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li>S. Widnall: <a href="https://ocw.mit.edu/courses/16-07-dynamics-fall-2009/resources/mit16_07f09_lec03/">Lecture L3 - Vectors, Matrices and Coordinate Transformations</a></li>
</ul></div>
</dd>
<dt id="ctsimu.geometry.change_reference_frame_of_direction"><code class="name flex">
<span>def <span class="ident">change_reference_frame_of_direction</span></span>(<span>direction: Vector, cs_from: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>, cs_to: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>) ‑> <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>For a <code>direction</code> in <code>cs_from</code>, get the new direction in terms of <code>cs_to</code>.
<code>cs_from</code> and <code>cs_to</code> must be in the same reference coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>direction</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Direction in terms of <code>cs_from</code>.</dd>
<dt><strong><code>cs_from</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The original coordinate system.</dd>
<dt><strong><code>cs_to</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The target coordinate system, in which the direction should be expressed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>direction_in_cs_to</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>The direction in terms of cs_to.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.change_reference_frame_of_point"><code class="name flex">
<span>def <span class="ident">change_reference_frame_of_point</span></span>(<span>point: Vector, cs_from: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>, cs_to: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>) ‑> <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>For a <code>point</code> coordinate in <code>cs_from</code>, get the new coordinate in terms of
<code>cs_to</code>. <code>cs_from</code> and <code>cs_to</code> must be in the same reference coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Point coordinates in terms of <code>cs_from</code>.</dd>
<dt><strong><code>cs_from</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The original coordinate system.</dd>
<dt><strong><code>cs_to</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The target coordinate system, in which the point coordinates
should be expressed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>point_in_cs_to</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>The point coordinates in terms of cs_to.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.create_CERA_config"><code class="name flex">
<span>def <span class="ident">create_CERA_config</span></span>(<span>geo: <a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a>, projection_file_pattern: str, basename: str, save_dir: str = None, n_projections: int = None, flip_u: bool = False, flip_v: bool = True, projection_datatype: str = 'float32', projection_filetype: str = 'tiff', projection_byteorder: str = 'little', projection_headersize: int = 0, start_angle: float = 0, total_angle: float = 360, scan_direction='CCW', voxels_x: int = None, voxels_y: int = None, voxels_z: int = None, voxelsize_x: float = None, voxelsize_y: float = None, voxelsize_z: float = None, i0max: float = 60000, output_datatype: str = 'float32', matrices: list = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a CERA config file for the given geometry.</p>
<p>A circular trajectory for the given angular range is assumed, all parameters
of the output config file will reflect a circular behaviour (obeying static tilts).
For non-circular trajectories, provide a list of projection matrices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geo</code></strong> :&ensp;<code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code></dt>
<dd>A geometry that should represent the CT setup at frame zero, as seen
by the reconstruction software.</dd>
<dt><strong><code>projection_file_pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Pattern for the sequential projection files.</p>
<p>Example: <code>"../projections/corrected/example_%04d.tif"</code></p>
</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>str</code></dt>
<dd>Base name for the configuration files and table of projection matrices.</dd>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Directory where the configuration files will be stored.</p>
<p>Standard value: <code>None</code> (local script directory)</p>
</dd>
<dt><strong><code>n_projections</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of projections. Set to <code>None</code> if number of projections
should be inferred from the number of provided projection matrices.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>flip_u</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Flip projection images horizontally before reconstruction?</p>
<p>Standard value: <code>False</code></p>
</dd>
<dt><strong><code>flip_v</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Flip projection images vertically before reconstruction?</p>
<p>Standard value: <code>True</code></p>
</dd>
<dt><strong><code>projection_datatype</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Data type of the projection images, as well as possible bright and dark
images and the bad pixel map.</p>
<p>Allowed values: <code>"uint16"</code>, <code>"float32"</code></p>
<p>Standard value: <code>"float32"</code></p>
</dd>
<dt><strong><code>projection_filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>File type of the projection images, as well as possible bright and dark
images and the bad pixel map.</p>
<p>Allowed values: <code>"raw"</code> or <code>"tiff"</code></p>
<p>Standard value: <code>"tiff"</code></p>
</dd>
<dt><strong><code>projection_headersize</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>For RAW projection images: header size to skip (in bytes).</p>
<p>Standard value: <code>0</code></p>
</dd>
<dt><strong><code>projection_byteorder</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>For RAW projection images: endianness of the files.</p>
<p>Allowed values: <code>"little"</code> or <code>"big"</code></p>
<p>Standard value: <code>"little"</code></p>
</dd>
<dt><strong><code>start_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Reconstruction start angle (in degrees). The start angle can be
tuned to change the in-plane rotation of the reconstruction images.
Depending on the current stage rotation in this geometry, the
start angle will be adjusted. Consider this parameter more like
an offset to the start angle of stage rotation.</p>
<p>Standard value: <code>0</code></p>
</dd>
<dt><strong><code>total_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Total angular range of the CT scan (in degrees).</p>
<p>Standard value: <code>360</code></p>
</dd>
<dt><strong><code>scan_direction</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Direction of stage rotation, either <code>"CCW"</code> for counter-clockwise
or <code>"CW"</code> for clockwise rotation.</p>
<p>Standard value: <code>"CCW"</code></p>
</dd>
<dt><strong><code>voxels_x</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of voxels in x direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixels.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxels_y</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of voxels in y direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixels.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxels_z</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of voxels in z direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixels.</p>
<p>For helix scans, this parameter should be increased because the
default voxel size in z direction corresponds to the detector height,
whereas a helix scan usually covers much more than the detector height.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxelsize_x</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Voxel size in x direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixel size
and magnification.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxelsize_y</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Voxel size in y direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixel size
and magnification.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxelsize_z</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Voxel size in z direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixel size
and magnification.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>i0max</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Grey value for the maximum free-beam intensity in the
projection images.</p>
<p>Standard value: <code>60000</code></p>
</dd>
<dt><strong><code>output_datatype</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Data type for the reconstruction volume output file.
Either <code>"float32"</code> or <code>"uint16"</code>.</p>
<p>Standard value: <code>"float32"</code></p>
</dd>
<dt><strong><code>matrices</code></strong> :&ensp;<code>list</code></dt>
<dd>List of projection matrices of type <code><a title="ctsimu.primitives.Matrix" href="primitives.html#ctsimu.primitives.Matrix">Matrix</a></code>.
One matrix for each projection image is required. If this parameter
is set to <code>None</code>, the configuration will be set up for a circular scan
trajectory (obeying static tilts).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.create_OpenCT_config"><code class="name flex">
<span>def <span class="ident">create_OpenCT_config</span></span>(<span>geo: <a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a>, filename: str = None, variant: str = 'free', projection_files: list = None, projection_dir: str = None, flip_u: bool = False, flip_v: bool = False, projection_datatype: str = 'float32', projection_filetype: str = 'tiff', projection_headersize: int = 0, projection_byteorder: str = 'little', detector_coordinate_frame='OriginAtDetectorCenter.VerticalAxisRunningDownwards', detector_coordinate_dimension='Length', total_angle: float = None, scan_direction: str = 'CCW', matrices: list = None, volumename: str = None, bb_center_x: float = 0, bb_center_y: float = 0, bb_center_z: float = 0, voxels_x: int = None, voxels_y: int = None, voxels_z: int = None, voxelsize_x: float = None, voxelsize_y: float = None, voxelsize_z: float = None, bright_image_dir: str = None, bright_images: list = None, dark_image: str = None, bad_pixel_mask: str = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Create an OpenCT free trajectory CBCT configuration and optionally write to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geo</code></strong> :&ensp;<code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code></dt>
<dd>A geometry that should represent the CT setup at frame zero, as seen
by the reconstruction software.</dd>
<dt><strong><code>variant</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Which variant of the OpenCT file format is created.
Options: <code>"free"</code> and <code>"circular"</code>.</p>
<p>Standard value: <code>"free"</code></p>
</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Path and filename for the OpenCT configuration file to be written.
If no file should be written, set this to <code>None</code>.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>projection_files</code></strong> :&ensp;<code>list</code></dt>
<dd>List of projection file names.</dd>
<dt><strong><code>projection_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Path where the projection images are stored.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>flip_u</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Flip projection images horizontally before reconstruction?</p>
<p>Standard value: <code>False</code></p>
</dd>
<dt><strong><code>flip_v</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Flip projection images vertically before reconstruction?</p>
<p>Standard value: <code>False</code></p>
</dd>
<dt><strong><code>projection_datatype</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Data type of the projection images, as well as possible bright and dark
images and the bad pixel map.</p>
<p>Allowed values: <code>"uint8"</code>, <code>"uint16"</code>, <code>"uint32"</code>, <code>"int8"</code>, <code>"int16"</code>, <code>"int32"</code>, <code>"float32"</code></p>
<p>Standard value: <code>"float32"</code></p>
</dd>
<dt><strong><code>projection_filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>File type of the projection images, as well as possible bright and dark
images and the bad pixel map.</p>
<p>Allowed values: <code>"raw"</code> or <code>"tiff"</code></p>
<p>Standard value: <code>"tiff"</code></p>
</dd>
<dt><strong><code>projection_headersize</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>For RAW projection images: header size to skip (in bytes).</p>
<p>Standard value: <code>0</code></p>
</dd>
<dt><strong><code>projection_byteorder</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>For RAW projection images: endianness of the files.</p>
<p>Allowed values: <code>"little"</code> or <code>"big"</code></p>
<p>Standard value: <code>"little"</code></p>
</dd>
<dt><strong><code>detector_coordinate_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>A string that defines the orientation of the detector coordinate system
with respect to the projection images.</p>
<p>Possible values:</p>
<ul>
<li><code>"OriginAtDetectorCenter.VerticalAxisRunningUpwards"</code></li>
<li><code>"OriginAtDetectorCenter.VerticalAxisRunningDownwards"</code></li>
<li><code>"OriginAtDetectorTopLeftCorner"</code></li>
<li><code>"OriginAtDetectorBottomLeftCorner"</code></li>
</ul>
<p>Standard value: <code>"OriginAtDetectorCenter.VerticalAxisRunningDownwards"</code></p>
</dd>
<dt><strong><code>detector_coordinate_dimension</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>A string that defines the unit of the detector coordinate system.</p>
<p>Possible values:</p>
<ul>
<li><code>"Length"</code> for physical length units (usually mm).</li>
<li><code>"PixelCount"</code> if projection matrices refer to a pixel coordinate system.</li>
</ul>
<p>Standard value: <code>"Length"</code></p>
</dd>
<dt><strong><code>total_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Total angular range (in deg) of the CT scan. This parameter is only
really needed for the strict circular trajectory variant of the file
format, but not for free trajectories.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>scan_direction</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Direction of stage rotation, either <code>"CCW"</code> for counter-clockwise
or <code>"CW"</code> for clockwise rotation. Only relevant for circular
trajectory variant.</p>
<p>Standard value: <code>"CCW"</code></p>
</dd>
<dt><strong><code>matrices</code></strong> :&ensp;<code>list</code></dt>
<dd>
<p>List of projection matrices of type <code><a title="ctsimu.primitives.Matrix" href="primitives.html#ctsimu.primitives.Matrix">Matrix</a></code>.
One matrix for each projection image is required for the free trajectory
variant of the OpenCT file format. For the circular trajectory variant,
the matrices are not required.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>volumename</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Optional name for the reconstruction volume.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>bb_center_x</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Position (in x direction) of the reconstruction volume bounding box.
Center position in respect to the stage coordinate system.</p>
<p>Standard value: <code>0</code></p>
</dd>
<dt><strong><code>bb_center_y</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Position (in y direction) of the reconstruction volume bounding box.
Center position in respect to the stage coordinate system.</p>
<p>Standard value: <code>0</code></p>
</dd>
<dt><strong><code>bb_center_z</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Position (in z direction) of the reconstruction volume bounding box.
Center position in respect to the stage coordinate system.</p>
<p>Standard value: <code>0</code></p>
</dd>
<dt><strong><code>voxels_x</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of voxels in x direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixels.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxels_y</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of voxels in y direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixels.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxels_z</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of voxels in z direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixels.</p>
<p>For helix scans, this parameter should be increased because the
default voxel size in z direction corresponds to the detector height,
whereas a helix scan usually covers much more than the detector height.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxelsize_x</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Voxel size in x direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixel size
and magnification.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxelsize_y</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Voxel size in y direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixel size
and magnification.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>voxelsize_z</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Voxel size in z direction of the reconstruction volume.
Set to <code>None</code> for a default value based on the detector pixel size
and magnification.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>bright_image_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Optional directory where bright correction images are stored.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>bright_images</code></strong> :&ensp;<code>list</code></dt>
<dd>
<p>List of file names of bright correction images.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>dark_image</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Path to a dark correction image.</p>
<p>Standard value: <code>None</code></p>
</dd>
<dt><strong><code>bad_pixel_mask</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Path to a bad pixel mask for correction.</p>
<p>Standard value: <code>None</code></p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>openct_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary that represents the JSON structure of the OpenCT file.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.geometry.CoordinateSystem"><code class="flex name class">
<span>class <span class="ident">CoordinateSystem</span></span>
</code></dt>
<dd>
<div class="desc"><p>Coordinate system: center point and axis vectors.</p>
<p>The center and axis vectors are expressed in terms of the
object's reference coordinate system, which must be known implicitly
when objects of this class are used.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>The location of the center point in a reference
coordinate system (usually world or stage).</dd>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Basis vector for the u axis.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Basis vector for the v axis.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Basis vector for the w axis.</dd>
</dl>
<p>Initialized as a standard world coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoordinateSystem:
    &#34;&#34;&#34;Coordinate system: center point and axis vectors.

    The center and axis vectors are expressed in terms of the
    object&#39;s reference coordinate system, which must be known implicitly
    when objects of this class are used.

    Attributes
    ----------
    center : ctsimu.primitives.Vector
        The location of the center point in a reference
        coordinate system (usually world or stage).

    u : ctsimu.primitives.Vector
        Basis vector for the u axis.

    v : ctsimu.primitives.Vector
        Basis vector for the v axis.

    w : ctsimu.primitives.Vector
        Basis vector for the w axis.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialized as a standard world coordinate system.&#34;&#34;&#34;
        self.center = Vector(0, 0, 0)
        self.u      = Vector(1, 0, 0)
        self.v      = Vector(0, 1, 0)
        self.w      = Vector(0, 0, 1)

    def __str__(self):
        &#34;&#34;&#34;Information string for easy printing.&#34;&#34;&#34;
        txt  = &#34;Center: {}\n&#34;.format(self.center)
        txt += &#34;u:      {}\n&#34;.format(self.u)
        txt += &#34;v:      {}\n&#34;.format(self.v)
        txt += &#34;w:      {}\n&#34;.format(self.w)
        return txt

    def reset(self):
        &#34;&#34;&#34;Reset to a standard world coordinate system.&#34;&#34;&#34;
        self.center = Vector(0, 0, 0)
        self.u      = Vector(1, 0, 0)
        self.v      = Vector(0, 1, 0)
        self.w      = Vector(0, 0, 1)

    def make_unit_coordinate_system(self):
        &#34;&#34;&#34;Convert all basis vectors into unit vectors.&#34;&#34;&#34;
        self.u.make_unit_vector()
        self.v.make_unit_vector()
        self.w.make_unit_vector()
        self.update()

    def make_from_vectors(self, center:&#39;Vector&#39;, u:&#39;Vector&#39;, w:&#39;Vector&#39;):
        &#34;&#34;&#34;Create a right-handed coordinate system from the `center`,
        `u` vector (first basis vector) and `w` vector (third basis vector).
        The vector `v` will be determined from the cross product `w`×`u`.

        Parameters
        ----------
        center : ctsimu.primitives.Vector
            Object&#39;s center point in reference coordinate system,
            origin of local {u,v,w} coordinate system.

        u : ctsimu.primitives.Vector
            Basis vector u in terms of reference coordinate system.

        w : ctsimu.primitives.Vector
            Basis vector w in terms of reference coordinate system.

        Notes
        -----
        Basis vectors must be orthogonal.
        &#34;&#34;&#34;
        self.center  = center
        self.u = u
        self.w = w
        self.v = self.w.cross(self.u)

        self.update()

    def make(self, cx:float, cy:float, cz:float, ux:float, uy:float, uz:float, wx:float, wy:float, wz:float):
        &#34;&#34;&#34;Set up the coordinate system from vector components (all floats)
        for the center (`cx`, `cy`, `cz`), the `u` vector (first basis vector,
        `ux`, `uy`, `uz`) and the `w` vector (third basis vector, `wx`, `wy`, `wz`).

        Parameters
        ----------
        cx : float
            Center x coordinate.

        cy : float
            Center y coordinate.

        cz : float
            Center z coordinate.

        ux : float
            `u` vector x component.

        uy : float
            `u` vector y component.

        uz : float
            `u` vector z component.

        wx : float
            `w` vector x component.

        wy : float
            `w` vector y component.

        wz : float
            `w` vector z component.
        &#34;&#34;&#34;
        self.center = Vector(cx, cy, cz)
        self.u      = Vector(ux, uy, uz)
        self.w      = Vector(wx, wy, wz)
        self.v      = self.w.cross(self.u)

        self.update()

    def set_u_w(self, u:&#39;Vector&#39;, w:&#39;Vector&#39;):
        &#34;&#34;&#34;Set u and w vector, calculate v from cross product (right-handed).

        Parameters
        ----------
        u : ctsimu.primitives.Vector
            Basis vector for u direction.

        v : ctsimu.primitives.Vector
            Basis vector for v direction.
        &#34;&#34;&#34;
        self.u = u
        self.w = w
        self.v = w.cross(u)

    def get_copy(self) -&gt; &#39;CoordinateSystem&#39;:
        &#34;&#34;&#34;Get a copy of this coordinate system.

        Returns
        -------
        copy_cs : CoordinateSystem
            Copy of this coordinate system.
        &#34;&#34;&#34;
        new_cs = CoordinateSystem()
        new_cs.center = Vector(self.center.x(), self.center.y(), self.center.z())
        new_cs.u      = Vector(self.u.x(), self.u.y(), self.u.z())
        new_cs.v      = Vector(self.v.x(), self.v.y(), self.v.z())
        new_cs.w      = Vector(self.w.x(), self.w.y(), self.w.z())
        return new_cs

    def copy_cs(self, other:&#39;CoordinateSystem&#39;):
        &#34;&#34;&#34;Make this CoordinateSystem a copy of the `other` coordinate system.

        Parameters
        ----------
        other : CoordinateSystem
            Another coordinate system to copy.
        &#34;&#34;&#34;
        self.center = other.center.get_copy()
        self.u      = other.u.get_copy()
        self.v      = other.v.get_copy()
        self.w      = other.w.get_copy()

    def update(self):
        &#34;&#34;&#34;Signal a manual update to the center position or orientation vectors.&#34;&#34;&#34;
        self.center.update()
        self.u.update()
        self.v.update()
        self.w.update()

    def translate(self, translation_vector:&#39;Vector&#39;):
        &#34;&#34;&#34;Shift center by given translation vector.

        Parameters
        ----------
        translation_vector : ctsimu.primitives.Vector
            Vector by which the object&#39;s center point should be shifted.
            Its components are added to the center&#39;s components.
        &#34;&#34;&#34;
        self.center.add(translation_vector)

    def translate_in_direction(self, direction:&#39;Vector&#39;, distance:float):
        &#34;&#34;&#34;Shift center in given `direction` by given `distance`.

        Parameters
        ----------
        direction : ctsimu.primitives.Vector
            Vector along which the center point should be shifted.
            It must not be a unit vector.

        distance : float
            Distance by which the center point will travel
        &#34;&#34;&#34;
        t = direction.unit_vector().scaled(factor=distance)
        self.translate(translation_vector=t)

    def translate_x(self, dx:float):
        &#34;&#34;&#34;Translate coordinate system in x direction of reference
        coordinate system by distance `dx`.

        Parameters
        ----------
        dx : float
            Shift amount in x direction.
        &#34;&#34;&#34;
        self.center.set_x(self.center.x() + float(dx))

    def translate_y(self, dy: float):
        &#34;&#34;&#34;Translate coordinate system in y direction of reference
        coordinate system by distance `dy`.

        Parameters
        ----------
        dy : float
            Shift amount in y direction.
        &#34;&#34;&#34;
        self.center.set_y(self.center.y() + float(dy))

    def translate_z(self, dz: float):
        &#34;&#34;&#34;Translate coordinate system in z direction of reference
        coordinate system by distance `dz`.

        Parameters
        ----------
        dz : float
            Shift amount in z direction.
        &#34;&#34;&#34;
        self.center.set_z(self.center.z() + float(dz))

    def translate_u(self, du:float):
        &#34;&#34;&#34;Translate coordinate system in u direction by distance `du`.

        Parameters
        ----------
        du : float
            Shift amount in u direction.
        &#34;&#34;&#34;
        self.translate_in_direction(direction=self.u, distance=du)

    def translate_v(self, dv:float):
        &#34;&#34;&#34;Translate coordinate system in v direction by distance `dv`.

        Parameters
        ----------
        dv : float
            Shift amount in v direction.
        &#34;&#34;&#34;
        self.translate_in_direction(direction=self.v, distance=dv)

    def translate_w(self, dw:float):
        &#34;&#34;&#34;Translate coordinate system in w direction by distance `dw`.

        Parameters
        ----------
        dw : float
            Shift amount in w direction.
        &#34;&#34;&#34;
        self.translate_in_direction(direction=self.w, distance=dw)

    def rotate(self, axis:&#39;Vector&#39;, angle:float):
        &#34;&#34;&#34;Rotate coordinate system around a given axis by the given angle (in rad).

        This does not move the center point, as the axis vector is assumed
        to be attached to the center of the coordinate system.

        Parameters
        ----------
        axis : ctsimu.primitives.Vector
            The axis of rotation, in terms of the object&#39;s
            reference coordinate system.

        angle : float
            Rotation angle (in rad), mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        R = rotation_matrix(axis, angle)
        self.u.transform(R)
        self.v.transform(R)
        self.w.transform(R)

    def rotate_around_pivot_point(self, axis:&#39;Vector&#39;, angle:float, pivot:&#39;Vector&#39;):
        &#34;&#34;&#34;Rotate coordinate system around a pivot point.
        Generally, this will result in a different center position,
        as the axis of rotation is assumed to be attached to the
        pivot point instead of the center of the coordinate system.

        Parameters
        ----------
        axis : ctsimu.primitives.Vector
            Rotation axis, in terms of the object&#39;s reference coordinate system.

        angle : float
            Rotation angle (in rad).

        pivot : ctsimu.primitives.Vector
            Pivot point, in terms of the object&#39;s reference coordinate system.
        &#34;&#34;&#34;

        # Move coordinate system such that pivot point is at world origin:
        self.center.subtract(pivot)

        # Rotate center point and transform back into
        # world coordinate system:
        self.center.rotate(axis, angle)
        self.center.add(pivot)

        # Rotate the coordinate system itself:
        self.rotate(axis, angle)

    def rotate_around_x(self, angle: float):
        &#34;&#34;&#34;Rotate object around x axis of its reference coordinate system
        by given angle (in rad).

        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        if angle != 0:
            x_axis = Vector(1, 0, 0)
            self.rotate(x_axis, angle)

    def rotate_around_y(self, angle: float):
        &#34;&#34;&#34;Rotate object around y axis of its reference coordinate system
        by given angle (in rad).

        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        if angle != 0:
            y_axis = Vector(0, 1, 0)
            self.rotate(y_axis, angle)

    def rotate_around_z(self, angle: float):
        &#34;&#34;&#34;Rotate object around z axis of its reference coordinate system
        by given angle (in rad).

        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        if angle != 0:
            z_axis = Vector(0, 0, 1)
            self.rotate(z_axis, angle)

    def rotate_around_u(self, angle: float):
        &#34;&#34;&#34;Rotate object around its u axis by given angle (in rad).

        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.v.rotate(self.u, angle)
        self.w.rotate(self.u, angle)

    def rotate_around_v(self, angle: float):
        &#34;&#34;&#34;Rotate object around its v axis by given angle (in rad).

        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(self.v, angle)
        self.w.rotate(self.v, angle)

    def rotate_around_w(self, angle: float):
        &#34;&#34;&#34;Rotate object around its w axis by given angle (in rad).

        Parameters
        ----------
        angle : float
            Rotation angle in rad, mathematically positive direction (right-hand rule).
        &#34;&#34;&#34;
        self.u.rotate(self.w, angle)
        self.v.rotate(self.w, angle)

    def transform(self, cs_from:&#39;CoordinateSystem&#39;, cs_to:&#39;CoordinateSystem&#39;):
        &#34;&#34;&#34;Relative transformation in world coordinates
        from `cs_from` to `cs_to`, result will be in world coordinates.

        Assuming this CS, `cs_from` and `cs_to`
        all three are independent coordinate systems in a common
        reference coordinate system (e.g. world). This function
        will calculate the necessary translation and rotation that
        would have to be done to superimpose `cs_from` with `cs_to`.
        This translation and rotation will, however, be applied
        to this CS, not to `cs_from`.

        Parameters
        ----------
        cs_from : CoordinateSystem
            Coordinate system before the transformation.

        cs_to : CoordinateSystem
            Coordinate system after the transformation.
        &#34;&#34;&#34;

        # -- TRANSLATION:
        t = cs_from.center.to(cs_to.center)
        self.translate(t)

        # We need a copy of cs_from and cs_to because later on,
        # we might have to transform them and don&#39;t want to
        # affect the original cs_from passed to this function.
        # Also, cs_from or cs_to could simply be pointers to
        # this coordinate system.
        cs_fromCopy = cs_from.get_copy()
        cs_toCopy   = cs_to.get_copy()

        # -- ROTATIONS
        # Rotation to bring w axis from -&gt; to
        wFrom = cs_fromCopy.w
        wTo   = cs_toCopy.w
        rotationAxis = wFrom.cross(wTo)

        if rotationAxis.length() == 0:
            if wTo.dot(wFrom) &lt; 0:
                # 180° flip; vectors point in opposite direction.
                # Rotation axis is another CS basis vector.
                rotationAxis = cs_fromCopy.u.get_copy()
            else:
                # wFrom already points in direction of wTo.
                pass

        if rotationAxis.length() &gt; 0:
            rotationAngle = wFrom.angle(wTo)
            if rotationAngle != 0:
                self.rotate_around_pivot_point(rotationAxis, rotationAngle, cs_toCopy.center)

                # Also rotate `cs_from` to make calculation of
                # rotation around u axis possible (next step):
                cs_fromCopy.rotate(rotationAxis, rotationAngle)

        # Rotation to bring u axis from -&gt; to (around now fixed w axis)
        uFrom = cs_fromCopy.u
        uTo   = cs_toCopy.u
        rotationAxis = uFrom.cross(uTo)

        if rotationAxis.length() == 0:
            if uTo.dot(uFrom) &lt; 0:
                # 180° flip; vectors point in opposite direction.
                # Rotation axis is another CS basis vector.
                rotationAxis = cs_fromCopy.w.get_copy()
            else:
                # uFrom already points in direction of uTo.
                pass

        if rotationAxis.length() &gt; 0:
            rotationAngle = uFrom.angle(uTo)
            if rotationAngle != 0:
                self.rotate_around_pivot_point(rotationAxis, rotationAngle, cs_toCopy.center)

    def change_reference_frame(self, cs_from:&#39;CoordinateSystem&#39;, cs_to:&#39;CoordinateSystem&#39;):
        &#34;&#34;&#34;Change the object&#39;s reference coordinate system.

        Parameters
        ----------
        cs_from : CoordinateSystem
            Current reference coordinate system.

        cs_to : CoordinateSystem
            New reference coordinate system.

        Notes
        -----
        Both `cs_from` and `cs_to` must be in the same reference coordinate system
        (e.g., the world coordinate system).
        &#34;&#34;&#34;

        # Rotate basis vectors into cs_to:
        T = basis_transform_matrix(cs_from, cs_to)
        self.u.transform(T)
        self.v.transform(T)
        self.w.transform(T)

        self.center = change_reference_frame_of_point(self.center, cs_from, cs_to)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ctsimu.geometry.DetectorGeometry" href="#ctsimu.geometry.DetectorGeometry">DetectorGeometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.CoordinateSystem.change_reference_frame"><code class="name flex">
<span>def <span class="ident">change_reference_frame</span></span>(<span>self, cs_from: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>, cs_to: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the object's reference coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cs_from</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>Current reference coordinate system.</dd>
<dt><strong><code>cs_to</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>New reference coordinate system.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Both <code>cs_from</code> and <code>cs_to</code> must be in the same reference coordinate system
(e.g., the world coordinate system).</p></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.copy_cs"><code class="name flex">
<span>def <span class="ident">copy_cs</span></span>(<span>self, other: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Make this CoordinateSystem a copy of the <code>other</code> coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>Another coordinate system to copy.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.get_copy"><code class="name flex">
<span>def <span class="ident">get_copy</span></span>(<span>self) ‑> <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a copy of this coordinate system.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>copy_cs</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>Copy of this coordinate system.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>self, cx: float, cy: float, cz: float, ux: float, uy: float, uz: float, wx: float, wy: float, wz: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up the coordinate system from vector components (all floats)
for the center (<code>cx</code>, <code>cy</code>, <code>cz</code>), the <code>u</code> vector (first basis vector,
<code>ux</code>, <code>uy</code>, <code>uz</code>) and the <code>w</code> vector (third basis vector, <code>wx</code>, <code>wy</code>, <code>wz</code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cx</code></strong> :&ensp;<code>float</code></dt>
<dd>Center x coordinate.</dd>
<dt><strong><code>cy</code></strong> :&ensp;<code>float</code></dt>
<dd>Center y coordinate.</dd>
<dt><strong><code>cz</code></strong> :&ensp;<code>float</code></dt>
<dd>Center z coordinate.</dd>
<dt><strong><code>ux</code></strong> :&ensp;<code>float</code></dt>
<dd><code>u</code> vector x component.</dd>
<dt><strong><code>uy</code></strong> :&ensp;<code>float</code></dt>
<dd><code>u</code> vector y component.</dd>
<dt><strong><code>uz</code></strong> :&ensp;<code>float</code></dt>
<dd><code>u</code> vector z component.</dd>
<dt><strong><code>wx</code></strong> :&ensp;<code>float</code></dt>
<dd><code>w</code> vector x component.</dd>
<dt><strong><code>wy</code></strong> :&ensp;<code>float</code></dt>
<dd><code>w</code> vector y component.</dd>
<dt><strong><code>wz</code></strong> :&ensp;<code>float</code></dt>
<dd><code>w</code> vector z component.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.make_from_vectors"><code class="name flex">
<span>def <span class="ident">make_from_vectors</span></span>(<span>self, center: Vector, u: Vector, w: Vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a right-handed coordinate system from the <code>center</code>,
<code>u</code> vector (first basis vector) and <code>w</code> vector (third basis vector).
The vector <code>v</code> will be determined from the cross product <code>w</code>×<code>u</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Object's center point in reference coordinate system,
origin of local {u,v,w} coordinate system.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Basis vector u in terms of reference coordinate system.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Basis vector w in terms of reference coordinate system.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Basis vectors must be orthogonal.</p></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.make_unit_coordinate_system"><code class="name flex">
<span>def <span class="ident">make_unit_coordinate_system</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all basis vectors into unit vectors.</p></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset to a standard world coordinate system.</p></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, axis: Vector, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate coordinate system around a given axis by the given angle (in rad).</p>
<p>This does not move the center point, as the axis vector is assumed
to be attached to the center of the coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>The axis of rotation, in terms of the object's
reference coordinate system.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle (in rad), mathematically positive direction (right-hand rule).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate_around_pivot_point"><code class="name flex">
<span>def <span class="ident">rotate_around_pivot_point</span></span>(<span>self, axis: Vector, angle: float, pivot: Vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate coordinate system around a pivot point.
Generally, this will result in a different center position,
as the axis of rotation is assumed to be attached to the
pivot point instead of the center of the coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Rotation axis, in terms of the object's reference coordinate system.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle (in rad).</dd>
<dt><strong><code>pivot</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Pivot point, in terms of the object's reference coordinate system.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate_around_u"><code class="name flex">
<span>def <span class="ident">rotate_around_u</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its u axis by given angle (in rad).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate_around_v"><code class="name flex">
<span>def <span class="ident">rotate_around_v</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its v axis by given angle (in rad).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate_around_w"><code class="name flex">
<span>def <span class="ident">rotate_around_w</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its w axis by given angle (in rad).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate_around_x"><code class="name flex">
<span>def <span class="ident">rotate_around_x</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around x axis of its reference coordinate system
by given angle (in rad).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate_around_y"><code class="name flex">
<span>def <span class="ident">rotate_around_y</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around y axis of its reference coordinate system
by given angle (in rad).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.rotate_around_z"><code class="name flex">
<span>def <span class="ident">rotate_around_z</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around z axis of its reference coordinate system
by given angle (in rad).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad, mathematically positive direction (right-hand rule).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.set_u_w"><code class="name flex">
<span>def <span class="ident">set_u_w</span></span>(<span>self, u: Vector, w: Vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Set u and w vector, calculate v from cross product (right-handed).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Basis vector for u direction.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Basis vector for v direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, cs_from: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>, cs_to: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Relative transformation in world coordinates
from <code>cs_from</code> to <code>cs_to</code>, result will be in world coordinates.</p>
<p>Assuming this CS, <code>cs_from</code> and <code>cs_to</code>
all three are independent coordinate systems in a common
reference coordinate system (e.g. world). This function
will calculate the necessary translation and rotation that
would have to be done to superimpose <code>cs_from</code> with <code>cs_to</code>.
This translation and rotation will, however, be applied
to this CS, not to <code>cs_from</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cs_from</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>Coordinate system before the transformation.</dd>
<dt><strong><code>cs_to</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>Coordinate system after the transformation.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, translation_vector: Vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Shift center by given translation vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>translation_vector</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Vector by which the object's center point should be shifted.
Its components are added to the center's components.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate_in_direction"><code class="name flex">
<span>def <span class="ident">translate_in_direction</span></span>(<span>self, direction: Vector, distance: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Shift center in given <code>direction</code> by given <code>distance</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>direction</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Vector along which the center point should be shifted.
It must not be a unit vector.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance by which the center point will travel</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate_u"><code class="name flex">
<span>def <span class="ident">translate_u</span></span>(<span>self, du: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate coordinate system in u direction by distance <code>du</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>du</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in u direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate_v"><code class="name flex">
<span>def <span class="ident">translate_v</span></span>(<span>self, dv: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate coordinate system in v direction by distance <code>dv</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dv</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in v direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate_w"><code class="name flex">
<span>def <span class="ident">translate_w</span></span>(<span>self, dw: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate coordinate system in w direction by distance <code>dw</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dw</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in w direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate_x"><code class="name flex">
<span>def <span class="ident">translate_x</span></span>(<span>self, dx: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate coordinate system in x direction of reference
coordinate system by distance <code>dx</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in x direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate_y"><code class="name flex">
<span>def <span class="ident">translate_y</span></span>(<span>self, dy: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate coordinate system in y direction of reference
coordinate system by distance <code>dy</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in y direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.translate_z"><code class="name flex">
<span>def <span class="ident">translate_z</span></span>(<span>self, dz: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate coordinate system in z direction of reference
coordinate system by distance <code>dz</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in z direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.CoordinateSystem.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal a manual update to the center position or orientation vectors.</p></div>
</dd>
</dl>
</dd>
<dt id="ctsimu.geometry.DetectorGeometry"><code class="flex name class">
<span>class <span class="ident">DetectorGeometry</span></span>
</code></dt>
<dd>
<div class="desc"><p>Detector as geometrical object.</p>
<p>With additional attributes for the spatial extension and
the pixel coordinate system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pixels_u</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in u direction.</dd>
<dt><strong><code>pixels_v</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in v direction.</dd>
<dt><strong><code>pitch_u</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of a pixel in u direction.
In units of the reference coordinate system.</dd>
<dt><strong><code>pitch_v</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of a pixel in v direction.
In units of the reference coordinate system.</dd>
<dt><strong><code>phys_width</code></strong> :&ensp;<code>float</code></dt>
<dd>Physical size in u direction.
In units of the reference coordinate system.
Computed automatically after calling <code>set_size()</code>.</dd>
<dt><strong><code>phys_height</code></strong> :&ensp;<code>float</code></dt>
<dd>Physical size in v direction.
In units of the reference coordinate system.
Computed automatically after calling <code>set_size()</code>.</dd>
<dt><strong><code>pixel_origin</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Origin of the pixel coordinate system in terms of the reference
coordinate system. This is the outermost corner of the
(0,0) pixel of the detector (often the "upper left" corner).
Computed automatically after calling <code>set_size()</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Use <code>set_size()</code> to set the size of the detector, given its number of pixels
and the pitch. This function automatically computes the physical dimensions
<code>phys_width</code> and <code>phys_height</code> and the origin of the pixel coordinate system.</p>
<p>Initialize as a standard CoordinateSystem.</p>
<p>Orientation, position and size must be set up manually afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DetectorGeometry(CoordinateSystem):
    &#34;&#34;&#34;Detector as geometrical object.

    With additional attributes for the spatial extension and
    the pixel coordinate system.

    Attributes
    ----------
    pixels_u : int
        Number of pixels in u direction.

    pixels_v : int
        Number of pixels in v direction.

    pitch_u : float
        Size of a pixel in u direction.
        In units of the reference coordinate system.

    pitch_v : float
        Size of a pixel in v direction.
        In units of the reference coordinate system.

    phys_width : float
        Physical size in u direction.
        In units of the reference coordinate system.
        Computed automatically after calling `set_size()`.

    phys_height : float
        Physical size in v direction.
        In units of the reference coordinate system.
        Computed automatically after calling `set_size()`.

    pixel_origin : ctsimu.primitives.Vector
        Origin of the pixel coordinate system in terms of the reference
        coordinate system. This is the outermost corner of the
        (0,0) pixel of the detector (often the &#34;upper left&#34; corner).
        Computed automatically after calling `set_size()`.

    Notes
    -----
    Use `set_size()` to set the size of the detector, given its number of pixels
    and the pitch. This function automatically computes the physical dimensions
    `phys_width` and `phys_height` and the origin of the pixel coordinate system.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard CoordinateSystem.

        Orientation, position and size must be set up manually afterwards.
        &#34;&#34;&#34;

        # Call init from parent class:
        CoordinateSystem.__init__(self)

        self.pixels_u     = None  # Detector pixels in u direction
        self.pixels_v     = None  # Detector pixels in v direction
        self.pitch_u      = None  # Size of a pixel in u direction in units of reference coordinate system
        self.pitch_v      = None  # Size of a pixel in v direction in units of reference coordinate system
        self.phys_width   = 0     # Physical width in units of reference coordinate system
        self.phys_height  = 0     # Physical height in units of reference coordinate system

        self.pixel_origin = Vector()  # origin of pixel coordinate system in terms of reference coordinate system

    def get_copy(self):
        new_detector = DetectorGeometry()

        new_detector.center = Vector(self.center.x(), self.center.y(), self.center.z())
        new_detector.u      = Vector(self.u.x(), self.u.y(), self.u.z())
        new_detector.v      = Vector(self.v.x(), self.v.y(), self.v.z())
        new_detector.w      = Vector(self.w.x(), self.w.y(), self.w.z())

        new_detector.pixels_u     = self.pixels_u
        new_detector.pixels_v     = self.pixels_v
        new_detector.pitch_u      = self.pitch_u
        new_detector.pitch_v      = self.pitch_v
        new_detector.phys_width   = self.phys_width
        new_detector.phys_height  = self.phys_height
        new_detector.pixel_origin = self.pixel_origin.get_copy()

        return new_detector

    def size_is_set(self):
        if (self.pixels_u is None) or (self.pixels_v is None) or (self.pitch_u is None) or (self.pitch_v is None):
            return False

        return True

    def set_size(self, pixels_u:int = None, pixels_v:int = None, pitch_u:float = None, pitch_v:float = None):
        &#34;&#34;&#34;Set the physical size of the detector.

        From the given parameters (number of pixels and pitch), the physical
        size of the detector and the position of the origin of the pixel
        coordinate system will be calculated. Make sure that the orientation
        vectors and position of the detector are correct before calling
        `set_size()`, or call `compute_geometry_parameters()` if you update
        the detector orientation or position later on.

        Parameters
        ----------
        pixels_u : int
            Number of pixels in u direction.

        pixels_v : int
            Number of pixels in v direction.

        pitch_u : float
            Pixel pitch in u direction.

        pitch_v : float
            Pixel pitch in v direction.
        &#34;&#34;&#34;

        self.pixels_u = int(pixels_u)
        self.pixels_v = int(pixels_v)
        self.pitch_u = float(pitch_u)
        self.pitch_v = float(pitch_v)

        self.compute_geometry_parameters()

    def compute_geometry_parameters(self):
        &#34;&#34;&#34;Calculate the physical width and height, and the position of the
        pixel coordinate system origin.

        These calculations assume that the size, position and
        orientation of the detector are correctly set up.

        Results are assigned to their member variables (attributes).
        &#34;&#34;&#34;

        if self.size_is_set():
            # Physical width and height:
            self.phys_width  = self.pixels_u * self.pitch_u
            self.phys_height = self.pixels_v * self.pitch_v

            # Vectors of the detector coordinate system:
            ux = self.u.unit_vector().x()
            uy = self.u.unit_vector().y()
            uz = self.u.unit_vector().z()
            vx = self.v.unit_vector().x()
            vy = self.v.unit_vector().y()
            vz = self.v.unit_vector().z()

            # World coordinates of origin (0,0) of detector&#39;s pixel coordinate system:
            self.pixel_origin.set_x(self.center.x() - 0.5*(ux*self.phys_width + vx*self.phys_height))
            self.pixel_origin.set_y(self.center.y() - 0.5*(uy*self.phys_width + vy*self.phys_height))
            self.pixel_origin.set_z(self.center.z() - 0.5*(uz*self.phys_width + vz*self.phys_height))

    def cols(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector columns (i.e., pixels in u direction).

        Returns
        -------
        pixels_u : int
            Number of detector columns (i.e., pixels in u direction).
        &#34;&#34;&#34;
        return self.pixels_u

    def rows(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector rows (i.e., pixels in v direction).

        Returns
        -------
        pixels_v : int
            Number of detector rows (i.e., pixels in v direction).
        &#34;&#34;&#34;
        return self.pixels_v

    def pixel_vector(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector for given pixel coordinate.

        The pixel coordinate system has its origin at the detector corner with
        the lowest coordinate in terms of its u and v basis vectors. Typically,
        this is the upper left corner, but your arrangement may differ.

        Integer coordinates always refer to the pixel corner that is closest to
        the origin of the pixel coordinate system, whereas the center of a pixel
        therefore has a &#34;.5&#34; coordinate in the pixel coordinate system.
        For example, the first pixel (0, 0) would have center coordinates
        (0.5, 0.5).

        To get the center coordinates for a given integer pixel location,
        `pixel_vector_center()` may be used.

        Parameters
        ----------
        x : float
            x position in pixel coordinate system.

        y : float
            y position in pixel coordinate system.

        Returns
        -------
        pixel_vector : ctsimu.primitives.Vector
            Pixel position in reference coordinate system (usually world)
            as a 3D vector.
        &#34;&#34;&#34;

        # x, y are coordinates in pixel coordinates system
        px = self.pixel_origin.x() + self.u.x()*x*self.pitch_u + self.v.x()*y*self.pitch_v
        py = self.pixel_origin.y() + self.u.y()*x*self.pitch_u + self.v.y()*y*self.pitch_v
        pz = self.pixel_origin.z() + self.u.z()*x*self.pitch_u + self.v.z()*y*self.pitch_v
        pixel_vector = Vector(px, py, pz)
        return pixel_vector

    def pixel_vector_center(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector of pixel center, for a pixel given in integer coordinates.

        Parameters
        ----------
        x : float
            Integer x coordinate, specifies a pixel in the pixel coordinate system.

        y : float
            Integer y coordinate, specifies a pixel in the pixel coordinate system.

        Returns
        -------
        pixel_vector : ctsimu.primitives.Vector
            Position of the pixel center in the reference coordinate system
            (usually world) as a 3D vector.

        Notes
        -----
        If `float` coordinates are passed (non-integer),
        they are converted to integers using `math.floor`.
        &#34;&#34;&#34;
        return self.pixel_vector(float(math.floor(x))+0.5, float(math.floor(y))+0.5)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.DetectorGeometry.cols"><code class="name flex">
<span>def <span class="ident">cols</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of detector columns (i.e., pixels in u direction).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixels_u</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of detector columns (i.e., pixels in u direction).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.DetectorGeometry.compute_geometry_parameters"><code class="name flex">
<span>def <span class="ident">compute_geometry_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the physical width and height, and the position of the
pixel coordinate system origin.</p>
<p>These calculations assume that the size, position and
orientation of the detector are correctly set up.</p>
<p>Results are assigned to their member variables (attributes).</p></div>
</dd>
<dt id="ctsimu.geometry.DetectorGeometry.pixel_vector"><code class="name flex">
<span>def <span class="ident">pixel_vector</span></span>(<span>self, x: float, y: float) ‑> <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>World position vector for given pixel coordinate.</p>
<p>The pixel coordinate system has its origin at the detector corner with
the lowest coordinate in terms of its u and v basis vectors. Typically,
this is the upper left corner, but your arrangement may differ.</p>
<p>Integer coordinates always refer to the pixel corner that is closest to
the origin of the pixel coordinate system, whereas the center of a pixel
therefore has a ".5" coordinate in the pixel coordinate system.
For example, the first pixel (0, 0) would have center coordinates
(0.5, 0.5).</p>
<p>To get the center coordinates for a given integer pixel location,
<code>pixel_vector_center()</code> may be used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>x position in pixel coordinate system.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>y position in pixel coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixel_vector</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Pixel position in reference coordinate system (usually world)
as a 3D vector.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.DetectorGeometry.pixel_vector_center"><code class="name flex">
<span>def <span class="ident">pixel_vector_center</span></span>(<span>self, x: float, y: float) ‑> <a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>World position vector of pixel center, for a pixel given in integer coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Integer x coordinate, specifies a pixel in the pixel coordinate system.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Integer y coordinate, specifies a pixel in the pixel coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixel_vector</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Position of the pixel center in the reference coordinate system
(usually world) as a 3D vector.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If <code>float</code> coordinates are passed (non-integer),
they are converted to integers using <code>math.floor</code>.</p></div>
</dd>
<dt id="ctsimu.geometry.DetectorGeometry.rows"><code class="name flex">
<span>def <span class="ident">rows</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of detector rows (i.e., pixels in v direction).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixels_v</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of detector rows (i.e., pixels in v direction).</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.DetectorGeometry.set_size"><code class="name flex">
<span>def <span class="ident">set_size</span></span>(<span>self, pixels_u: int = None, pixels_v: int = None, pitch_u: float = None, pitch_v: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the physical size of the detector.</p>
<p>From the given parameters (number of pixels and pitch), the physical
size of the detector and the position of the origin of the pixel
coordinate system will be calculated. Make sure that the orientation
vectors and position of the detector are correct before calling
<code>set_size()</code>, or call <code>compute_geometry_parameters()</code> if you update
the detector orientation or position later on.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixels_u</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in u direction.</dd>
<dt><strong><code>pixels_v</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in v direction.</dd>
<dt><strong><code>pitch_u</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel pitch in u direction.</dd>
<dt><strong><code>pitch_v</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel pitch in v direction.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.DetectorGeometry.size_is_set"><code class="name flex">
<span>def <span class="ident">size_is_set</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></b></code>:
<ul class="hlist">
<li><code><a title="ctsimu.geometry.CoordinateSystem.change_reference_frame" href="#ctsimu.geometry.CoordinateSystem.change_reference_frame">change_reference_frame</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.copy_cs" href="#ctsimu.geometry.CoordinateSystem.copy_cs">copy_cs</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.get_copy" href="#ctsimu.geometry.CoordinateSystem.get_copy">get_copy</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.make" href="#ctsimu.geometry.CoordinateSystem.make">make</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.make_from_vectors" href="#ctsimu.geometry.CoordinateSystem.make_from_vectors">make_from_vectors</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.make_unit_coordinate_system" href="#ctsimu.geometry.CoordinateSystem.make_unit_coordinate_system">make_unit_coordinate_system</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.reset" href="#ctsimu.geometry.CoordinateSystem.reset">reset</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate" href="#ctsimu.geometry.CoordinateSystem.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_pivot_point" href="#ctsimu.geometry.CoordinateSystem.rotate_around_pivot_point">rotate_around_pivot_point</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_u" href="#ctsimu.geometry.CoordinateSystem.rotate_around_u">rotate_around_u</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_v" href="#ctsimu.geometry.CoordinateSystem.rotate_around_v">rotate_around_v</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_w" href="#ctsimu.geometry.CoordinateSystem.rotate_around_w">rotate_around_w</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_x" href="#ctsimu.geometry.CoordinateSystem.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_y" href="#ctsimu.geometry.CoordinateSystem.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_z" href="#ctsimu.geometry.CoordinateSystem.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.set_u_w" href="#ctsimu.geometry.CoordinateSystem.set_u_w">set_u_w</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.transform" href="#ctsimu.geometry.CoordinateSystem.transform">transform</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate" href="#ctsimu.geometry.CoordinateSystem.translate">translate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_in_direction" href="#ctsimu.geometry.CoordinateSystem.translate_in_direction">translate_in_direction</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_u" href="#ctsimu.geometry.CoordinateSystem.translate_u">translate_u</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_v" href="#ctsimu.geometry.CoordinateSystem.translate_v">translate_v</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_w" href="#ctsimu.geometry.CoordinateSystem.translate_w">translate_w</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_x" href="#ctsimu.geometry.CoordinateSystem.translate_x">translate_x</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_y" href="#ctsimu.geometry.CoordinateSystem.translate_y">translate_y</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_z" href="#ctsimu.geometry.CoordinateSystem.translate_z">translate_z</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.update" href="#ctsimu.geometry.CoordinateSystem.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ctsimu.geometry.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
</code></dt>
<dd>
<div class="desc"><p>Geometry information about the complete CT setup.</p>
<p>Keeps the source, stage and detector in one bundle and provides methods
to calculate geometry parameters and projection matrices.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>detector</code></strong> :&ensp;<code><a title="ctsimu.geometry.DetectorGeometry" href="#ctsimu.geometry.DetectorGeometry">DetectorGeometry</a></code></dt>
<dd>The detector geometry.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The source geometry.</dd>
<dt><strong><code>stage</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The stage geometry.</dd>
<dt><strong><code>SDD</code></strong> :&ensp;<code>float</code></dt>
<dd>Shortest distance between source center and detector plane.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>SOD</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance between source center and stage center.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>ODD</code></strong> :&ensp;<code>float</code></dt>
<dd>Shortest distance between stage center and detector plane.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>brightest_spot_world</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Location of the intensity maximum on the detector, in world coordinates.
Assuming an isotropically radiating source.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>brightest_spot_detector</code></strong> :&ensp;<code><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></code></dt>
<dd>Location of the intensity maximum on the detector, in terms of
detector coordinate system. Assuming an isotropically radiating source.
Calculated automatically by <code>update()</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry:
    &#34;&#34;&#34;Geometry information about the complete CT setup.

    Keeps the source, stage and detector in one bundle and provides methods
    to calculate geometry parameters and projection matrices.

    Attributes
    ----------
    detector : DetectorGeometry
        The detector geometry.

    source : CoordinateSystem
        The source geometry.

    stage : CoordinateSystem
        The stage geometry.

    SDD : float
        Shortest distance between source center and detector plane.
        Calculated automatically by `update()`.

    SOD : float
        Distance between source center and stage center.
        Calculated automatically by `update()`.

    ODD : float
        Shortest distance between stage center and detector plane.
        Calculated automatically by `update()`.

    brightest_spot_world : ctsimu.primitives.Vector
        Location of the intensity maximum on the detector, in world coordinates.
        Assuming an isotropically radiating source.
        Calculated automatically by `update()`.

    brightest_spot_detector : ctsimu.primitives.Vector
        Location of the intensity maximum on the detector, in terms of
        detector coordinate system. Assuming an isotropically radiating source.
        Calculated automatically by `update()`.
    &#34;&#34;&#34;

    def __init__(self):
        self.detector    = DetectorGeometry()
        self.source      = CoordinateSystem()
        self.stage       = CoordinateSystem()

        # Backup geometry after calling store():
        self._detector_stored = None
        self._source_stored   = None
        self._stage_stored    = None

        # Initialize source and detector to standard CTSimU orientation:
        self.detector.u = Vector(0, -1,  0)
        self.detector.v = Vector(0,  0, -1)
        self.detector.w = Vector(1,  0,  0)
        self.source.u   = Vector(0, -1,  0)
        self.source.v   = Vector(0,  0, -1)
        self.source.w   = Vector(1,  0,  0)

        self.SDD = None
        self.SOD = None
        self.ODD = None
        self.brightest_spot_world = None
        self.brightest_spot_detector = None

    def __str__(self):
        return self.info()

    def update(self):
        &#34;&#34;&#34;Calculate derived geometry parameters.

        Calculates the SOD, SDD, ODD, and location of the intensity maximum
        on the detector (in world and detector coordinates) for the
        curent geometry. Results are stored in the following member variables
        (attributes).

        SDD: Shortest distance between source center and detector plane.

        SOD: Distance between source center and stage center.

        ODD: Shortest distance between stage center and detector plane.

        brightest_spot_world: Location of the intensity maximum on the detector,
            in world coordinates.  Assuming an isotropically radiating source.

        brightest_spot_detector: Location of the intensity maximum on the
            detector, in terms of detector coordinate system.
            Assuming an isotropically radiating source.
        &#34;&#34;&#34;

        self.source.update()
        self.stage.update()
        self.detector.update()

        # SOD, SDD, ODD
        world = CoordinateSystem()
        source_from_image = copy.deepcopy(self.source)
        stage_from_detector  = copy.deepcopy(self.stage)

        source_from_image.change_reference_frame(world, self.detector)
        stage_from_detector.change_reference_frame(world, self.detector)

        self.SDD = abs(source_from_image.center.z())
        self.ODD = abs(stage_from_detector.center.z())
        self.SOD = self.source.center.distance(self.stage.center)

        ## Brightest Spot in World Coordinate System:
        self.brightest_spot_world = copy.deepcopy(self.detector.w)
        self.brightest_spot_world.scale(self.SDD)
        self.brightest_spot_world.add(self.source.center)

        ## Brightest Spot in Detector Coordinate System:
        self.brightest_spot_detector = copy.deepcopy(self.brightest_spot_world)
        self.brightest_spot_detector.subtract(self.detector.center)

        pxU = 0
        pxV = 0

        if (self.detector.pitch_u != 0) and (self.detector.pitch_u is not None):
            if self.detector.cols() is not None:
                pxU = self.brightest_spot_detector.dot(self.detector.u) / self.detector.pitch_u + self.detector.cols()/2.0


        if (self.detector.pitch_v != 0) and (self.detector.pitch_v is not None):
            if self.detector.rows() is not None:
                pxV = self.brightest_spot_detector.dot(self.detector.v) / self.detector.pitch_v + self.detector.rows()/2.0


        self.brightest_spot_detector = Vector(pxU, pxV, 0)

        self.detector.compute_geometry_parameters()

    def store(self):
        &#34;&#34;&#34;Store the current configuration in a backup buffer.

        The primary purpose of this function is to create a backup
        of the initial configuration, which can then always be recovered
        by a call of `Geometry.restore()`. This allows the simulation of a
        parameterized scan trajectory where each step&#39;s (or frame&#39;s)
        configuration is deterministically calculated from the initial state,
        rather than using incremental changes which could lead to the
        accumulation of rounding inaccuracies.
        &#34;&#34;&#34;
        self._source_stored   = copy.deepcopy(self.source)
        self._detector_stored = copy.deepcopy(self.detector)
        self._stage_stored    = copy.deepcopy(self.stage)

    def restore(self):
        &#34;&#34;&#34;Restore the configuration that has been saved by `Geometry.store()`.&#34;&#34;&#34;

        if self._source_stored is not None:
            self.source = copy.deepcopy(self._source_stored)

        if self._detector_stored is not None:
            self.detector = copy.deepcopy(self._detector_stored)

        if self._stage_stored is not None:
            self.stage = copy.deepcopy(self._stage_stored)

        self.update()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Generate an information string about the current geometry.

        Returns
        -------
        txt : string
            Information string for humans.
        &#34;&#34;&#34;

        self.update()

        txt  = &#34;Detector\n&#34;
        txt += &#34;===================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.detector.center)
        txt += &#34;u:               {}\n&#34;.format(self.detector.u)
        txt += &#34;v:               {}\n&#34;.format(self.detector.v)
        txt += &#34;w:               {}\n&#34;.format(self.detector.w)
        txt += &#34;Pixels:          {cols} x {rows}\n&#34;.format(cols=self.detector.cols(), rows=self.detector.rows())
        txt += &#34;Pitch:           {pitch_u} x {pitch_v}\n&#34;.format(pitch_u=self.detector.pitch_u, pitch_v=self.detector.pitch_v)
        txt += &#34;Physical Size:   {width} x {height}\n&#34;.format(width=self.detector.phys_width, height=self.detector.phys_height)

        txt += &#34;Brightest Spot:\n&#34;
        txt += &#34;  World:         {}\n&#34;.format(self.brightest_spot_world)
        txt += &#34;  Pixels:        {}\n&#34;.format(self.brightest_spot_detector)

        txt += &#34;\n&#34;
        txt += &#34;Source\n&#34;
        txt += &#34;===================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.source.center)
        txt += &#34;u:               {}\n&#34;.format(self.source.u)
        txt += &#34;v:               {}\n&#34;.format(self.source.v)
        txt += &#34;w:               {}\n&#34;.format(self.source.w)

        txt += &#34;\n&#34;
        txt += &#34;Stage\n&#34;
        txt += &#34;===================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.stage.center)
        txt += &#34;u:               {}\n&#34;.format(self.stage.u)
        txt += &#34;v:               {}\n&#34;.format(self.stage.v)
        txt += &#34;w:               {}\n&#34;.format(self.stage.w)

        txt += &#34;\n&#34;
        txt += &#34;Geometry Parameters\n&#34;
        txt += &#34;===================\n&#34;
        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        txt += &#34;SDD:             {}\n&#34;.format(self.SDD)
        txt += &#34;ODD:             {}\n&#34;.format(self.ODD)
        txt += &#34;SOD:             {}\n&#34;.format(self.SOD)

        return txt

    def get_CERA_standard_circular_parameters(self, start_angle:float=0) -&gt; dict:
        &#34;&#34;&#34;Calculate all parameters for an ideal circular trajectory
        reconstruction in CERA without projection matrices.

        These can be added to the reconstruction config file for CERA.

        Parameters
        ----------
        start_angle : float
            Reconstruction start angle (in degrees). The start angle can be
            tuned to change the in-plane rotation of the reconstruction images.
            Depending on the current stage rotation in this geometry, the
            start angle will be adjusted. Consider this parameter more like
            an offset to the start angle of stage rotation.

        Returns
        -------
        cera_parameters : dict
            The dictionary contains the following keys:

            + `&#34;R&#34;`: CERA&#39;s source-object distance (SOD)

            + `&#34;D&#34;`: CERA&#39;s source-detector distance (SDD)

            + `&#34;ODD&#34;`: object-detector distance (ODD = SDD - SOD)

            + `&#34;a&#34;`: CERA&#39;s a tilt

            + `&#34;b&#34;`: CERA&#39;s b tilt

            + `&#34;c&#34;`: CERA&#39;s c tilt

            + `&#34;u0&#34;`: Detector u offset (px)

            + `&#34;v0&#34;`: Detector v offset (px)

            + `&#34;start_angle&#34;`

            + `&#34;volume_midpoint&#34;`: dict

                - `&#34;x&#34;`, `&#34;y&#34;` and `&#34;z&#34;`

            + `&#34;voxelsize&#34;`: dict

                - `&#34;x&#34;`, `&#34;y&#34;` and `&#34;z&#34;`
        &#34;&#34;&#34;

        cera_detector = self.detector.get_copy()

        # Number and size of pixels:
        nu  = cera_detector.pixels_u
        nv  = cera_detector.pixels_v
        psu = cera_detector.pitch_u
        psv = cera_detector.pitch_v

        # Default number of voxels for the reconstruction volume
        # is based on the detector size:
        n_voxels_x = nu
        n_voxels_y = nu
        n_voxels_z = nv

        # CERA&#39;s detector CS has its origin in the lower left corner instead of the center.
        # Let&#39;s move there:
        half_width  = psu*nu / 2.0
        half_height = psv*nv / 2.0

        cera_detector.center -= cera_detector.u.scaled(half_width) # add half a pixel in u direction??
        cera_detector.center += cera_detector.v.scaled(half_height) # subtract half a pixel in v direction??

        # The v axis points up instead of down:
        cera_detector.rotate_around_u(angle=math.pi)

        # Construct the CERA world coordinate system:
        # --------------------------------------------------
        # z axis points in v direction of our detector CS:
        cera_z = cera_detector.v.get_copy()
        cera_z.make_unit_vector()

        z0 = cera_z.x()
        z1 = cera_z.y()
        z2 = cera_z.z()

        O0 = self.stage.center.x()
        O1 = self.stage.center.y()
        O2 = self.stage.center.z()

        S0 = self.source.center.x()
        S1 = self.source.center.y()
        S2 = self.source.center.z()

        w0 = self.stage.w.x()
        w1 = self.stage.w.y()
        w2 = self.stage.w.z()

        # x axis points from source to stage (inverted), and perpendicular to cera_z (det v):
        t = -(z0*(O0-S0) + z1*(O1-S1) + z2*(O2-S2))/(z0*w0 + z1*w1 + z2*w2)
        d = self.source.center.distance(self.stage.center)
        SOD = math.sqrt(d*d - t*t)

        if SOD &gt; 0:
            x0 = -(O0 - S0 + t*w0)/SOD
            x1 = -(O1 - S1 + t*w1)/SOD
            x2 = -(O2 - S2 + t*w2)/SOD
        else:
            # SOD == 0
            x0 = -1
            x1 = 0
            x2 = 0

        cera_x = Vector(x0, x1, x2)
        cera_x.make_unit_vector()

        cs_CERA = CoordinateSystem()
        cs_CERA.center = self.source.center.get_copy()
        cs_CERA.set_u_w(cera_x, cera_z)

        stage_in_CERA    = self.stage.get_copy()
        detector_in_CERA = cera_detector.get_copy()
        source_in_CERA   = self.source.get_copy()

        stage_in_CERA.change_reference_frame(ctsimu_world, cs_CERA)
        detector_in_CERA.change_reference_frame(ctsimu_world, cs_CERA)
        source_in_CERA.change_reference_frame(ctsimu_world, cs_CERA)

        # Source:
        xS = source_in_CERA.center.x()
        yS = source_in_CERA.center.y()
        zS = source_in_CERA.center.z()

        # Stage:
        xO = stage_in_CERA.center.x()
        yO = stage_in_CERA.center.y()
        zO = stage_in_CERA.center.z()
        uO = stage_in_CERA.u.unit_vector()
        vO = stage_in_CERA.v.unit_vector()
        wO = stage_in_CERA.w.unit_vector()

        # Detector:
        xD = detector_in_CERA.center.x()
        yD = detector_in_CERA.center.y()
        zD = detector_in_CERA.center.z()
        uD = detector_in_CERA.u.unit_vector()
        vD = detector_in_CERA.v.unit_vector()
        wD = detector_in_CERA.w.unit_vector()

        # Detector normal:
        nx = wD.x()
        ny = wD.y()
        nz = wD.z()

        # Intersection of CERA&#39;s x axis with the stage rotation axis = ceraVolumeMidpoint (new center of stage)
        xaxis = Vector(SOD, 0, 0)
        cera_volume_midpoint = source_in_CERA.center.get_copy()
        cera_volume_midpoint.subtract(xaxis)

        if xaxis.length() != 0:
            xaxis.make_unit_vector()

        world_volume_midpoint = change_reference_frame_of_point(cera_volume_midpoint, cs_CERA, ctsimu_world)

        cera_volume_relative_midpoint = cera_volume_midpoint.to(stage_in_CERA.center)
        midpoint_x = cera_volume_relative_midpoint.x()
        midpoint_y = cera_volume_relative_midpoint.y()
        midpoint_z = cera_volume_relative_midpoint.z()

        c = uD.x()   # x component of detector u vector is c-tilt
        a = wO.x()   # x component of stage w vector is a-tilt
        b = wO.y()   # y component of stage w vector is b-tilt

        # Intersection of x axis with detector (in px):
        efoc_x = xaxis.x() # 1
        efoc_y = xaxis.y() # 0
        efoc_z = xaxis.z() # 0

        E = nx*xD + ny*yD + nz*zD
        dv = nx*efoc_x + ny*efoc_y + nz*efoc_z

        if dv &gt; 0:
            SDD_cera = abs((E - xS*nx - yS*ny - zS*nz)/dv)
        else:
            SDD_cera = 1

        SOD_cera = source_in_CERA.center.distance(cera_volume_midpoint)

        if SDD_cera != 0:
            voxelsize_u = psu * SOD_cera / SDD_cera
            voxelsize_v = psv * SOD_cera / SDD_cera
        else:
            voxelsize_u = 1
            voxelsize_v = 1

        # Intersection point of principal ray with detector:
        detector_intersection_point = xaxis.get_copy()
        detector_intersection_point.scale(-SDD_cera)

        stage_on_detector = detector_in_CERA.center.to(detector_intersection_point)
        ufoc = stage_on_detector.dot(uD)
        vfoc = stage_on_detector.dot(vD)
        wfoc = stage_on_detector.dot(wD)

        if psu &gt; 0:
            ufoc_px = ufoc / psu
        else:
            ufoc_px = 0

        if psv &gt; 0:
            vfoc_px = vfoc / psv
        else:
            vfoc_px = 0

        offset_u = ufoc_px - 0.5
        offset_v = vfoc_px - 0.5

        # Detector rotation relative to stage:
        cera_x = Vector(1, 0, 0)
        cera_y = Vector(0, 1, 0)
        cera_x.scale(vO.dot(cera_x))
        cera_y.scale(vO.dot(cera_y))

        v_in_xy_plane = cera_x.get_copy()
        v_in_xy_plane.add(cera_y)

        rot = v_in_xy_plane.angle(cera_y)

        # Add this start angle to the user-defined start angle:
        start_angle += (180.0 - math.degrees(rot))

        cera_parameters = {
            &#34;R&#34;: SOD_cera,
            &#34;D&#34;: SDD_cera,
            &#34;ODD&#34;: SDD_cera - SOD_cera,
            &#34;a&#34;: a,
            &#34;b&#34;: b,
            &#34;c&#34;: c,
            &#34;u0&#34;: offset_u,
            &#34;v0&#34;: offset_v,
            &#34;start_angle&#34;: start_angle,
            &#34;volume_midpoint&#34;: {
                &#34;x&#34;: midpoint_x,
                &#34;y&#34;: midpoint_y,
                &#34;z&#34;: midpoint_z
            },
            &#34;voxels&#34;: {
                &#34;x&#34;: n_voxels_x,
                &#34;y&#34;: n_voxels_y,
                &#34;z&#34;: n_voxels_z
            },
            &#34;voxelsize&#34;: {
                &#34;x&#34;: voxelsize_u,
                &#34;y&#34;: voxelsize_u,
                &#34;z&#34;: voxelsize_v
            }
        }

        return cera_parameters

    def projection_matrix(self,
                         volumeCS:CoordinateSystem=None,
                         imageCS:CoordinateSystem=None,
                         mode:str=None):
        &#34;&#34;&#34;Calculate a projection matrix for the current geometry.

        Parameters
        ----------
        volumeCS : CoordinateSystem, optional
            Position of the volume coordinate system in terms of the
            stage coordinate system. If `None` is given, the volume
            coordinate system is assumed to be the stage coordinate system.
            See notes for details.

        imageCS : CoordinateSystem, optional
            Position of the image coordinate system in terms of the
            detector coordinate system. If `None` is given, the image
            coordinate system is assumed to be the detector coordinate system.
            See notes for details.

        mode : str, optional
            Pre-defined modes. Either `&#34;OpenCT&#34;` or `&#34;CERA&#34;` are supported.
            They override the `volumeCS` and `imageCS`, which can be set
            to `None` when using one of the pre-defined modes.

        Returns
        -------
        P : ctsimu.primitives.Matrix
            Projection matrix.

        Notes
        -----
        The image coordinate system (`imageCS`) should match the location,
        scale and orientation used by the reconstruction software, and is
        expressed in terms of the detector coordinate system.

        The detector coordinate system has its origin at the detector `center`,
        the `u` unit vector points in the row vector direction, and the
        `v` unit vector points in column vector direction (they are always
        assumed to be unit vectors).

        The `center` (origin) of the `imageCS` should be where the reconstruction
        software places the origin of its own projection image coordinate
        system. For example, CERA places it at the center of the lower-left
        pixel of the projection image.

        Similarly, a volume coordinate system (`volumeCS`) can be provided
        that describes the location, scale and orientation of the reconstruction
        volume with respect to the stage coordinate system.

        If the reconstruction software expects a different unit for the image
        or volume coordinate system (e.g. mm or voxels) than the world
        coordinates (e.g. mm), you can scale the basis vectors accordingly.
        For example, if you need a pixel and voxel coordinate system instead
        of a millimeter coordinate system, scale the basis vectors by the
        respective pixel and voxel size:

        ```python
        imageCS.u.scale(pixelSize_u)
        imageCS.v.scale(pixelSize_v)
        imageCS.w.scale(1.0) # Do not scale the detector normal!

        volumeCS.u.scale(voxelSize_u)
        volumeCS.v.scale(voxelSize_v)
        volumeCS.w.scale(voxelSize_w)
        ```
        &#34;&#34;&#34;

        validModes = [&#34;openct&#34;, &#34;cera&#34;]

        if mode is not None:
            if mode.lower() in validModes:  # Override imageCS
                image = CoordinateSystem()
                volume = CoordinateSystem()

                if mode.lower() == &#34;openct&#34;:
                    &#34;&#34;&#34;OpenCT places the origin of the image CS at the detector
                    center. The constructor places it at (0,0,0) automatically,
                    so there is nothing to do. Comments for illustration.&#34;&#34;&#34;
                    # image.center.set_x(0)
                    # image.center.set_y(0)
                    # image.center.set_z(0)

                    &#34;&#34;&#34;OpenCT&#39;s image CS is in mm units. We assume that all
                    other coordinate systems are in mm as well here (at least
                    when imported from JSON file). No scaling of the basis vectors is necessary.&#34;&#34;&#34;
                    # image.u.scale(1.0)
                    # image.v.scale(1.0)
                    # image.w.scale(1.0)

                    volume.w.invert() # mirror reconstruction volume

                elif mode.lower() == &#34;cera&#34;:
                    if self.detector.size_is_set():
                        &#34;&#34;&#34;CERA places the origin of the image CS in the center
                        of the lower left pixel of the projection image.&#34;&#34;&#34;
                        image.center.set_x(-self.detector.phys_width  / 2.0 + 0.5*self.detector.pitch_u)
                        image.center.set_y( self.detector.phys_height / 2.0 - 0.5*self.detector.pitch_v)
                        # image.center.set_z(0)

                        &#34;&#34;&#34;CERA&#39;s unit of the image CS is in px, so we need to
                        scale the image CS basis vectors by the pixel size.
                        Also, v points up instead of down.&#34;&#34;&#34;
                        image.u.scale( self.detector.pitch_u)
                        image.v.scale(-self.detector.pitch_v)

                        volume.w.invert() # mirror reconstruction volume
                    else:
                        raise RuntimeError(&#34;Detector size not set. To calculate a projection matrix for CERA, you need to set the size of the detector. Use the set_size() function of your detector object.&#34;)
            else:
                raise RuntimeError(&#34;Unsupported mode for projection matrix: \&#34;{}\&#34;&#34;.format(mode))
        else:
            if imageCS is not None:
                image = copy.deepcopy(imageCS)
            else:
                # Set a standard coordinate system. Results in pure
                # detector coordinate system after transformation.
                image = CoordinateSystem()

            if volumeCS is not None:
                volume = copy.deepcopy(volumeCS)
            else:
                # Set a standard coordinate system. Results in pure
                # stage coordinate system after transformation.
                volume = CoordinateSystem()

        source = copy.deepcopy(self.source)

        # Detach the image CS from the detector CS and
        # express it in terms of the world CS:
        image.change_reference_frame(self.detector, ctsimu_world)

        # Detach the volume CS from the stage CS and
        # express it in terms of the world CS:
        volume.change_reference_frame(self.stage, ctsimu_world)

        &#34;&#34;&#34;The volume scale factors are derived from the lengths of the basis
        vectors of the volume CS .&#34;&#34;&#34;
        scale_volume_u = volume.u.length()
        scale_volume_v = volume.v.length()
        scale_volume_w = volume.w.length()

        &#34;&#34;&#34;The image scale factors are derived from the lengths of the basis
        vectors of the image CS.&#34;&#34;&#34;
        scale_image_u = image.u.length()
        scale_image_v = image.v.length()
        scale_image_w = image.w.length()

        # Save a source CS as seen from the detector CS. This is convenient to
        # later get the SDD, ufoc and vfoc:
        source_from_image = copy.deepcopy(self.source)
        source_from_image.change_reference_frame(ctsimu_world, image)

        # Make the volume CS the new world CS:
        source.change_reference_frame(ctsimu_world, volume)
        image.change_reference_frame(ctsimu_world, volume)
        volume.change_reference_frame(ctsimu_world, volume)

        # Translation vector from volume to source:
        xfoc = source.center.x()
        yfoc = source.center.y()
        zfoc = source.center.z()

        # Focus point on detector: principal, perpendicular ray.
        # In the detector coordinate system, ufoc and vfoc are the u and v coordinates
        # of the source center; SDD (perpendicular to detector plane) is source w coordinate.
        ufoc = source_from_image.center.x() / scale_image_u
        vfoc = source_from_image.center.y() / scale_image_v
        SDD  = abs(source_from_image.center.z())

        # Scale: volume units -&gt; world units,
        # move origin to source (the origin of the camera CS)
        A = Matrix(values=[
            [scale_volume_u, 0, 0, xfoc],
            [0, scale_volume_v, 0, yfoc],
            [0, 0, scale_volume_w, zfoc]
        ])

        # Rotations:
        R = basis_transform_matrix(volume, image)

        # Projection onto detector and scaling (world units -&gt; image units)
        # and shift in detector CS: (ufoc and vfoc must be in scaled units)
        S = Matrix(values=[
            [SDD/scale_image_u, 0, ufoc/scale_image_w],
            [0, SDD/scale_image_v, vfoc/scale_image_w],
            [0, 0, 1.0/scale_image_w]
        ])

        # Multiply all together:
        P = S * (R * A)

        # Renormalize:
        lower_right = P.get(col=3, row=2)
        if lower_right != 0:
            P.scale(1.0/lower_right)
            P.set(col=3, row=2, value=1.0) # avoids rounding issues

        return P

    def create_detector_flat_field_rays(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction. &#34;&#34;&#34;
        width      = self.detector.cols()
        height     = self.detector.rows()
        pixelSizeU = self.detector.pitch_u
        pixelSizeV = self.detector.pitch_v

        if(width is None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height is None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeU is None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeV is None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x()
        dy = self.detector.center.y()
        dz = self.detector.center.z()

        sx = self.source.center.x()
        sy = self.source.center.y()
        sz = self.source.center.z()

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x()
        uy = self.detector.u.y()
        uz = self.detector.u.z()

        vx = self.detector.v.x()
        vy = self.detector.v.y()
        vz = self.detector.v.z()

        wx = self.detector.w.x()
        wy = self.detector.w.y()
        wz = self.detector.w.z()


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        log(&#34;Geometry definition from JSON file:\n\
   Detector Angle:    {}\n\
   Detector Distance: {}\n\
   SDD:               {}\n\
   Pixels U:          {}\n\
   Pixels V:          {}\n\
   Pitch U:           {}\n\
   Pitch V:           {}\n\
   Source:            {}, {}, {}\n\
   Detector:          {}, {}, {}\n\
   Connection Vector: {}, {}, {}\n\
   Detector Vector U: {}, {}, {}\n\
   Detector Vector V: {}, {}, {}\n\
   Detector Vector W: {}, {}, {}&#34;.format(alpha, dist, SDD, width, height, pixelSizeU, pixelSizeV, sx, sy, sz, dx, dy, dz, connectionLine.x(), connectionLine.y(), connectionLine.z(), ux, uy, uz, vx, vy, vz, wx, wy, wz))

        maxIntensity = 0
        maxX = 0
        maxY = 0
        minDistToSource = 0
        brightestIncidenceAngle = 0

        gridSize = 3
        gridSizeSq = gridSize*gridSize

        for x in range(width):
            for y in range(height):
                factorSum = 0
                for gx in range(gridSize):
                    for gy in range(gridSize):
                        # Calculate coordinates of pixel center in mm:
                        # Grid with margin:
                        stepSize = 1.0 / (gridSize+1)
                        pixel = self.detector.pixel_vector(x+(gx+1)*stepSize, y+(gy+1)*stepSize)

                        # Grid with no margin:
                        #if gridSize &gt; 1:
                        #    stepSize = 1.0 / (gridSize-1)
                        #    pixel = self.detector.pixel_vector(x+gx*stepSize, y+gy*stepSize)
                        #else:
                        #    pixel = self.detector.pixel_vector_center(x, y)

                        distToSource = self.source.center.distance(pixel)

                        # Angle of incident rays:
                        vecSourceToPixel = Vector(pixel.x()-sx, pixel.y()-sy, pixel.z()-sz)
                        incidenceAngle = abs(self.detector.w.angle(vecSourceToPixel))
                        if incidenceAngle &gt; (math.pi/2):
                            incidenceAngle = math.pi - incidenceAngle

                        intensityFactor = math.cos(incidenceAngle)*math.pow(SDD/distToSource, 2)
                        factorSum += intensityFactor

                intensityWeight = factorSum / gridSizeSq

                if intensityWeight &gt; maxIntensity:
                    maxIntensity = intensityWeight
                    maxX = x
                    maxY = y
                    minDistToSource = distToSource
                    brightestIncidenceAngle = incidenceAngle

                flatField.setPixel(x, y, intensityWeight)

            progress = 100*(float(x+1)/float(width))
            print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        return flatField

    def pixel_area_on_unit_sphere(self, A, B, C, D):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C, D must be vectors pointing to pixel corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()

        ACin  = A.cross(C)
        DAin  = D.cross(A)
        CDin  = C.cross(D)
        ACout = ACin.inverse()
        DAout = DAin.inverse()
        CDout = CDin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        # areaABC = alpha + beta + gamma - math.pi

        # Spherical Triangle ACD:
        rho   = ACin.angle(DAout)
        sigma = CDin.angle(ACout)
        tau   = DAin.angle(CDout)

        # areaACD = rho + tau + sigma - math.pi

        pxSphericalArea = (alpha + beta + gamma + rho + sigma + tau) - 2*math.pi

        return pxSphericalArea

    def triangle_area_on_unit_sphere(self, A, B, C):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        areaABC = alpha + beta + gamma - math.pi

        return areaABC

    def polygon_area_on_unit_sphere(self, polygon):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        if len(polygon.points) &gt;= 3:
            # Start at first point
            p1 = polygon.points[0]

            area = 0

            for i in range(1, len(polygon.points)-1):
                p2 = polygon.points[i]
                p3 = polygon.points[i+1]

                area += self.triangle_area_on_unit_sphere(p1, p2, p3)

            return area
        else:
            return 0

    def create_detector_flat_field_sphere(self, *coverPolygons):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Geometrical approach using spherical geometry. &#34;&#34;&#34;

        # Change to the detector coordinate system:
        D = copy.deepcopy(self.detector)
        S = copy.deepcopy(self.source)
        world = CoordinateSystem()  # will be initialized as world

        S.change_reference_frame(world, D)
        D.change_reference_frame(world, D)
        D.compute_geometry_parameters()

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = abs(S.center.z())

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        pu = D.pitch_u
        pv = D.pitch_v
        nRows = D.rows()
        nCols = D.cols()

        hpu = 0.5*pu
        hpv = 0.5*pv
        pA = Vector(SDD,  hpu,  hpv)
        pB = Vector(SDD, -hpu,  hpv)
        pC = Vector(SDD, -hpu, -hpv)
        pD = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixel_area_on_unit_sphere(pA, pB, pC, pD)

        # Full flat field image (without any clipping bodies):
        flatField = Image()
        flatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # A second image with a clipping body under consideration: (both will be returned)
        clippedFlatField = None
        if len(coverPolygons) &gt; 0:
            clippedFlatField = Image()
            clippedFlatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # Upper left detector corner in world coordinates (remember: world is now the detector CS)
        p00 = D.pixel_vector(0, 0)

        stepRight      = Vector(pu, 0,  0)
        stepDown       = Vector(0,  pv, 0)
        stepRightDown  = Vector(pu, pv, 0)

        # Move the clipping polygon to a coordinate system
        # where source is centered:
        for coverPolygon in coverPolygons:
            for p in range(len(coverPolygon.points)):
                coverPolygon.points[p] = coverPolygon.points[p] - S.center

        # Go through pixels:
        for x in range(nCols):
            for y in range(nRows):
                # Pixel in world coordinates (remember: world is now the detector CS)
                shift = Vector(x*pu, y*pv, 0)

                # Define Pixel corners:
                pA = p00 + shift
                pB = pA  + stepRight
                pC = pA  + stepRightDown
                pD = pA  + stepDown

                # Center source at (0, 0, 0):
                pA = pA - S.center
                pB = pB - S.center
                pC = pC - S.center
                pD = pD - S.center

                pixelPolygon = Polygon(pA, pB, pC, pD)
                pxSphericalArea  = self.polygon_area_on_unit_sphere(pixelPolygon)

                flatField.setPixel(x, y, pxSphericalArea)

                if len(coverPolygons) &gt; 0:
                    for coverPolygon in coverPolygons:
                        pixelPolygon = pixelPolygon.clip(coverPolygon)

                    # Remove the intensity covered by the clipping polygon:
                    pixelPolygon.make_3D(z_component=SDD)
                    subarea = self.polygon_area_on_unit_sphere(pixelPolygon)
                    pxSphericalArea -= subarea

                    clippedFlatField.setPixel(x, y, pxSphericalArea)

            progress = 100*(float(x+1)/float(D.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)
        if clippedFlatField is not None:
            clippedFlatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)

        return flatField, clippedFlatField

    def solid_angle(self, l, m):
        &#34;&#34;&#34; Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth. &#34;&#34;&#34;
        if l != 0:
            return (l/abs(l)) * math.atan(abs(l)*m/math.sqrt(1.0+l**2+m**2))
        else:
            return 0

    def create_detector_flat_field_analytical(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Analytical approach by Florian Wohlgemuth. &#34;&#34;&#34;

        width  = self.detector.cols()
        height = self.detector.rows()
        pitch_u = self.detector.pitch_u
        pitch_v = self.detector.pitch_v

        if(width is None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height is None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pitch_u is None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pitch_v is None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x()
        dy = self.detector.center.y()
        dz = self.detector.center.z()

        sx = self.source.center.x()
        sy = self.source.center.y()
        sz = self.source.center.z()

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x()
        uy = self.detector.u.y()
        uz = self.detector.u.z()

        vx = self.detector.v.x()
        vy = self.detector.v.y()
        vz = self.detector.v.z()

        wx = self.detector.w.x()
        wy = self.detector.w.y()
        wz = self.detector.w.z()


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        maxIntensity = 0
        maxX = 0
        maxY = 0

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translation_vector = Vector(-sx, -sy, -sz)
        det.translate(translation_vector)
        det.compute_geometry_parameters()

        upperLeft_u = det.pixel_vector(0, 0).dot(self.detector.u)
        upperLeft_v = det.pixel_vector(0, 0).dot(self.detector.v)
        upperLeft_w = det.pixel_vector(0, 0).dot(self.detector.w)

        if upperLeft_w != 0:   # check if detector is not facing its edge towards the source
            for x in range(width):
                for y in range(height):
                    nu = x
                    nv = y
                    lambda0 = (upperLeft_u + nu*pitch_u) / upperLeft_w
                    lambda1 = (upperLeft_u + (nu+1)*pitch_u) / upperLeft_w
                    mu0     = (upperLeft_v + nv*pitch_v) / upperLeft_w
                    mu1     = (upperLeft_v + (nv+1)*pitch_v) / upperLeft_w

                    omega = self.solid_angle(lambda0, mu0) + self.solid_angle(lambda1, mu1) - self.solid_angle(lambda0, mu1) - self.solid_angle(lambda1, mu0)

                    if omega &gt; maxIntensity:
                        maxIntensity = omega
                        maxX = x
                        maxY = y

                    flatField.setPixel(x, y, omega)

                progress = 100*(float(x+1)/float(width))
                print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        # print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        # print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        # Method #1: find hypothetical brightest pixel
        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitch_u
        hpv = 0.5*det.pitch_v
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixel_area_on_unit_sphere(A, B, C, D)
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale actual maximum to 1.
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, dataType=&#34;float32&#34;)
        return flatField


    def create_detector_flat_field(self):
        return create_detector_flat_field_analytical()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.Geometry.create_detector_flat_field"><code class="name flex">
<span>def <span class="ident">create_detector_flat_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ctsimu.geometry.Geometry.create_detector_flat_field_analytical"><code class="name flex">
<span>def <span class="ident">create_detector_flat_field_analytical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p>
<p>Analytical approach by Florian Wohlgemuth.</p></div>
</dd>
<dt id="ctsimu.geometry.Geometry.create_detector_flat_field_rays"><code class="name flex">
<span>def <span class="ident">create_detector_flat_field_rays</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p></div>
</dd>
<dt id="ctsimu.geometry.Geometry.create_detector_flat_field_sphere"><code class="name flex">
<span>def <span class="ident">create_detector_flat_field_sphere</span></span>(<span>self, *coverPolygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p>
<p>Geometrical approach using spherical geometry.</p></div>
</dd>
<dt id="ctsimu.geometry.Geometry.get_CERA_standard_circular_parameters"><code class="name flex">
<span>def <span class="ident">get_CERA_standard_circular_parameters</span></span>(<span>self, start_angle: float = 0) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate all parameters for an ideal circular trajectory
reconstruction in CERA without projection matrices.</p>
<p>These can be added to the reconstruction config file for CERA.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Reconstruction start angle (in degrees). The start angle can be
tuned to change the in-plane rotation of the reconstruction images.
Depending on the current stage rotation in this geometry, the
start angle will be adjusted. Consider this parameter more like
an offset to the start angle of stage rotation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cera_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>The dictionary contains the following keys:</p>
<ul>
<li>
<p><code>"R"</code>: CERA's source-object distance (SOD)</p>
</li>
<li>
<p><code>"D"</code>: CERA's source-detector distance (SDD)</p>
</li>
<li>
<p><code>"ODD"</code>: object-detector distance (ODD = SDD - SOD)</p>
</li>
<li>
<p><code>"a"</code>: CERA's a tilt</p>
</li>
<li>
<p><code>"b"</code>: CERA's b tilt</p>
</li>
<li>
<p><code>"c"</code>: CERA's c tilt</p>
</li>
<li>
<p><code>"u0"</code>: Detector u offset (px)</p>
</li>
<li>
<p><code>"v0"</code>: Detector v offset (px)</p>
</li>
<li>
<p><code>"start_angle"</code></p>
</li>
<li>
<p><code>"volume_midpoint"</code>: dict</p>
<ul>
<li><code>"x"</code>, <code>"y"</code> and <code>"z"</code></li>
</ul>
</li>
<li>
<p><code>"voxelsize"</code>: dict</p>
<ul>
<li><code>"x"</code>, <code>"y"</code> and <code>"z"</code></li>
</ul>
</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.Geometry.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an information string about the current geometry.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>txt</code></strong> :&ensp;<code>string</code></dt>
<dd>Information string for humans.</dd>
</dl></div>
</dd>
<dt id="ctsimu.geometry.Geometry.pixel_area_on_unit_sphere"><code class="name flex">
<span>def <span class="ident">pixel_area_on_unit_sphere</span></span>(<span>self, A, B, C, D)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ctsimu.geometry.Geometry.polygon_area_on_unit_sphere"><code class="name flex">
<span>def <span class="ident">polygon_area_on_unit_sphere</span></span>(<span>self, polygon)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ctsimu.geometry.Geometry.projection_matrix"><code class="name flex">
<span>def <span class="ident">projection_matrix</span></span>(<span>self, volumeCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a> = None, imageCS: <a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a> = None, mode: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a projection matrix for the current geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>volumeCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>, optional</dt>
<dd>Position of the volume coordinate system in terms of the
stage coordinate system. If <code>None</code> is given, the volume
coordinate system is assumed to be the stage coordinate system.
See notes for details.</dd>
<dt><strong><code>imageCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code>, optional</dt>
<dd>Position of the image coordinate system in terms of the
detector coordinate system. If <code>None</code> is given, the image
coordinate system is assumed to be the detector coordinate system.
See notes for details.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Pre-defined modes. Either <code>"OpenCT"</code> or <code>"CERA"</code> are supported.
They override the <code>volumeCS</code> and <code>imageCS</code>, which can be set
to <code>None</code> when using one of the pre-defined modes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code><a title="ctsimu.primitives.Matrix" href="primitives.html#ctsimu.primitives.Matrix">Matrix</a></code></dt>
<dd>Projection matrix.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The image coordinate system (<code>imageCS</code>) should match the location,
scale and orientation used by the reconstruction software, and is
expressed in terms of the detector coordinate system.</p>
<p>The detector coordinate system has its origin at the detector <code>center</code>,
the <code>u</code> unit vector points in the row vector direction, and the
<code>v</code> unit vector points in column vector direction (they are always
assumed to be unit vectors).</p>
<p>The <code>center</code> (origin) of the <code>imageCS</code> should be where the reconstruction
software places the origin of its own projection image coordinate
system. For example, CERA places it at the center of the lower-left
pixel of the projection image.</p>
<p>Similarly, a volume coordinate system (<code>volumeCS</code>) can be provided
that describes the location, scale and orientation of the reconstruction
volume with respect to the stage coordinate system.</p>
<p>If the reconstruction software expects a different unit for the image
or volume coordinate system (e.g. mm or voxels) than the world
coordinates (e.g. mm), you can scale the basis vectors accordingly.
For example, if you need a pixel and voxel coordinate system instead
of a millimeter coordinate system, scale the basis vectors by the
respective pixel and voxel size:</p>
<pre><code class="language-python">imageCS.u.scale(pixelSize_u)
imageCS.v.scale(pixelSize_v)
imageCS.w.scale(1.0) # Do not scale the detector normal!

volumeCS.u.scale(voxelSize_u)
volumeCS.v.scale(voxelSize_v)
volumeCS.w.scale(voxelSize_w)
</code></pre></div>
</dd>
<dt id="ctsimu.geometry.Geometry.restore"><code class="name flex">
<span>def <span class="ident">restore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Restore the configuration that has been saved by <code><a title="ctsimu.geometry.Geometry.store" href="#ctsimu.geometry.Geometry.store">Geometry.store()</a></code>.</p></div>
</dd>
<dt id="ctsimu.geometry.Geometry.solid_angle"><code class="name flex">
<span>def <span class="ident">solid_angle</span></span>(<span>self, l, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth.</p></div>
</dd>
<dt id="ctsimu.geometry.Geometry.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Store the current configuration in a backup buffer.</p>
<p>The primary purpose of this function is to create a backup
of the initial configuration, which can then always be recovered
by a call of <code><a title="ctsimu.geometry.Geometry.restore" href="#ctsimu.geometry.Geometry.restore">Geometry.restore()</a></code>. This allows the simulation of a
parameterized scan trajectory where each step's (or frame's)
configuration is deterministically calculated from the initial state,
rather than using incremental changes which could lead to the
accumulation of rounding inaccuracies.</p></div>
</dd>
<dt id="ctsimu.geometry.Geometry.triangle_area_on_unit_sphere"><code class="name flex">
<span>def <span class="ident">triangle_area_on_unit_sphere</span></span>(<span>self, A, B, C)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ctsimu.geometry.Geometry.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate derived geometry parameters.</p>
<p>Calculates the SOD, SDD, ODD, and location of the intensity maximum
on the detector (in world and detector coordinates) for the
curent geometry. Results are stored in the following member variables
(attributes).</p>
<p>SDD: Shortest distance between source center and detector plane.</p>
<p>SOD: Distance between source center and stage center.</p>
<p>ODD: Shortest distance between stage center and detector plane.</p>
<p>brightest_spot_world: Location of the intensity maximum on the detector,
in world coordinates.
Assuming an isotropically radiating source.</p>
<p>brightest_spot_detector: Location of the intensity maximum on the
detector, in terms of detector coordinate system.
Assuming an isotropically radiating source.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<div class="toc">
<ul>
<li><a href="#coordinate-systems">Coordinate Systems</a></li>
<li><a href="#full-ct-geometry">Full CT Geometry</a><ul>
<li><a href="#detector-convention">Detector convention</a></li>
<li><a href="#stage-convention">Stage convention</a></li>
<li><a href="#source-convention">Source convention</a></li>
<li><a href="#example-setup">Example Setup</a></li>
</ul>
</li>
<li><a href="#reference-frames">Reference Frames</a></li>
<li><a href="#projection-matrices">Projection Matrices</a><ul>
<li><a href="#mathematical-background">Mathematical Background</a></li>
<li><a href="#generating-projection-matrices">Generating Projection Matrices</a><ul>
<li><a href="#openct-cera">openCT &amp; CERA</a></li>
<li><a href="#image-volume-coordinate-systems">Image &amp; Volume Coordinate Systems</a><ul>
<li><a href="#example-1-cera">Example 1: CERA</a></li>
<li><a href="#example-2-openct">Example 2: openCT</a></li>
<li><a href="#example-3">Example 3</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#simulating-a-complete-ct-scan">Simulating a complete CT scan</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu" href="index.html">ctsimu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctsimu.geometry.basis_transform_matrix" href="#ctsimu.geometry.basis_transform_matrix">basis_transform_matrix</a></code></li>
<li><code><a title="ctsimu.geometry.change_reference_frame_of_direction" href="#ctsimu.geometry.change_reference_frame_of_direction">change_reference_frame_of_direction</a></code></li>
<li><code><a title="ctsimu.geometry.change_reference_frame_of_point" href="#ctsimu.geometry.change_reference_frame_of_point">change_reference_frame_of_point</a></code></li>
<li><code><a title="ctsimu.geometry.create_CERA_config" href="#ctsimu.geometry.create_CERA_config">create_CERA_config</a></code></li>
<li><code><a title="ctsimu.geometry.create_OpenCT_config" href="#ctsimu.geometry.create_OpenCT_config">create_OpenCT_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.geometry.CoordinateSystem" href="#ctsimu.geometry.CoordinateSystem">CoordinateSystem</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.CoordinateSystem.change_reference_frame" href="#ctsimu.geometry.CoordinateSystem.change_reference_frame">change_reference_frame</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.copy_cs" href="#ctsimu.geometry.CoordinateSystem.copy_cs">copy_cs</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.get_copy" href="#ctsimu.geometry.CoordinateSystem.get_copy">get_copy</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.make" href="#ctsimu.geometry.CoordinateSystem.make">make</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.make_from_vectors" href="#ctsimu.geometry.CoordinateSystem.make_from_vectors">make_from_vectors</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.make_unit_coordinate_system" href="#ctsimu.geometry.CoordinateSystem.make_unit_coordinate_system">make_unit_coordinate_system</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.reset" href="#ctsimu.geometry.CoordinateSystem.reset">reset</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate" href="#ctsimu.geometry.CoordinateSystem.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_pivot_point" href="#ctsimu.geometry.CoordinateSystem.rotate_around_pivot_point">rotate_around_pivot_point</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_u" href="#ctsimu.geometry.CoordinateSystem.rotate_around_u">rotate_around_u</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_v" href="#ctsimu.geometry.CoordinateSystem.rotate_around_v">rotate_around_v</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_w" href="#ctsimu.geometry.CoordinateSystem.rotate_around_w">rotate_around_w</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_x" href="#ctsimu.geometry.CoordinateSystem.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_y" href="#ctsimu.geometry.CoordinateSystem.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.rotate_around_z" href="#ctsimu.geometry.CoordinateSystem.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.set_u_w" href="#ctsimu.geometry.CoordinateSystem.set_u_w">set_u_w</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.transform" href="#ctsimu.geometry.CoordinateSystem.transform">transform</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate" href="#ctsimu.geometry.CoordinateSystem.translate">translate</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_in_direction" href="#ctsimu.geometry.CoordinateSystem.translate_in_direction">translate_in_direction</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_u" href="#ctsimu.geometry.CoordinateSystem.translate_u">translate_u</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_v" href="#ctsimu.geometry.CoordinateSystem.translate_v">translate_v</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_w" href="#ctsimu.geometry.CoordinateSystem.translate_w">translate_w</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_x" href="#ctsimu.geometry.CoordinateSystem.translate_x">translate_x</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_y" href="#ctsimu.geometry.CoordinateSystem.translate_y">translate_y</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.translate_z" href="#ctsimu.geometry.CoordinateSystem.translate_z">translate_z</a></code></li>
<li><code><a title="ctsimu.geometry.CoordinateSystem.update" href="#ctsimu.geometry.CoordinateSystem.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.geometry.DetectorGeometry" href="#ctsimu.geometry.DetectorGeometry">DetectorGeometry</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.DetectorGeometry.cols" href="#ctsimu.geometry.DetectorGeometry.cols">cols</a></code></li>
<li><code><a title="ctsimu.geometry.DetectorGeometry.compute_geometry_parameters" href="#ctsimu.geometry.DetectorGeometry.compute_geometry_parameters">compute_geometry_parameters</a></code></li>
<li><code><a title="ctsimu.geometry.DetectorGeometry.pixel_vector" href="#ctsimu.geometry.DetectorGeometry.pixel_vector">pixel_vector</a></code></li>
<li><code><a title="ctsimu.geometry.DetectorGeometry.pixel_vector_center" href="#ctsimu.geometry.DetectorGeometry.pixel_vector_center">pixel_vector_center</a></code></li>
<li><code><a title="ctsimu.geometry.DetectorGeometry.rows" href="#ctsimu.geometry.DetectorGeometry.rows">rows</a></code></li>
<li><code><a title="ctsimu.geometry.DetectorGeometry.set_size" href="#ctsimu.geometry.DetectorGeometry.set_size">set_size</a></code></li>
<li><code><a title="ctsimu.geometry.DetectorGeometry.size_is_set" href="#ctsimu.geometry.DetectorGeometry.size_is_set">size_is_set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.Geometry.create_detector_flat_field" href="#ctsimu.geometry.Geometry.create_detector_flat_field">create_detector_flat_field</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.create_detector_flat_field_analytical" href="#ctsimu.geometry.Geometry.create_detector_flat_field_analytical">create_detector_flat_field_analytical</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.create_detector_flat_field_rays" href="#ctsimu.geometry.Geometry.create_detector_flat_field_rays">create_detector_flat_field_rays</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.create_detector_flat_field_sphere" href="#ctsimu.geometry.Geometry.create_detector_flat_field_sphere">create_detector_flat_field_sphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.get_CERA_standard_circular_parameters" href="#ctsimu.geometry.Geometry.get_CERA_standard_circular_parameters">get_CERA_standard_circular_parameters</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.info" href="#ctsimu.geometry.Geometry.info">info</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.pixel_area_on_unit_sphere" href="#ctsimu.geometry.Geometry.pixel_area_on_unit_sphere">pixel_area_on_unit_sphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.polygon_area_on_unit_sphere" href="#ctsimu.geometry.Geometry.polygon_area_on_unit_sphere">polygon_area_on_unit_sphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.projection_matrix" href="#ctsimu.geometry.Geometry.projection_matrix">projection_matrix</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.restore" href="#ctsimu.geometry.Geometry.restore">restore</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.solid_angle" href="#ctsimu.geometry.Geometry.solid_angle">solid_angle</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.store" href="#ctsimu.geometry.Geometry.store">store</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.triangle_area_on_unit_sphere" href="#ctsimu.geometry.Geometry.triangle_area_on_unit_sphere">triangle_area_on_unit_sphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.update" href="#ctsimu.geometry.Geometry.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
