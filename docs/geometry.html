<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctsimu.geometry API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.geometry</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-
import numpy
import os    # File and path handling
import json
import math
import copy
import pkgutil
from datetime import datetime

from .primitives import *
from .image import Image  # To create detector flat field

def basisTransformMatrix(fromCS:&#39;GeometryObject&#39;, toCS:&#39;GeometryObject&#39;) -&gt; Matrix:
    &#34;&#34;&#34;Calculate a matrix that transforms coordinates from `fromCS` to `toCS`.

    Parameters
    ----------
    fromCS : GeometryObject
        The origin coordinate system.

    toCS : GeometryObject
        The target coordinate system.

    Returns
    -------
    T : Matrix
        The 3x3 basis transformation matrix.

    References
    ----------
    * S. Widnall: [Lecture L3 - Vectors, Matrices and Coordinate Transformations]
    [Lecture L3 - Vectors, Matrices and Coordinate Transformations]: https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec03.pdf
    &#34;&#34;&#34;

    T = Matrix(3, 3)

    # Row 1:
    T.value[0][0] = toCS.u.unitVector().dot(fromCS.u.unitVector())
    T.value[0][1] = toCS.u.unitVector().dot(fromCS.v.unitVector())
    T.value[0][2] = toCS.u.unitVector().dot(fromCS.w.unitVector())

    # Row 2:
    T.value[1][0] = toCS.v.unitVector().dot(fromCS.u.unitVector())
    T.value[1][1] = toCS.v.unitVector().dot(fromCS.v.unitVector())
    T.value[1][2] = toCS.v.unitVector().dot(fromCS.w.unitVector())

    # Row 3:
    T.value[2][0] = toCS.w.unitVector().dot(fromCS.u.unitVector())
    T.value[2][1] = toCS.w.unitVector().dot(fromCS.v.unitVector())
    T.value[2][2] = toCS.w.unitVector().dot(fromCS.w.unitVector())

    return T

class GeometryObject:
    &#34;&#34;&#34;Coordinate system: center point and axis vectors.

    An object according to the CTSimU scenario specification,
    containing a center coordinate and an orientation in 3D space.
    
    The center and axis vectors are expressed in terms of the
    object&#39;s reference coordinate system, which must be known implicitly
    when objects of this class are used.

    Geometrical objects could be source, stage or detector.
    Samples would need additional attention due to possible attachment
    to stage coordinate system (instead of world).

    Attributes
    ----------
    center : Vector
        The location of the center point in a reference
        coordinate system (usually world or stage).

    u : Vector
        Basis vector for the u axis.

    v : Vector
        Basis vector for the v axis.

    w : Vector
        Basis vector for the w axis.

    Methods
    -------
    setupFromGeometryDefinition(geometry)
        Set up geometry from a JSON dictionary.

    setup(centerX, centerY, centerZ, uX, uY, uZ, wX, wY, wZ)
        Set up center and orientation manually.

    makeUnitCS()
        Convert all basis vectors to unit vectors.

    translate(translationVector)
        Move object in space.

    translateX(dx)
        Move object in x direction.

    translateY(dx)
        Move object in y direction.

    translateZ(dx)
        Move object in z direction.

    rotateAroundU(angle)
        Rotate object around its u axis by given angle [rad].

    rotateAroundV(angle)
        Rotate object around its v axis by given angle [rad].

    rotateAroundW(angle)
        Rotate object around its w axis by given angle [rad].

    rotate(axis, angle)
        Rotate object around a given axis by the given angle [rad].

    changeReferenceFrame(fromCS, toCS)
        Change the object&#39;s reference coordinate system.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard world coordinate system.&#34;&#34;&#34;
        self.center  = Vector(0, 0, 0)
        self.u = Vector(1, 0, 0)
        self.v = Vector(0, 1, 0)
        self.w = Vector(0, 0, 1)

    def __str__(self):
        &#34;&#34;&#34;Information string for easy printing.&#34;&#34;&#34;

        txt  = &#34;Center: {}\n&#34;.format(self.center)
        txt += &#34;u:      {}\n&#34;.format(self.u)
        txt += &#34;v:      {}\n&#34;.format(self.v)
        txt += &#34;w:      {}\n&#34;.format(self.w)
        return txt

    def setupFromGeometryDefinition(self, geometry: dict):
        &#34;&#34;&#34;Set up geometry from a JSON dictionary.

        Parameters
        ----------
        geometry : dict
            A parsed JSON dictionary from a CTSimU scenario description file.
            See [2]_.

        Raises
        ------
        KeyError
            When expected JSON keys for center and vector x, y, z
            components are not found in the dictionary.

        References
        ----------
        .. [2] CTSimU Scenario Descriptions, https://bamresearch.github.io/ctsimu-scenarios/
        &#34;&#34;&#34;

        # Get center position from JSON dict:
        if &#34;center&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;center&#34;]:
                cx = in_mm(geometry[&#34;center&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;center&#34;]:
                cy = in_mm(geometry[&#34;center&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;center&#34;]:
                cz = in_mm(geometry[&#34;center&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        # Try old British spelling (up to file format v0.9)
        elif &#34;centre&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;centre&#34;]:
                cx = in_mm(geometry[&#34;centre&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;centre&#34;]:
                cy = in_mm(geometry[&#34;centre&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;centre&#34;]:
                cz = in_mm(geometry[&#34;centre&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;center\&#34; section.&#34;)

        # Get vector u from JSON dict:
        if &#34;vector_u&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_u&#34;]:
                ux = geometry[&#34;vector_u&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector u.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_u&#34;]:
                uy = geometry[&#34;vector_u&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector u.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_u&#34;]:
                uz = geometry[&#34;vector_u&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector u.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_u\&#34; section.&#34;)

        # Get vector w from JSON dict:
        if &#34;vector_w&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_w&#34;]:
                wx = geometry[&#34;vector_w&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector w.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_w&#34;]:
                wy = geometry[&#34;vector_w&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector w.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_w&#34;]:
                wz = geometry[&#34;vector_w&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector w.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_w\&#34; section.&#34;)

        # Set up the geometry from the information given in the JSON file:
        c = Vector(cx, cy, cz)  # center
        u = Vector(ux, uy, uz)  # u basis vector
        w = Vector(wx, wy, wz)  # w basis vector
        v = w.cross(u)
        self.setup(c, u, v, w)
        self.makeUnitCS()

        # Apply deviations from the now-ideal geometry:
        if &#34;deviation&#34; in geometry:
            # Positional deviations:
            if &#34;position&#34; in geometry[&#34;deviation&#34;]:
                if &#34;x&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;] != None:
                        translationX = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;])
                        self.translateX(translationX)
    
                if &#34;y&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;] != None:
                        translationY = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;])
                        self.translateY(translationY)

                if &#34;z&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;] != None:
                        translationZ = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;])
                        self.translateZ(translationZ)

            # Rotations according to w&#39;&#39;v&#39;u convention:
            if &#34;rotation&#34; in geometry[&#34;deviation&#34;]:
                if &#34;w&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;] != None:
                        angleAroundW = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;])
                        self.rotateAroundW(angleAroundW)

                if &#34;v&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;] != None:
                        angleAroundV = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;])
                        self.rotateAroundV(angleAroundV)

                if &#34;u&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;] != None:
                        angleAroundU = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;])
                        self.rotateAroundU(angleAroundU)

    def setup(self, center:Vector, u:Vector, v:Vector, w:Vector):
        &#34;&#34;&#34;Set up center and orientation manually.

        Parameters
        ----------
        center : Vector
            Object&#39;s center point in reference coordinate system,
            origin of local {u,v,w} coordinate system.

        u : Vector
            Basis vector u in terms of reference coordinate system.

        v : Vector
            Basis vector v in terms of reference coordinate system.

        w : Vector
            Basis vector w in terms of reference coordinate system.

        Notes
        -----
        All basis vectors must be orthogonal.
        &#34;&#34;&#34;

        # Create new vectors from given components:
        self.center  = center
        self.u = u
        self.v = v
        self.w = w

    def makeUnitCS(self):
        &#34;&#34;&#34;Convert all basis vectors to unit vectors.&#34;&#34;&#34;
        self.u.makeUnitVector()
        self.v.makeUnitVector()
        self.w.makeUnitVector()

    def translate(self, translationVector: Vector):
        &#34;&#34;&#34;Move object in space.

        Parameters
        ----------
        translationVector : Vector
            Vector by which the object&#39;s center point should be shifted.
            Its components are added to the center&#39;s components.
        &#34;&#34;&#34;
        self.center.add(translationVector)

    def translateX(self, dx: float):
        &#34;&#34;&#34;Move object in x direction.

        Parameters
        ----------
        dx : float
            Shift amount in x direction.
        &#34;&#34;&#34;
        self.center.setx(self.center.x + float(dx))

    def translateY(self, dy: float):
        &#34;&#34;&#34;Move object in y direction.

        Parameters
        ----------
        dy : float
            Shift amount in y direction.
        &#34;&#34;&#34;
        self.center.sety(self.center.y + float(dy))

    def translateZ(self, dz: float):
        &#34;&#34;&#34;Move object in z direction.

        Parameters
        ----------
        dz : float
            Shift amount in z direction.
        &#34;&#34;&#34;
        self.center.setz(self.center.z + float(dz))

    def rotateAroundU(self, angle: float):
        &#34;&#34;&#34;Rotate object around its u axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.v.rotate(self.u, angle)
        self.w.rotate(self.u, angle)

    def rotateAroundV(self, angle: float):
        &#34;&#34;&#34;Rotate object around its v axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.u.rotate(self.v, angle)
        self.w.rotate(self.v, angle)

    def rotateAroundW(self, angle: float):
        &#34;&#34;&#34;Rotate object around its w axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.u.rotate(self.w, angle)
        self.v.rotate(self.w, angle)

    def rotate(self, axis: Vector, angle: float):
        &#34;&#34;&#34;Rotate object around a given axis by the given angle [rad].
        
        Parameters
        ----------
        axis : Vector
            The axis of rotation, in terms of the object&#39;s
            reference coordinate system (e.g. world).
        
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.u.rotate(axis, angle)
        self.v.rotate(axis, angle)
        self.w.rotate(axis, angle)

    def changeReferenceFrame(self, fromCS:&#39;GeometryObject&#39;, toCS:&#39;GeometryObject&#39;):
        &#34;&#34;&#34;Change the object&#39;s reference coordinate system.
        
        Parameters
        ----------
        fromCS : GeometryObject
            Current reference coordinate system.
        
        toCS : GeometryObject
            New reference coordinate system.

        Notes
        -----
        Both fromCS and toCS must be in the same reference coordinate system
        (e.g., the world coordinate system).
        &#34;&#34;&#34;

        # Rotate basis vectors into toCS:
        T = basisTransformMatrix(fromCS, toCS)
        self.u = T * self.u
        self.v = T * self.v
        self.w = T * self.w

        world = GeometryObject()

        # Move center to toCS:
        # 1. Translate self.center by difference of toCS and fromCS
        #    -&gt; Origins are &#34;superimposed&#34;.
        # 2. Rotate self.center from fromCS to toCS.

        # Translation vector in world coordinates:
        translator = fromCS.center - toCS.center  # in world coordinates
        # Translation vector in fromCS coordinates:
        M = basisTransformMatrix(world, fromCS)
        translator = M*translator
        relCenter = self.center + translator
        self.center = T*relCenter

class Detector(GeometryObject):
    &#34;&#34;&#34;Detector as geometrical object.

    With additional attributes for the spatial extension and
    the pixel coordinate system.

    Attributes
    ----------
    pixelsU : int
        Number of pixels in u direction.
    
    pixelsV : int
        Number of pixels in v direction.
    
    pitchU : float
        Size of a pixel in u direction.
        In units of the reference coordinate system.
    
    pitchV : float
        Size of a pixel in v direction.
        In units of the reference coordinate system.
    
    physWidth : float
        Physical size in u direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
    
    physHeight : float
        Physical size in v direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
 
    pixelOrigin : Vector
        Origin of the pixel coordinate system in terms of the reference
        coordinate system. This is the outermost corner of the
        (0,0) pixel of the detector (often the &#34;upper left&#34; corner).
        Computed automatically after calling `setSize()`.

    Methods
    -------
    setSize(nPixelsU, nPixelsV, pitchU, pitchV)
        Set the physical size of the detector.

    computeGeometryParameters()
        Calculate the physical width and height,
        and the position of the pixel coordinate system origin.

    cols()
        Returns the number of detector columns (i.e., pixels in u direction).

    rows()
        Returns the number of detector rows (i.e., pixels in v direction).

    pixelVector(x, y)
        World position vector for given pixel coordinate.

    pixelVectorCenter(x, y)
        World position vector of pixel center,
        for a pixel identified by its integer coordinates.

    Notes
    -----
    Use `setSize()` to set the size of the detector, given its number of pixels
    and the pitch. This function automatically computes the physical dimensions
    `physWidth` and `physHeight` and the origin of the pixel coordinate system.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard GeometryObject.

        Orientation, position and size must be set up manually afterwards.
        &#34;&#34;&#34;

        # Call init from parent class:
        GeometryObject.__init__(self)

        self.pixelsU     = None  # Detector pixels in u direction
        self.pixelsV     = None  # Detector pixels in v direction
        self.pitchU = None  # Size of a pixel in u direction in units of reference coordinate system
        self.pitchV = None  # Size of a pixel in v direction in units of reference coordinate system
        self.physWidth   = 0    # Physical width in units of reference coordinate system
        self.physHeight  = 0    # Physical height in units of reference coordinate system

        self.pixelOrigin = Vector()  # origin of pixel coordinate system in terms of reference coordinate system

    def setSize(self, nPixelsU:int = None, nPixelsV:int = None, pitchU:float = None, pitchV:float = None):
        &#34;&#34;&#34;Set the physical size of the detector.

        From the given parameters (number of pixels and pitch), the physical
        size of the detector and the position of the origin of the pixel
        coordinate system will be calculated. Make sure that the orientation
        vectors and position of the detector are correct before calling
        `setSize()`, or call `computeGeometryParameters()` if you update
        the detector orientation or position later on.

        Parameters
        ----------
        nPixelsU : int
            Number of pixels in u direction.

        nPixelsV : int
            Number of pixels in v direction.

        pitchU : float
            Pixel pitch in u direction.

        pitchV : float
            Pixel pitch in v direction.
        &#34;&#34;&#34;

        self.pixelsU = int(nPixelsU)
        self.pixelsV = int(nPixelsV)
        self.pitchU = float(pitchU)
        self.pitchV = float(pitchV)

        self.computeGeometryParameters()

    def computeGeometryParameters(self):
        &#34;&#34;&#34;Calculate the physical width and height, and the position of the
        pixel coordinate system origin.

        These calculations assume that the size, position and
        orientation of the detector are correctly set up.

        Results are assigned to their member variables (attributes).
        &#34;&#34;&#34;

        if (self.pixelsU is not None) and (self.pixelsV is not None) and (self.pitchU is not None) and (self.pitchV is not None):
            # Physical width and height:
            self.physWidth  = self.pixelsU * self.pitchU
            self.physHeight = self.pixelsV * self.pitchV

            # Vectors of the detector coordinate system:
            ux = self.u.unitVector().x
            uy = self.u.unitVector().y
            uz = self.u.unitVector().z
            vx = self.v.unitVector().x
            vy = self.v.unitVector().y
            vz = self.v.unitVector().z

            # World coordinates of origin (0,0) of detector&#39;s pixel coordinate system:
            self.pixelOrigin.x = self.center.x - 0.5*(ux*self.physWidth + vx*self.physHeight)
            self.pixelOrigin.y = self.center.y - 0.5*(uy*self.physWidth + vy*self.physHeight)
            self.pixelOrigin.z = self.center.z - 0.5*(uz*self.physWidth + vz*self.physHeight)

    def cols(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector columns (i.e., pixels in u direction).

        Returns
        -------
        pixelsU : int
            Number of detector columns (i.e., pixels in u direction).
        &#34;&#34;&#34;
        return self.pixelsU

    def rows(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector rows (i.e., pixels in v direction).

        Returns
        -------
        pixelsV : int
            Number of detector rows (i.e., pixels in v direction).
        &#34;&#34;&#34;
        return self.pixelsV

    def pixelVector(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector for given pixel coordinate.

        The pixel coordinate system has its origin at the detector corner with
        the lowest coordinate in terms of its u and v basis vectors. Typically,
        this is the upper left corner, but your arrangement may differ.

        Integer coordinates always refer to the pixel corner that is closest to
        the origin of the pixel coordinate system, whereas the center of a pixel
        therefore has a &#34;.5&#34; coordinate in the pixel coordinate system.
        For example, the first pixel (0, 0) would have center coordinates
        (0.5, 0.5).

        To get the center coordinates for a given integer pixel location,
        `pixelVectorCenter()` may be used.

        Parameters
        ----------
        x : float
            x position in pixel coordinate system.

        y : float
            y position in pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Pixel position in reference coordinate system (usually world)
            as a 3D vector.
        &#34;&#34;&#34;

        # x, y are coordinates in pixel coordinates system
        px = self.pixelOrigin.x + self.u.x*x*self.pitchU + self.v.x*y*self.pitchV
        py = self.pixelOrigin.y + self.u.y*x*self.pitchU + self.v.y*y*self.pitchV
        pz = self.pixelOrigin.z + self.u.z*x*self.pitchU + self.v.z*y*self.pitchV
        pixelVector = Vector(px, py, pz)
        return pixelVector

    def pixelVectorCenter(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector of pixel center, for a pixel given in integer coordinates.

        Parameters
        ----------
        x : float
            Integer x coordinate, specifies a pixel in the pixel coordinate system.

        y : float
            Integer y coordinate, specifies a pixel in the pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Position of the pixel center in the reference coordinate system
            (usually world) as a 3D vector.

        Notes
        -----
        If `float` coordinates are passed (non-integer),
        they are converted to integers using `math.floor`.
        &#34;&#34;&#34;
        return self.pixelVector(float(math.floor(x))+0.5, float(math.floor(y))+0.5)


class Geometry:
    &#34;&#34;&#34;Bundles geometry information about the complete CT setup.

    Keeps the source, stage and detector as a set and provides methods
    to calculate geometry parameters and projection matrices.
    
    Attributes
    ----------
    detector : Detector
        The detector geometry.

    source : GeometryObject
        The source geometry.

    stage : GeometryObject
        The stage geometry.

    SDD : float
        Shortest distance between source center and detector plane.
        Calculated automatically by `update()`.

    SOD : float
        Distance between source center and stage center.
        Calculated automatically by `update()`.

    ODD : float
        Shortest distance between stage center and detector plane.
        Calculated automatically by `update()`.

    brightestSpotWorld : Vector
        Location of the intensity maximum on the detector, in world coordinates.
        Assuming an isotropically radiating source.
        Calculated automatically by `update()`.

    brightestSpotDetector : Vector
        Location of the intensity maximum on the detector, in terms of
        detector coordinate system. Assuming an isotropically radiating source.
        Calculated automatically by `update()`.

    Methods
    -------

    &#34;&#34;&#34;

    def __init__(self, jsonFile:str = None, jsonFileFromPkg:str = None):
        &#34;&#34;&#34;Initialize using the provided JSON geometry specification.

        Parameters
        ----------
        jsonFile : str, optional
            Location of a CTSimU scenario description file to
            import the geometry.

        jsonFileFromPkg : str, optional
            Load the geometry from a JSON file included in the package,
            usually for internal purposes only.

        &#34;&#34;&#34;
        self.detector    = Detector()
        self.source      = GeometryObject()
        self.stage       = GeometryObject()

        self.SDD = None
        self.SOD = None
        self.ODD = None
        self.brightestSpotWorld = None
        self.brightestSpotDetector = None

        jsonText = None
        if jsonFileFromPkg is not None:  # from package
            jsonFile = jsonFileFromPkg
            jsonText = pkgutil.get_data(__name__, jsonFileFromPkg).decode()
        elif jsonFile is not None:  # from file
            if os.path.isfile(jsonFile):
                log(&#34;JSON File: {}&#34;.format(jsonFile))
                jsonFilePtr = open(jsonFile, &#34;r&#34;)
                jsonText = jsonFilePtr.read()
                jsonFilePtr.close()
            else:
                raise Exception(&#34;Can&#39;t find &#34; + jsonFile)
        else:
            return

        if(jsonText is not None):
            try:
                jsonDict = json.loads(jsonText)
            except:
                raise Exception(&#34;Error parsing JSON file: {}&#34;.format(jsonFile))

            # Detector size and pixel pitch:
            pixelsU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;columns&#34;, &#34;value&#34;)
            pixelsV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;rows&#34;, &#34;value&#34;)
            pitchU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;u&#34;, &#34;value&#34;)
            pitchV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;v&#34;, &#34;value&#34;)

            try:
                detectorGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;detector&#34;)
                if detectorGeometry != None:
                    self.detector.setupFromGeometryDefinition(detectorGeometry)
                    self.detector.setSize(pixelsU, pixelsV, pitchU, pitchV)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;detector\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the detector geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                sourceGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;source&#34;)
                if sourceGeometry != None:
                    self.source.setupFromGeometryDefinition(sourceGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;source\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the source geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                stageGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;stage&#34;)
                if stageGeometry != None:
                    self.stage.setupFromGeometryDefinition(stageGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;stage\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the stage geometry using the JSON file description.&#34;)
                raise Exception(e)

            self.update()            
        else:
            raise Exception(&#34;JSON scenario file not available.&#34;)
        
    def update(self):
        &#34;&#34;&#34;Calculate derived geometry parameters.

        Calculates the SOD, SDD, ODD, and location of the intensity maximum
        on the detector (in world and detector coordinates) for the
        curent geometry. Results are stored in the following member variables
        (attributes).

        SDD: Shortest distance between source center and detector plane.

        SOD: Distance between source center and stage center.

        ODD: Shortest distance between stage center and detector plane.

        brightestSpotWorld: Location of the intensity maximum on the detector,
            in world coordinates.  Assuming an isotropically radiating source.

        brightestSpotDetector: Location of the intensity maximum on the
            detector, in terms of detector coordinate system.
            Assuming an isotropically radiating source.
        &#34;&#34;&#34;

        # SOD, SDD, ODD
        world = GeometryObject()
        source_from_image = copy.deepcopy(self.source)
        stage_from_detector  = copy.deepcopy(self.stage)

        source_from_image.changeReferenceFrame(world, self.detector)
        stage_from_detector.changeReferenceFrame(world, self.detector)

        self.SDD = abs(source_from_image.center.z)
        self.ODD = abs(stage_from_detector.center.z)
        self.SOD = self.source.center.distance(self.stage.center)

        ## Brightest Spot in World Coordinate System:
        self.brightestSpotWorld = copy.deepcopy(self.detector.w)
        self.brightestSpotWorld.scale(self.SDD)
        self.brightestSpotWorld.add(self.source.center)

        ## Brightest Spot in Detector Coordinate System:
        self.brightestSpotDetector = copy.deepcopy(self.brightestSpotWorld)
        self.brightestSpotDetector.subtract(self.detector.center)
        
        pxU = self.brightestSpotDetector.dot(self.detector.u) / self.detector.pitchU + self.detector.cols()/2.0
        pxV = self.brightestSpotDetector.dot(self.detector.v) / self.detector.pitchV + self.detector.rows()/2.0

        self.brightestSpotDetector = Vector(pxU, pxV, 0)


    def info(self) -&gt; str:
        &#34;&#34;&#34;Generate an information string about the current geometry.
    
        Returns
        -------
        txt : string
            Information string for humans.
        &#34;&#34;&#34;

        txt  = &#34;Detector\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.detector.center)
        txt += &#34;u:               {}\n&#34;.format(self.detector.u)
        txt += &#34;v:               {}\n&#34;.format(self.detector.v)
        txt += &#34;w:               {}\n&#34;.format(self.detector.w)
        txt += &#34;Pixels:          {cols} x {rows}\n&#34;.format(cols=self.detector.cols(), rows=self.detector.rows())
        txt += &#34;Pitch:           {pitchU} mm x {pitchV} mm\n&#34;.format(pitchU=self.detector.pitchU, pitchV=self.detector.pitchV)
        txt += &#34;Physical Size:   {width} mm x {height} mm\n&#34;.format(width=self.detector.physWidth, height=self.detector.physHeight)
        txt += &#34;Center Distance: {} mm\n&#34;.format(self.detector.center.distance(self.source.center))

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        txt += &#34;SDD:             {} mm\n&#34;.format(self.SDD)
        txt += &#34;Brightest Spot:\n&#34;
        txt += &#34;  World:         {}\n&#34;.format(self.brightestSpotWorld)
        txt += &#34;  Pixels:        {}\n&#34;.format(self.brightestSpotDetector)

        txt += &#34;\n&#34;
        txt += &#34;Source:\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.source.center)
        txt += &#34;u:               {}\n&#34;.format(self.source.u)
        txt += &#34;v:               {}\n&#34;.format(self.source.v)
        txt += &#34;w:               {}\n&#34;.format(self.source.w)

        return txt

    def projectionMatrix(self,
                         imageCS:GeometryObject=None,
                         mode:str=None):
        &#34;&#34;&#34;Calculate a projection matrix for the current geometry.

        Parameters
        ----------
        imageCS : GeometryObject
            Position of the image coordinate system in terms of the
            detector coordinate system. See notes for details.

        mode : str
            Pre-defined modes, either &#34;openCT&#34; or &#34;CERA&#34; are supported.
            They override the `imageCS`, which can be set to `None` when
            using one of the pre-defined modes.

        Returns
        -------
        P : Matrix
            Projection matrix.

        Notes
        -----
        The image coordinate system (`imageCS`) should match the notation
        used by the reconstruction software, and is expressed in terms of
        the detector coordinate system.

        The detector coordinate system has its origin at the detector center,
        the u unit vector points in the row vector direction, and the
        v unit vector points in column vector direction (they are always assumed
        to be unit vectors).

        The center (origin) of the `imageCS` should be where the reconstruction
        software places the origin of its own image or detector coordinate
        system. For example, CERA places it at the lower-left corner of the
        projection image. In this case, the `imageCS` center should be set to
        ()
        &#34;&#34;&#34;

        validModes = [&#34;openCT&#34;, &#34;CERA&#34;]

        if mode is not None:
            if mode in validModes:  # Override imageCS
                image = GeometryObject()

                if mode == &#34;openCT&#34;:
                    &#34;&#34;&#34;openCT places the origin of the image CS at the detector 
                    center. The constructor places it at (0,0,0) automatically,
                    so there is nothing to do. Comments for illustration.&#34;&#34;&#34;
                    # image.center.x = 0
                    # image.center.y = 0
                    # image.center.z = 0

                    &#34;&#34;&#34;openCT&#39;s image CS is in mm units. We assume that all
                    other coordinate systems are in mm as well here (at least
                    when imported from JSON file). No scaling of the basis vectors is necessary.&#34;&#34;&#34;
                    # image.u.scale(1.0)
                    # image.v.scale(1.0)
                    # image.w.scale(1.0)

                elif mode == &#34;CERA&#34;:
                    &#34;&#34;&#34;CERA places the origin of the image CS in the center
                    of the lower left pixel of the projection image.&#34;&#34;&#34;
                    image.center.x = -self.detector.physWidth  / 2.0 + 0.5*self.detector.pitchU
                    image.center.y =  self.detector.physHeight / 2.0 - 0.5*self.detector.pitchV
                    # image.center.z = 0

                    &#34;&#34;&#34;CERA&#39;s unit of the image CS is in px, so we need to
                    scale the image CS basis vectors by the pixel size.
                    Also, v points up instead of down.&#34;&#34;&#34;
                    image.u.scale( self.detector.pitchU)
                    image.v.scale(-self.detector.pitchV)
                    image.w.scale(-1.0)
            else:
                raise RuntimeError(&#34;Unsupported mode for projection matrix: \&#34;{}\&#34;&#34;.format(mode))
        elif imageCS is not None:
            image = copy.deepcopy(imageCS)
        else:
            raise RuntimeError(&#34;projectionMatrix: Please provide either a mode or an imageCS.&#34;)

        world    = GeometryObject()
        source   = copy.deepcopy(self.source)
        stage    = copy.deepcopy(self.stage)

        # Detach the image CS from the detector CS and
        # express it in terms of the world CS:
        image.changeReferenceFrame(self.detector, world)

        &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
        vectors of the image CS compared to the detector CS unit vectors.&#34;&#34;&#34;
        scale_u = self.detector.u.dot(image.u)
        scale_v = self.detector.v.dot(image.v)
        scale_w = self.detector.w.dot(image.w)

        # Save a source CS as seen from the detector CS. This is convenient to
        # later get the SDD, ufoc and vfoc:
        source_from_image = copy.deepcopy(self.source)
        source_from_image.changeReferenceFrame(world, image)

        # Make the stage CS the new world CS:
        source.changeReferenceFrame(world, stage)
        image.changeReferenceFrame(world, stage)
        stage.changeReferenceFrame(world, stage)

        # Translation vector from stage to source:
        rfoc = source.center - stage.center
        xfoc = rfoc.x
        yfoc = rfoc.y
        zfoc = rfoc.z

        # Focus point on detector: principal, perpendicular ray.
        # In the detector coordinate system, ufoc and vfoc are the u and v coordinates
        # of the source center; SDD (perpendicular to detector plane) is source w coordinate.
        ufoc = source_from_image.center.x / scale_u
        vfoc = source_from_image.center.y / scale_v
        wfoc = source_from_image.center.z / scale_w
        SDD  = abs(source_from_image.center.z)

        # Mirror volume:
        M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])

        # Translation matrix: stage -&gt; source:
        F = Matrix(values=[[1, 0, 0, xfoc], [0, 1, 0, yfoc], [0, 0, 1, zfoc]])

        # Rotations:
        R = basisTransformMatrix(stage, image)

        # Projection onto detector and scaling:
        D = Matrix(values=[[SDD/scale_u, 0, 0], [0, SDD/scale_v, 0], [0, 0, 1.0/scale_w]])

        # Shift in detector CS: (ufoc and vfoc must be in scaled units)
        V = Matrix(values=[[1, 0, ufoc], [0, 1, vfoc], [0, 0, 1]])

        # Multiply all together:
        P = V * (D * (R * (F*M)))

        # Renormalize:
        lower_right = P.get(col=3, row=2)
        if lower_right != 0:
            P.scale(1.0/lower_right)

        return P

    def createDetectorFlatField_rays(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction. &#34;&#34;&#34;
        width      = self.detector.cols()
        height     = self.detector.rows()
        pixelSizeU = self.detector.pitchU
        pixelSizeV = self.detector.pitchV

        if(width == None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height == None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeU == None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeV == None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        log(&#34;Geometry definition from JSON file:\n\
   Detector Angle:    {}\n\
   Detector Distance: {}\n\
   SDD:               {}\n\
   Pixels U:          {}\n\
   Pixels V:          {}\n\
   Pitch U:           {}\n\
   Pitch V:           {}\n\
   Source:            {}, {}, {}\n\
   Detector:          {}, {}, {}\n\
   Connection Vector: {}, {}, {}\n\
   Detector Vector U: {}, {}, {}\n\
   Detector Vector V: {}, {}, {}\n\
   Detector Vector W: {}, {}, {}&#34;.format(alpha, dist, SDD, width, height, pixelSizeU, pixelSizeV, sx, sy, sz, dx, dy, dz, connectionLine.x, connectionLine.y, connectionLine.z, ux, uy, uz, vx, vy, vz, wx, wy, wz))

        maxIntensity = 0
        maxX = 0
        maxY = 0
        minDistToSource = 0
        brightestIncidenceAngle = 0

        gridSize = 3
        gridSizeSq = gridSize*gridSize

        for x in range(width):
            for y in range(height):
                factorSum = 0
                for gx in range(gridSize):
                    for gy in range(gridSize):
                        # Calculate coordinates of pixel center in mm:
                        # Grid with margin:
                        stepSize = 1.0 / (gridSize+1)
                        pixel = self.detector.pixelVector(x+(gx+1)*stepSize, y+(gy+1)*stepSize)

                        # Grid with no margin:
                        #if gridSize &gt; 1:
                        #    stepSize = 1.0 / (gridSize-1)
                        #    pixel = self.detector.pixelVector(x+gx*stepSize, y+gy*stepSize)
                        #else:
                        #    pixel = self.detector.pixelVectorCenter(x, y)

                        distToSource = self.source.center.distance(pixel)

                        # Angle of incident rays:
                        vecSourceToPixel = Vector(pixel.x-sx, pixel.y-sy, pixel.z-sz)
                        incidenceAngle = abs(self.detector.w.angle(vecSourceToPixel))
                        if incidenceAngle &gt; (math.pi/2):
                            incidenceAngle = math.pi - incidenceAngle

                        intensityFactor = math.cos(incidenceAngle)*math.pow(SDD/distToSource, 2)
                        factorSum += intensityFactor

                intensityWeight = factorSum / gridSizeSq

                if intensityWeight &gt; maxIntensity:
                    maxIntensity = intensityWeight
                    maxX = x
                    maxY = y
                    minDistToSource = distToSource
                    brightestIncidenceAngle = incidenceAngle

                flatField.setPixel(x, y, intensityWeight)

            progress = 100*(float(x+1)/float(width))
            print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        return flatField

    def pixelAreaOnUnitSphere(self, A, B, C, D):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C, D must be vectors pointing to pixel corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()
        
        ACin  = A.cross(C)
        DAin  = D.cross(A)
        CDin  = C.cross(D)
        ACout = ACin.inverse()
        DAout = DAin.inverse()
        CDout = CDin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        # areaABC = alpha + beta + gamma - math.pi

        # Spherical Triangle ACD:
        rho   = ACin.angle(DAout)
        sigma = CDin.angle(ACout)
        tau   = DAin.angle(CDout)

        # areaACD = rho + tau + sigma - math.pi

        pxSphericalArea = (alpha + beta + gamma + rho + sigma + tau) - 2*math.pi

        return pxSphericalArea

    def triangleAreaOnUnitSphere(self, A, B, C):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        areaABC = alpha + beta + gamma - math.pi

        return areaABC

    def polygonAreaOnUnitSphere(self, polygon):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        if len(polygon.points) &gt;= 3:
            # Start at first point
            p1 = polygon.points[0]

            area = 0

            for i in range(1, len(polygon.points)-1):
                p2 = polygon.points[i]
                p3 = polygon.points[i+1]

                area += self.triangleAreaOnUnitSphere(p1, p2, p3)

            return area
        else:
            return 0

    &#34;&#34;&#34;
    def createDetectorFlatField_sphere_old(self, clippingPolygon=None):
        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = dist * math.cos(alpha)

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)

        print(&#34;SDD: {}&#34;.format(SDD))
        print(&#34;Pitch: {}, {}&#34;.format(hpu, hpv))
        #print(&#34;Brightest Pixel Area: {}&#34;.format(areaOfBrightestPixel))

        flatField = Image()
        flatField.shape(det.cols(), det.rows(), 0, flatField.getInternalDataType())

        maxArea = 0
        maxX = 0
        maxY = 0
        maxCenter = 0
        # Go through pixels:
        for x in range(det.cols()):
            for y in range(det.rows()):
                # Define Pixel corners:
                A = det.pixelVector(x,   y)
                B = det.pixelVector(x+1, y)
                C = det.pixelVector(x+1, y+1)
                D = det.pixelVector(x,   y+1)

                pxSphericalArea = self.pixelAreaOnUnitSphere(A, B, C, D)
                flatField.setPixel(x, y, pxSphericalArea)

                if pxSphericalArea &gt; maxArea:
                    maxArea = pxSphericalArea
                    maxX = x
                    maxY = y

            progress = 100*(float(x+1)/float(det.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)


        maxCenter = det.pixelVectorCenter(maxX, maxY)
        distToSource = maxCenter.length()
        incidenceAngle = abs(self.detector.w.angle(maxCenter))

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Vector: {}, {}, {}&#34;.format(maxCenter.x, maxCenter.y, maxCenter.z))
        print(&#34;  Distance to Source: {}&#34;.format(distToSource))
        print(&#34;  Spherical Area: {}&#34;.format(maxArea))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(incidenceAngle, 180*incidenceAngle/math.pi))

        return flatField
    &#34;&#34;&#34;

    def createDetectorFlatField_sphere(self, *coverPolygons):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Geometrical approach using spherical geometry. &#34;&#34;&#34;

        # Change to the detector coordinate system:
        D = copy.deepcopy(self.detector)
        S = copy.deepcopy(self.source)
        world = GeometryObject()  # will be initialized as world

        S.changeReferenceFrame(world, D)
        D.changeReferenceFrame(world, D)
        D.computeGeometryParameters()

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = abs(S.center.z)

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        pu = D.pitchU
        pv = D.pitchV
        nRows = D.rows()
        nCols = D.cols()

        hpu = 0.5*pu
        hpv = 0.5*pv
        pA = Vector(SDD,  hpu,  hpv)
        pB = Vector(SDD, -hpu,  hpv)
        pC = Vector(SDD, -hpu, -hpv)
        pD = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(pA, pB, pC, pD)

        # Full flat field image (without any clipping bodies):
        flatField = Image()
        flatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # A second image with a clipping body under consideration: (both will be returned)
        clippedFlatField = None
        if len(coverPolygons) &gt; 0:
            clippedFlatField = Image()
            clippedFlatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # Upper left detector corner in world coordinates (remember: world is now the detector CS)
        p00 = D.pixelVector(0, 0)

        stepRight      = Vector(pu, 0,  0)
        stepDown       = Vector(0,  pv, 0)
        stepRightDown  = Vector(pu, pv, 0)

        # Move the clipping polygon to a coordinate system
        # where source is centered:
        for coverPolygon in coverPolygons:
            for p in range(len(coverPolygon.points)):
                coverPolygon.points[p] = coverPolygon.points[p] - S.center

        # Go through pixels:
        for x in range(nCols):
            for y in range(nRows):
                # Pixel in world coordinates (remember: world is now the detector CS)
                shift = Vector(x*pu, y*pv, 0)

                # Define Pixel corners:
                pA = p00 + shift
                pB = pA  + stepRight
                pC = pA  + stepRightDown
                pD = pA  + stepDown

                # Center source at (0, 0, 0):
                pA = pA - S.center
                pB = pB - S.center
                pC = pC - S.center
                pD = pD - S.center

                pixelPolygon = Polygon(pA, pB, pC, pD)
                pxSphericalArea  = self.polygonAreaOnUnitSphere(pixelPolygon)

                flatField.setPixel(x, y, pxSphericalArea)

                if len(coverPolygons) &gt; 0:
                    for coverPolygon in coverPolygons:
                        pixelPolygon = pixelPolygon.clip(coverPolygon)
                        
                    # Remove the intensity covered by the clipping polygon:
                    pixelPolygon.make3D(zComponent=SDD)
                    subarea = self.polygonAreaOnUnitSphere(pixelPolygon)
                    pxSphericalArea -= subarea

                    clippedFlatField.setPixel(x, y, pxSphericalArea)

            progress = 100*(float(x+1)/float(D.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)
        if clippedFlatField != None:
            clippedFlatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)

        return flatField, clippedFlatField

    def solidAngle(self, l, m):
        &#34;&#34;&#34; Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth. &#34;&#34;&#34;
        if l != 0:
            return (l/abs(l)) * math.atan(abs(l)*m/math.sqrt(1.0+l**2+m**2))
        else:
            return 0

    def createDetectorFlatField_analytical(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Analytical approach by Florian Wohlgemuth. &#34;&#34;&#34;

        width  = self.detector.cols()
        height = self.detector.rows()
        pitchU = self.detector.pitchU
        pitchV = self.detector.pitchV

        if(width == None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height == None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchU == None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchV == None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        maxIntensity = 0
        maxX = 0
        maxY = 0

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        upperLeft_u = det.pixelVector(0, 0).dot(self.detector.u)
        upperLeft_v = det.pixelVector(0, 0).dot(self.detector.v)
        upperLeft_w = det.pixelVector(0, 0).dot(self.detector.w)

        if upperLeft_w != 0:   # check if detector is not facing its edge towards the source
            for x in range(width):
                for y in range(height):
                    nu = x
                    nv = y
                    lambda0 = (upperLeft_u + nu*pitchU) / upperLeft_w
                    lambda1 = (upperLeft_u + (nu+1)*pitchU) / upperLeft_w
                    mu0     = (upperLeft_v + nv*pitchV) / upperLeft_w
                    mu1     = (upperLeft_v + (nv+1)*pitchV) / upperLeft_w

                    omega = self.solidAngle(lambda0, mu0) + self.solidAngle(lambda1, mu1) - self.solidAngle(lambda0, mu1) - self.solidAngle(lambda1, mu0)

                    if omega &gt; maxIntensity:
                        maxIntensity = omega
                        maxX = x
                        maxY = y

                    flatField.setPixel(x, y, omega)

                progress = 100*(float(x+1)/float(width))
                print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        # print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        # print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        # Method #1: find hypothetical brightest pixel
        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale actual maximum to 1.
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, dataType=&#34;float32&#34;)
        return flatField


    def createDetectorFlatField(self):
        return createDetectorFlatField_analytical()

def writeCERAconfig(geo, totalAngle, projectionFilePattern, matrices, basename, voxelsX, voxelsY, voxelsZ, i0max=60000):
    now = datetime.now()

    nProjections = len(matrices)
    projTableString = &#34;&#34;&#34;projtable.txt version 3
{timestring}

# format: angle / entries of projection matrices
{nProjections}
&#34;&#34;&#34;.format(
    nProjections=nProjections,
    timestring=now.strftime(&#34;%a %b %d %H:%M:%S %Y&#34;)
    )

    for i in range(nProjections):
        m=matrices[i]
        projTableString += &#34;&#34;&#34;@{nr}
0.0 0.0
{c00} {c01} {c02} {c03}
{c10} {c11} {c12} {c13}
{c20} {c21} {c22} {c23}

&#34;&#34;&#34;.format(
        nr=(i+1),
        c00=m.get(col=0, row=0),
        c01=m.get(col=1, row=0),
        c02=m.get(col=2, row=0),
        c03=m.get(col=3, row=0),
        c10=m.get(col=0, row=1),
        c11=m.get(col=1, row=1),
        c12=m.get(col=2, row=1),
        c13=m.get(col=3, row=1),
        c20=m.get(col=0, row=2),
        c21=m.get(col=1, row=2),
        c22=m.get(col=2, row=2),
        c23=m.get(col=3, row=2)
    )

    with open(&#34;{}_projtable.txt&#34;.format(basename), &#39;w&#39;) as f:
        f.write(projTableString)
        f.close()

    voxelSizeXY = geo.detector.pitchU * geo.SOD / geo.SDD
    voxelSizeZ  = geo.detector.pitchV * geo.SOD / geo.SDD

    configFileString = &#34;&#34;&#34;#CERACONFIG

[Projections]
NumChannelsPerRow = {nCols}
NumRows = {nRows}
PixelSizeU = {psu}
PixelSizeV = {psv}
Rotation = None
FlipU = false
FlipV = true
Padding = 0
BigEndian = false
CropBorderRight = 0
CropBorderLeft = 0
CropBorderTop = 0
CropBorderBottom = 0
BinningFactor = None
SkipProjectionInterval = 1
ProjectionDataDomain = Intensity
RawHeaderSize = 0

[Volume]
SizeX = {volx}
SizeY = {voly}
SizeZ = {volz}
# Midpoints are only necessary for reconstructions
# without projection matrices.
MidpointX = {midpointx}
MidpointY = {midpointy}
MidpointZ = {midpointz}
VoxelSizeX = {vsx}
VoxelSizeY = {vsy}
VoxelSizeZ = {vsz}
Datatype = float

[CustomKeys]
NumProjections = {nProjections}    
ProjectionFileType = tiff
VolumeOutputPath = {basename}.raw
ProjectionStartNum = 0
ProjectionFilenameMask = {projFilePattern}

[CustomKeys.ProjectionMatrices]
SourceObjectDistance = {SOD}
SourceImageDistance = {SDD}
DetectorOffsetU = {offu}
DetectorOffsetV = {offv}
StartAngle = {startAngle}
ScanAngle = {scanAngle}
AquisitionDirection = CW
a = {a}
b = {b}
c = {c}
ProjectionMatrixFilename = {basename}_projtable.txt

[Backprojection]
ClearOutOfRegionVoxels = false
InterpolationMode = bilinear
FloatingPointPrecision = half
Enabled = true

[Filtering]
Enabled = true
Kernel = shepp

[I0Log]
Enabled = true
Epsilon = 1.0E-5
GlobalI0Value = {i0max}
&#34;&#34;&#34;.format(
    basename=basename,
    nCols=int(geo.detector.cols()),
    nRows=int(geo.detector.rows()),
    psu=geo.detector.pitchU,
    psv=geo.detector.pitchV,
    volx=int(voxelsX),
    voly=int(voxelsY),
    volz=int(voxelsZ),
    midpointx=0, #!
    midpointy=0, #!
    midpointz=0, #!
    vsx=voxelSizeXY,
    vsy=voxelSizeXY,
    vsz=voxelSizeZ,
    nProjections=int(nProjections),
    projFilePattern=projectionFilePattern,
    SOD=geo.SOD,
    SDD=geo.SDD,
    offu=0, #!
    offv=0, #!
    startAngle=0, #!
    scanAngle=totalAngle,
    a=0, #!
    b=0, #!
    c=0, #!
    i0max=i0max
    )

    with open(&#34;{}.config&#34;.format(basename), &#39;w&#39;) as f:
        f.write(configFileString)
        f.close()


def writeOpenCTFile(geo, totalAngle, boundingBoxX, boundingBoxY, boundingBoxZ, matrices, filename, volumename, projectionFilenames):
    nProjections = len(matrices)
    matrixString = &#34;&#34;

    i = 0
    for m in matrices:
        if i&gt;0:
            matrixString += &#34;,\n\n            &#34;

        matrixString += &#34;[ &#34;
        for row in range(m.rows):
            if row &gt; 0:
                matrixString += &#34;,\n              &#34;
            matrixString += &#34;[&#34;
            for col in range(m.cols):
                if col &gt; 0:
                    matrixString += &#34;, &#34;

                matrixString += &#34;{}&#34;.format(m.get(col=col, row=row))
            matrixString += &#34;]&#34;
        matrixString += &#34; ]&#34;
        i += 1

    filesString = &#34;&#34;
    if len(matrices) == len(projectionFilenames):
        for i in range(len(matrices)):
            if i &gt; 0:
                filesString += &#34;,\n                &#34;
            #filesString += &#39;&#34;{:05d}.tif&#34;&#39;.format(i)
            filesString += &#39;&#34;{}&#34;&#39;.format(projectionFilenames[i])
    else:
        raise Exception(&#34;The number of projection matrices ({}) does not match the number of projection file names ({}).&#34;.format(len(matrices), len(projectionFilenames)))


    content = &#34;&#34;&#34;{{
    &#34;version&#34;: {{&#34;major&#34;:1, &#34;minor&#34;:0}},
    &#34;openCTJSON&#34;:     {{
        &#34;versionMajor&#34;: 1,
        &#34;versionMinor&#34;: 0,
        &#34;revisionNumber&#34;: 0,
        &#34;variant&#34;: &#34;FreeTrajectoryCBCTScan&#34;
    }},
    &#34;units&#34;: {{
        &#34;length&#34;: &#34;Millimeter&#34;
    }},
    &#34;volumeName&#34;:  &#34;{volumeName}&#34;,
    &#34;projections&#34;: {{
        &#34;numProjections&#34;:  {nProjections},
        &#34;intensityDomain&#34;: true,
        &#34;images&#34;:          {{
            &#34;directory&#34;: &#34;.&#34;,
            &#34;dataType&#34;:  &#34;UInt16&#34;,
            &#34;fileType&#34;:  &#34;TIFF&#34;,
            &#34;files&#34;:     [
                {filesString}
            ]
        }},
        &#34;matrices&#34;: [
            {matrixString}
        ]
    }},
    &#34;geometry&#34;:    {{
        &#34;totalAngle&#34;:           {totalAngle},
        &#34;skipAngle&#34;:            0,
        &#34;detectorPixel&#34;:        [
            {nPixelsX},
            {nPixelsY}
        ],
        &#34;detectorSize&#34;:         [
            {detectorSizeX},
            {detectorSizeY}
        ],
        &#34;mirrorDetectorAxis&#34;:   &#34;&#34;,
        &#34;distanceSourceObject&#34;: {SOD},
        &#34;distanceObjectDetector&#34;: {ODD},
        &#34;objectBoundingBox&#34;:    [
            [
                {bbx},
                0.0,
                0.0,
                0.0
            ],
            [
                0.0,
                {bby},
                0.0,
                0.0
            ],
            [
                0.0,
                0.0,
                {bbz},
                0.0
            ],
            [
                0.0,
                0.0,
                0.0,
                1.0
            ]
        ]
    }},
    &#34;corrections&#34;: {{
        &#34;brightImages&#34;: {{
            &#34;directory&#34;: &#34;&#34;,
            &#34;dataType&#34;:  &#34;&#34;,
            &#34;fileType&#34;:  &#34;&#34;,
            &#34;files&#34;:     []
        }},
        &#34;darkImage&#34;:    {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;badPixelMask&#34;: {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;intensities&#34;:  []
    }}
}}&#34;&#34;&#34;.format(
    nProjections=nProjections,
    matrixString=matrixString,
    nPixelsX=int(geo.detector.cols()),
    nPixelsY=int(geo.detector.rows()),
    detectorSizeX=geo.detector.physWidth,
    detectorSizeY=geo.detector.physHeight,
    SOD=geo.SOD,
    ODD=geo.ODD,
    totalAngle=totalAngle,
    bbx=boundingBoxX,
    bby=boundingBoxY,
    bbz=boundingBoxZ,
    filesString=filesString,
    volumeName=volumename
    )

    with open(filename, &#39;w&#39;) as f:
        f.write(content)
        f.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctsimu.geometry.basisTransformMatrix"><code class="name flex">
<span>def <span class="ident">basisTransformMatrix</span></span>(<span>fromCS:<a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a>, toCS:<a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a>) ><a title="ctsimu.primitives.Matrix" href="primitives.html#ctsimu.primitives.Matrix">Matrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a matrix that transforms coordinates from <code>fromCS</code> to <code>toCS</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></dt>
<dd>The origin coordinate system.</dd>
<dt><strong><code>toCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></dt>
<dd>The target coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>The 3x3 basis transformation matrix.</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li>S. Widnall: <a href="https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec03.pdf">Lecture L3 - Vectors, Matrices and Coordinate Transformations</a></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def basisTransformMatrix(fromCS:&#39;GeometryObject&#39;, toCS:&#39;GeometryObject&#39;) -&gt; Matrix:
    &#34;&#34;&#34;Calculate a matrix that transforms coordinates from `fromCS` to `toCS`.

    Parameters
    ----------
    fromCS : GeometryObject
        The origin coordinate system.

    toCS : GeometryObject
        The target coordinate system.

    Returns
    -------
    T : Matrix
        The 3x3 basis transformation matrix.

    References
    ----------
    * S. Widnall: [Lecture L3 - Vectors, Matrices and Coordinate Transformations]
    [Lecture L3 - Vectors, Matrices and Coordinate Transformations]: https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec03.pdf
    &#34;&#34;&#34;

    T = Matrix(3, 3)

    # Row 1:
    T.value[0][0] = toCS.u.unitVector().dot(fromCS.u.unitVector())
    T.value[0][1] = toCS.u.unitVector().dot(fromCS.v.unitVector())
    T.value[0][2] = toCS.u.unitVector().dot(fromCS.w.unitVector())

    # Row 2:
    T.value[1][0] = toCS.v.unitVector().dot(fromCS.u.unitVector())
    T.value[1][1] = toCS.v.unitVector().dot(fromCS.v.unitVector())
    T.value[1][2] = toCS.v.unitVector().dot(fromCS.w.unitVector())

    # Row 3:
    T.value[2][0] = toCS.w.unitVector().dot(fromCS.u.unitVector())
    T.value[2][1] = toCS.w.unitVector().dot(fromCS.v.unitVector())
    T.value[2][2] = toCS.w.unitVector().dot(fromCS.w.unitVector())

    return T</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.writeCERAconfig"><code class="name flex">
<span>def <span class="ident">writeCERAconfig</span></span>(<span>geo, totalAngle, projectionFilePattern, matrices, basename, voxelsX, voxelsY, voxelsZ, i0max=60000)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeCERAconfig(geo, totalAngle, projectionFilePattern, matrices, basename, voxelsX, voxelsY, voxelsZ, i0max=60000):
    now = datetime.now()

    nProjections = len(matrices)
    projTableString = &#34;&#34;&#34;projtable.txt version 3
{timestring}

# format: angle / entries of projection matrices
{nProjections}
&#34;&#34;&#34;.format(
    nProjections=nProjections,
    timestring=now.strftime(&#34;%a %b %d %H:%M:%S %Y&#34;)
    )

    for i in range(nProjections):
        m=matrices[i]
        projTableString += &#34;&#34;&#34;@{nr}
0.0 0.0
{c00} {c01} {c02} {c03}
{c10} {c11} {c12} {c13}
{c20} {c21} {c22} {c23}

&#34;&#34;&#34;.format(
        nr=(i+1),
        c00=m.get(col=0, row=0),
        c01=m.get(col=1, row=0),
        c02=m.get(col=2, row=0),
        c03=m.get(col=3, row=0),
        c10=m.get(col=0, row=1),
        c11=m.get(col=1, row=1),
        c12=m.get(col=2, row=1),
        c13=m.get(col=3, row=1),
        c20=m.get(col=0, row=2),
        c21=m.get(col=1, row=2),
        c22=m.get(col=2, row=2),
        c23=m.get(col=3, row=2)
    )

    with open(&#34;{}_projtable.txt&#34;.format(basename), &#39;w&#39;) as f:
        f.write(projTableString)
        f.close()

    voxelSizeXY = geo.detector.pitchU * geo.SOD / geo.SDD
    voxelSizeZ  = geo.detector.pitchV * geo.SOD / geo.SDD

    configFileString = &#34;&#34;&#34;#CERACONFIG

[Projections]
NumChannelsPerRow = {nCols}
NumRows = {nRows}
PixelSizeU = {psu}
PixelSizeV = {psv}
Rotation = None
FlipU = false
FlipV = true
Padding = 0
BigEndian = false
CropBorderRight = 0
CropBorderLeft = 0
CropBorderTop = 0
CropBorderBottom = 0
BinningFactor = None
SkipProjectionInterval = 1
ProjectionDataDomain = Intensity
RawHeaderSize = 0

[Volume]
SizeX = {volx}
SizeY = {voly}
SizeZ = {volz}
# Midpoints are only necessary for reconstructions
# without projection matrices.
MidpointX = {midpointx}
MidpointY = {midpointy}
MidpointZ = {midpointz}
VoxelSizeX = {vsx}
VoxelSizeY = {vsy}
VoxelSizeZ = {vsz}
Datatype = float

[CustomKeys]
NumProjections = {nProjections}    
ProjectionFileType = tiff
VolumeOutputPath = {basename}.raw
ProjectionStartNum = 0
ProjectionFilenameMask = {projFilePattern}

[CustomKeys.ProjectionMatrices]
SourceObjectDistance = {SOD}
SourceImageDistance = {SDD}
DetectorOffsetU = {offu}
DetectorOffsetV = {offv}
StartAngle = {startAngle}
ScanAngle = {scanAngle}
AquisitionDirection = CW
a = {a}
b = {b}
c = {c}
ProjectionMatrixFilename = {basename}_projtable.txt

[Backprojection]
ClearOutOfRegionVoxels = false
InterpolationMode = bilinear
FloatingPointPrecision = half
Enabled = true

[Filtering]
Enabled = true
Kernel = shepp

[I0Log]
Enabled = true
Epsilon = 1.0E-5
GlobalI0Value = {i0max}
&#34;&#34;&#34;.format(
    basename=basename,
    nCols=int(geo.detector.cols()),
    nRows=int(geo.detector.rows()),
    psu=geo.detector.pitchU,
    psv=geo.detector.pitchV,
    volx=int(voxelsX),
    voly=int(voxelsY),
    volz=int(voxelsZ),
    midpointx=0, #!
    midpointy=0, #!
    midpointz=0, #!
    vsx=voxelSizeXY,
    vsy=voxelSizeXY,
    vsz=voxelSizeZ,
    nProjections=int(nProjections),
    projFilePattern=projectionFilePattern,
    SOD=geo.SOD,
    SDD=geo.SDD,
    offu=0, #!
    offv=0, #!
    startAngle=0, #!
    scanAngle=totalAngle,
    a=0, #!
    b=0, #!
    c=0, #!
    i0max=i0max
    )

    with open(&#34;{}.config&#34;.format(basename), &#39;w&#39;) as f:
        f.write(configFileString)
        f.close()</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.writeOpenCTFile"><code class="name flex">
<span>def <span class="ident">writeOpenCTFile</span></span>(<span>geo, totalAngle, boundingBoxX, boundingBoxY, boundingBoxZ, matrices, filename, volumename, projectionFilenames)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeOpenCTFile(geo, totalAngle, boundingBoxX, boundingBoxY, boundingBoxZ, matrices, filename, volumename, projectionFilenames):
    nProjections = len(matrices)
    matrixString = &#34;&#34;

    i = 0
    for m in matrices:
        if i&gt;0:
            matrixString += &#34;,\n\n            &#34;

        matrixString += &#34;[ &#34;
        for row in range(m.rows):
            if row &gt; 0:
                matrixString += &#34;,\n              &#34;
            matrixString += &#34;[&#34;
            for col in range(m.cols):
                if col &gt; 0:
                    matrixString += &#34;, &#34;

                matrixString += &#34;{}&#34;.format(m.get(col=col, row=row))
            matrixString += &#34;]&#34;
        matrixString += &#34; ]&#34;
        i += 1

    filesString = &#34;&#34;
    if len(matrices) == len(projectionFilenames):
        for i in range(len(matrices)):
            if i &gt; 0:
                filesString += &#34;,\n                &#34;
            #filesString += &#39;&#34;{:05d}.tif&#34;&#39;.format(i)
            filesString += &#39;&#34;{}&#34;&#39;.format(projectionFilenames[i])
    else:
        raise Exception(&#34;The number of projection matrices ({}) does not match the number of projection file names ({}).&#34;.format(len(matrices), len(projectionFilenames)))


    content = &#34;&#34;&#34;{{
    &#34;version&#34;: {{&#34;major&#34;:1, &#34;minor&#34;:0}},
    &#34;openCTJSON&#34;:     {{
        &#34;versionMajor&#34;: 1,
        &#34;versionMinor&#34;: 0,
        &#34;revisionNumber&#34;: 0,
        &#34;variant&#34;: &#34;FreeTrajectoryCBCTScan&#34;
    }},
    &#34;units&#34;: {{
        &#34;length&#34;: &#34;Millimeter&#34;
    }},
    &#34;volumeName&#34;:  &#34;{volumeName}&#34;,
    &#34;projections&#34;: {{
        &#34;numProjections&#34;:  {nProjections},
        &#34;intensityDomain&#34;: true,
        &#34;images&#34;:          {{
            &#34;directory&#34;: &#34;.&#34;,
            &#34;dataType&#34;:  &#34;UInt16&#34;,
            &#34;fileType&#34;:  &#34;TIFF&#34;,
            &#34;files&#34;:     [
                {filesString}
            ]
        }},
        &#34;matrices&#34;: [
            {matrixString}
        ]
    }},
    &#34;geometry&#34;:    {{
        &#34;totalAngle&#34;:           {totalAngle},
        &#34;skipAngle&#34;:            0,
        &#34;detectorPixel&#34;:        [
            {nPixelsX},
            {nPixelsY}
        ],
        &#34;detectorSize&#34;:         [
            {detectorSizeX},
            {detectorSizeY}
        ],
        &#34;mirrorDetectorAxis&#34;:   &#34;&#34;,
        &#34;distanceSourceObject&#34;: {SOD},
        &#34;distanceObjectDetector&#34;: {ODD},
        &#34;objectBoundingBox&#34;:    [
            [
                {bbx},
                0.0,
                0.0,
                0.0
            ],
            [
                0.0,
                {bby},
                0.0,
                0.0
            ],
            [
                0.0,
                0.0,
                {bbz},
                0.0
            ],
            [
                0.0,
                0.0,
                0.0,
                1.0
            ]
        ]
    }},
    &#34;corrections&#34;: {{
        &#34;brightImages&#34;: {{
            &#34;directory&#34;: &#34;&#34;,
            &#34;dataType&#34;:  &#34;&#34;,
            &#34;fileType&#34;:  &#34;&#34;,
            &#34;files&#34;:     []
        }},
        &#34;darkImage&#34;:    {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;badPixelMask&#34;: {{
            &#34;file&#34;:     &#34;&#34;,
            &#34;dataType&#34;: &#34;&#34;,
            &#34;fileType&#34;: &#34;&#34;
        }},
        &#34;intensities&#34;:  []
    }}
}}&#34;&#34;&#34;.format(
    nProjections=nProjections,
    matrixString=matrixString,
    nPixelsX=int(geo.detector.cols()),
    nPixelsY=int(geo.detector.rows()),
    detectorSizeX=geo.detector.physWidth,
    detectorSizeY=geo.detector.physHeight,
    SOD=geo.SOD,
    ODD=geo.ODD,
    totalAngle=totalAngle,
    bbx=boundingBoxX,
    bby=boundingBoxY,
    bbz=boundingBoxZ,
    filesString=filesString,
    volumeName=volumename
    )

    with open(filename, &#39;w&#39;) as f:
        f.write(content)
        f.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.geometry.Detector"><code class="flex name class">
<span>class <span class="ident">Detector</span></span>
</code></dt>
<dd>
<div class="desc"><p>Detector as geometrical object.</p>
<p>With additional attributes for the spatial extension and
the pixel coordinate system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pixelsU</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in u direction.</dd>
<dt><strong><code>pixelsV</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in v direction.</dd>
<dt><strong><code>pitchU</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of a pixel in u direction.
In units of the reference coordinate system.</dd>
<dt><strong><code>pitchV</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of a pixel in v direction.
In units of the reference coordinate system.</dd>
<dt><strong><code>physWidth</code></strong> :&ensp;<code>float</code></dt>
<dd>Physical size in u direction.
In units of the reference coordinate system.
Computed automatically after calling <code>setSize()</code>.</dd>
<dt><strong><code>physHeight</code></strong> :&ensp;<code>float</code></dt>
<dd>Physical size in v direction.
In units of the reference coordinate system.
Computed automatically after calling <code>setSize()</code>.</dd>
<dt><strong><code>pixelOrigin</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Origin of the pixel coordinate system in terms of the reference
coordinate system. This is the outermost corner of the
(0,0) pixel of the detector (often the "upper left" corner).
Computed automatically after calling <code>setSize()</code>.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>setSize(nPixelsU, nPixelsV, pitchU, pitchV)
Set the physical size of the detector.</p>
<p>computeGeometryParameters()
Calculate the physical width and height,
and the position of the pixel coordinate system origin.</p>
<p>cols()
Returns the number of detector columns (i.e., pixels in u direction).</p>
<p>rows()
Returns the number of detector rows (i.e., pixels in v direction).</p>
<p>pixelVector(x, y)
World position vector for given pixel coordinate.</p>
<p>pixelVectorCenter(x, y)
World position vector of pixel center,
for a pixel identified by its integer coordinates.</p>
<h2 id="notes">Notes</h2>
<p>Use <code>setSize()</code> to set the size of the detector, given its number of pixels
and the pitch. This function automatically computes the physical dimensions
<code>physWidth</code> and <code>physHeight</code> and the origin of the pixel coordinate system.</p>
<p>Initialize as a standard GeometryObject.</p>
<p>Orientation, position and size must be set up manually afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Detector(GeometryObject):
    &#34;&#34;&#34;Detector as geometrical object.

    With additional attributes for the spatial extension and
    the pixel coordinate system.

    Attributes
    ----------
    pixelsU : int
        Number of pixels in u direction.
    
    pixelsV : int
        Number of pixels in v direction.
    
    pitchU : float
        Size of a pixel in u direction.
        In units of the reference coordinate system.
    
    pitchV : float
        Size of a pixel in v direction.
        In units of the reference coordinate system.
    
    physWidth : float
        Physical size in u direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
    
    physHeight : float
        Physical size in v direction.
        In units of the reference coordinate system.
        Computed automatically after calling `setSize()`.
 
    pixelOrigin : Vector
        Origin of the pixel coordinate system in terms of the reference
        coordinate system. This is the outermost corner of the
        (0,0) pixel of the detector (often the &#34;upper left&#34; corner).
        Computed automatically after calling `setSize()`.

    Methods
    -------
    setSize(nPixelsU, nPixelsV, pitchU, pitchV)
        Set the physical size of the detector.

    computeGeometryParameters()
        Calculate the physical width and height,
        and the position of the pixel coordinate system origin.

    cols()
        Returns the number of detector columns (i.e., pixels in u direction).

    rows()
        Returns the number of detector rows (i.e., pixels in v direction).

    pixelVector(x, y)
        World position vector for given pixel coordinate.

    pixelVectorCenter(x, y)
        World position vector of pixel center,
        for a pixel identified by its integer coordinates.

    Notes
    -----
    Use `setSize()` to set the size of the detector, given its number of pixels
    and the pitch. This function automatically computes the physical dimensions
    `physWidth` and `physHeight` and the origin of the pixel coordinate system.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard GeometryObject.

        Orientation, position and size must be set up manually afterwards.
        &#34;&#34;&#34;

        # Call init from parent class:
        GeometryObject.__init__(self)

        self.pixelsU     = None  # Detector pixels in u direction
        self.pixelsV     = None  # Detector pixels in v direction
        self.pitchU = None  # Size of a pixel in u direction in units of reference coordinate system
        self.pitchV = None  # Size of a pixel in v direction in units of reference coordinate system
        self.physWidth   = 0    # Physical width in units of reference coordinate system
        self.physHeight  = 0    # Physical height in units of reference coordinate system

        self.pixelOrigin = Vector()  # origin of pixel coordinate system in terms of reference coordinate system

    def setSize(self, nPixelsU:int = None, nPixelsV:int = None, pitchU:float = None, pitchV:float = None):
        &#34;&#34;&#34;Set the physical size of the detector.

        From the given parameters (number of pixels and pitch), the physical
        size of the detector and the position of the origin of the pixel
        coordinate system will be calculated. Make sure that the orientation
        vectors and position of the detector are correct before calling
        `setSize()`, or call `computeGeometryParameters()` if you update
        the detector orientation or position later on.

        Parameters
        ----------
        nPixelsU : int
            Number of pixels in u direction.

        nPixelsV : int
            Number of pixels in v direction.

        pitchU : float
            Pixel pitch in u direction.

        pitchV : float
            Pixel pitch in v direction.
        &#34;&#34;&#34;

        self.pixelsU = int(nPixelsU)
        self.pixelsV = int(nPixelsV)
        self.pitchU = float(pitchU)
        self.pitchV = float(pitchV)

        self.computeGeometryParameters()

    def computeGeometryParameters(self):
        &#34;&#34;&#34;Calculate the physical width and height, and the position of the
        pixel coordinate system origin.

        These calculations assume that the size, position and
        orientation of the detector are correctly set up.

        Results are assigned to their member variables (attributes).
        &#34;&#34;&#34;

        if (self.pixelsU is not None) and (self.pixelsV is not None) and (self.pitchU is not None) and (self.pitchV is not None):
            # Physical width and height:
            self.physWidth  = self.pixelsU * self.pitchU
            self.physHeight = self.pixelsV * self.pitchV

            # Vectors of the detector coordinate system:
            ux = self.u.unitVector().x
            uy = self.u.unitVector().y
            uz = self.u.unitVector().z
            vx = self.v.unitVector().x
            vy = self.v.unitVector().y
            vz = self.v.unitVector().z

            # World coordinates of origin (0,0) of detector&#39;s pixel coordinate system:
            self.pixelOrigin.x = self.center.x - 0.5*(ux*self.physWidth + vx*self.physHeight)
            self.pixelOrigin.y = self.center.y - 0.5*(uy*self.physWidth + vy*self.physHeight)
            self.pixelOrigin.z = self.center.z - 0.5*(uz*self.physWidth + vz*self.physHeight)

    def cols(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector columns (i.e., pixels in u direction).

        Returns
        -------
        pixelsU : int
            Number of detector columns (i.e., pixels in u direction).
        &#34;&#34;&#34;
        return self.pixelsU

    def rows(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of detector rows (i.e., pixels in v direction).

        Returns
        -------
        pixelsV : int
            Number of detector rows (i.e., pixels in v direction).
        &#34;&#34;&#34;
        return self.pixelsV

    def pixelVector(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector for given pixel coordinate.

        The pixel coordinate system has its origin at the detector corner with
        the lowest coordinate in terms of its u and v basis vectors. Typically,
        this is the upper left corner, but your arrangement may differ.

        Integer coordinates always refer to the pixel corner that is closest to
        the origin of the pixel coordinate system, whereas the center of a pixel
        therefore has a &#34;.5&#34; coordinate in the pixel coordinate system.
        For example, the first pixel (0, 0) would have center coordinates
        (0.5, 0.5).

        To get the center coordinates for a given integer pixel location,
        `pixelVectorCenter()` may be used.

        Parameters
        ----------
        x : float
            x position in pixel coordinate system.

        y : float
            y position in pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Pixel position in reference coordinate system (usually world)
            as a 3D vector.
        &#34;&#34;&#34;

        # x, y are coordinates in pixel coordinates system
        px = self.pixelOrigin.x + self.u.x*x*self.pitchU + self.v.x*y*self.pitchV
        py = self.pixelOrigin.y + self.u.y*x*self.pitchU + self.v.y*y*self.pitchV
        pz = self.pixelOrigin.z + self.u.z*x*self.pitchU + self.v.z*y*self.pitchV
        pixelVector = Vector(px, py, pz)
        return pixelVector

    def pixelVectorCenter(self, x: float, y: float) -&gt; Vector:
        &#34;&#34;&#34;World position vector of pixel center, for a pixel given in integer coordinates.

        Parameters
        ----------
        x : float
            Integer x coordinate, specifies a pixel in the pixel coordinate system.

        y : float
            Integer y coordinate, specifies a pixel in the pixel coordinate system.

        Returns
        -------
        pixelVector : Vector
            Position of the pixel center in the reference coordinate system
            (usually world) as a 3D vector.

        Notes
        -----
        If `float` coordinates are passed (non-integer),
        they are converted to integers using `math.floor`.
        &#34;&#34;&#34;
        return self.pixelVector(float(math.floor(x))+0.5, float(math.floor(y))+0.5)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.Detector.cols"><code class="name flex">
<span>def <span class="ident">cols</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of detector columns (i.e., pixels in u direction).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelsU</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of detector columns (i.e., pixels in u direction).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cols(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of detector columns (i.e., pixels in u direction).

    Returns
    -------
    pixelsU : int
        Number of detector columns (i.e., pixels in u direction).
    &#34;&#34;&#34;
    return self.pixelsU</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.computeGeometryParameters"><code class="name flex">
<span>def <span class="ident">computeGeometryParameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the physical width and height, and the position of the
pixel coordinate system origin.</p>
<p>These calculations assume that the size, position and
orientation of the detector are correctly set up.</p>
<p>Results are assigned to their member variables (attributes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeGeometryParameters(self):
    &#34;&#34;&#34;Calculate the physical width and height, and the position of the
    pixel coordinate system origin.

    These calculations assume that the size, position and
    orientation of the detector are correctly set up.

    Results are assigned to their member variables (attributes).
    &#34;&#34;&#34;

    if (self.pixelsU is not None) and (self.pixelsV is not None) and (self.pitchU is not None) and (self.pitchV is not None):
        # Physical width and height:
        self.physWidth  = self.pixelsU * self.pitchU
        self.physHeight = self.pixelsV * self.pitchV

        # Vectors of the detector coordinate system:
        ux = self.u.unitVector().x
        uy = self.u.unitVector().y
        uz = self.u.unitVector().z
        vx = self.v.unitVector().x
        vy = self.v.unitVector().y
        vz = self.v.unitVector().z

        # World coordinates of origin (0,0) of detector&#39;s pixel coordinate system:
        self.pixelOrigin.x = self.center.x - 0.5*(ux*self.physWidth + vx*self.physHeight)
        self.pixelOrigin.y = self.center.y - 0.5*(uy*self.physWidth + vy*self.physHeight)
        self.pixelOrigin.z = self.center.z - 0.5*(uz*self.physWidth + vz*self.physHeight)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.pixelVector"><code class="name flex">
<span>def <span class="ident">pixelVector</span></span>(<span>self, x:float, y:float) ><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>World position vector for given pixel coordinate.</p>
<p>The pixel coordinate system has its origin at the detector corner with
the lowest coordinate in terms of its u and v basis vectors. Typically,
this is the upper left corner, but your arrangement may differ.</p>
<p>Integer coordinates always refer to the pixel corner that is closest to
the origin of the pixel coordinate system, whereas the center of a pixel
therefore has a ".5" coordinate in the pixel coordinate system.
For example, the first pixel (0, 0) would have center coordinates
(0.5, 0.5).</p>
<p>To get the center coordinates for a given integer pixel location,
<code>pixelVectorCenter()</code> may be used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>x position in pixel coordinate system.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>y position in pixel coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelVector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Pixel position in reference coordinate system (usually world)
as a 3D vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixelVector(self, x: float, y: float) -&gt; Vector:
    &#34;&#34;&#34;World position vector for given pixel coordinate.

    The pixel coordinate system has its origin at the detector corner with
    the lowest coordinate in terms of its u and v basis vectors. Typically,
    this is the upper left corner, but your arrangement may differ.

    Integer coordinates always refer to the pixel corner that is closest to
    the origin of the pixel coordinate system, whereas the center of a pixel
    therefore has a &#34;.5&#34; coordinate in the pixel coordinate system.
    For example, the first pixel (0, 0) would have center coordinates
    (0.5, 0.5).

    To get the center coordinates for a given integer pixel location,
    `pixelVectorCenter()` may be used.

    Parameters
    ----------
    x : float
        x position in pixel coordinate system.

    y : float
        y position in pixel coordinate system.

    Returns
    -------
    pixelVector : Vector
        Pixel position in reference coordinate system (usually world)
        as a 3D vector.
    &#34;&#34;&#34;

    # x, y are coordinates in pixel coordinates system
    px = self.pixelOrigin.x + self.u.x*x*self.pitchU + self.v.x*y*self.pitchV
    py = self.pixelOrigin.y + self.u.y*x*self.pitchU + self.v.y*y*self.pitchV
    pz = self.pixelOrigin.z + self.u.z*x*self.pitchU + self.v.z*y*self.pitchV
    pixelVector = Vector(px, py, pz)
    return pixelVector</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.pixelVectorCenter"><code class="name flex">
<span>def <span class="ident">pixelVectorCenter</span></span>(<span>self, x:float, y:float) ><a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>World position vector of pixel center, for a pixel given in integer coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Integer x coordinate, specifies a pixel in the pixel coordinate system.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Integer y coordinate, specifies a pixel in the pixel coordinate system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelVector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Position of the pixel center in the reference coordinate system
(usually world) as a 3D vector.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If <code>float</code> coordinates are passed (non-integer),
they are converted to integers using <code>math.floor</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixelVectorCenter(self, x: float, y: float) -&gt; Vector:
    &#34;&#34;&#34;World position vector of pixel center, for a pixel given in integer coordinates.

    Parameters
    ----------
    x : float
        Integer x coordinate, specifies a pixel in the pixel coordinate system.

    y : float
        Integer y coordinate, specifies a pixel in the pixel coordinate system.

    Returns
    -------
    pixelVector : Vector
        Position of the pixel center in the reference coordinate system
        (usually world) as a 3D vector.

    Notes
    -----
    If `float` coordinates are passed (non-integer),
    they are converted to integers using `math.floor`.
    &#34;&#34;&#34;
    return self.pixelVector(float(math.floor(x))+0.5, float(math.floor(y))+0.5)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.rows"><code class="name flex">
<span>def <span class="ident">rows</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of detector rows (i.e., pixels in v direction).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelsV</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of detector rows (i.e., pixels in v direction).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rows(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of detector rows (i.e., pixels in v direction).

    Returns
    -------
    pixelsV : int
        Number of detector rows (i.e., pixels in v direction).
    &#34;&#34;&#34;
    return self.pixelsV</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Detector.setSize"><code class="name flex">
<span>def <span class="ident">setSize</span></span>(<span>self, nPixelsU:int=None, nPixelsV:int=None, pitchU:float=None, pitchV:float=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the physical size of the detector.</p>
<p>From the given parameters (number of pixels and pitch), the physical
size of the detector and the position of the origin of the pixel
coordinate system will be calculated. Make sure that the orientation
vectors and position of the detector are correct before calling
<code>setSize()</code>, or call <code>computeGeometryParameters()</code> if you update
the detector orientation or position later on.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nPixelsU</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in u direction.</dd>
<dt><strong><code>nPixelsV</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels in v direction.</dd>
<dt><strong><code>pitchU</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel pitch in u direction.</dd>
<dt><strong><code>pitchV</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel pitch in v direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSize(self, nPixelsU:int = None, nPixelsV:int = None, pitchU:float = None, pitchV:float = None):
    &#34;&#34;&#34;Set the physical size of the detector.

    From the given parameters (number of pixels and pitch), the physical
    size of the detector and the position of the origin of the pixel
    coordinate system will be calculated. Make sure that the orientation
    vectors and position of the detector are correct before calling
    `setSize()`, or call `computeGeometryParameters()` if you update
    the detector orientation or position later on.

    Parameters
    ----------
    nPixelsU : int
        Number of pixels in u direction.

    nPixelsV : int
        Number of pixels in v direction.

    pitchU : float
        Pixel pitch in u direction.

    pitchV : float
        Pixel pitch in v direction.
    &#34;&#34;&#34;

    self.pixelsU = int(nPixelsU)
    self.pixelsV = int(nPixelsV)
    self.pitchU = float(pitchU)
    self.pitchV = float(pitchV)

    self.computeGeometryParameters()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></b></code>:
<ul class="hlist">
<li><code><a title="ctsimu.geometry.GeometryObject.changeReferenceFrame" href="#ctsimu.geometry.GeometryObject.changeReferenceFrame">changeReferenceFrame</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.makeUnitCS" href="#ctsimu.geometry.GeometryObject.makeUnitCS">makeUnitCS</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotate" href="#ctsimu.geometry.GeometryObject.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotateAroundU" href="#ctsimu.geometry.GeometryObject.rotateAroundU">rotateAroundU</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotateAroundV" href="#ctsimu.geometry.GeometryObject.rotateAroundV">rotateAroundV</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotateAroundW" href="#ctsimu.geometry.GeometryObject.rotateAroundW">rotateAroundW</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.setup" href="#ctsimu.geometry.GeometryObject.setup">setup</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.setupFromGeometryDefinition" href="#ctsimu.geometry.GeometryObject.setupFromGeometryDefinition">setupFromGeometryDefinition</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translate" href="#ctsimu.geometry.GeometryObject.translate">translate</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translateX" href="#ctsimu.geometry.GeometryObject.translateX">translateX</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translateY" href="#ctsimu.geometry.GeometryObject.translateY">translateY</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translateZ" href="#ctsimu.geometry.GeometryObject.translateZ">translateZ</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ctsimu.geometry.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
<span>(</span><span>jsonFile:str=None, jsonFileFromPkg:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bundles geometry information about the complete CT setup.</p>
<p>Keeps the source, stage and detector as a set and provides methods
to calculate geometry parameters and projection matrices.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>detector</code></strong> :&ensp;<code><a title="ctsimu.geometry.Detector" href="#ctsimu.geometry.Detector">Detector</a></code></dt>
<dd>The detector geometry.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></dt>
<dd>The source geometry.</dd>
<dt><strong><code>stage</code></strong> :&ensp;<code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></dt>
<dd>The stage geometry.</dd>
<dt><strong><code>SDD</code></strong> :&ensp;<code>float</code></dt>
<dd>Shortest distance between source center and detector plane.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>SOD</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance between source center and stage center.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>ODD</code></strong> :&ensp;<code>float</code></dt>
<dd>Shortest distance between stage center and detector plane.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>brightestSpotWorld</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Location of the intensity maximum on the detector, in world coordinates.
Assuming an isotropically radiating source.
Calculated automatically by <code>update()</code>.</dd>
<dt><strong><code>brightestSpotDetector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Location of the intensity maximum on the detector, in terms of
detector coordinate system. Assuming an isotropically radiating source.
Calculated automatically by <code>update()</code>.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>Initialize using the provided JSON geometry specification.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>jsonFile</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Location of a CTSimU scenario description file to
import the geometry.</dd>
<dt><strong><code>jsonFileFromPkg</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Load the geometry from a JSON file included in the package,
usually for internal purposes only.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry:
    &#34;&#34;&#34;Bundles geometry information about the complete CT setup.

    Keeps the source, stage and detector as a set and provides methods
    to calculate geometry parameters and projection matrices.
    
    Attributes
    ----------
    detector : Detector
        The detector geometry.

    source : GeometryObject
        The source geometry.

    stage : GeometryObject
        The stage geometry.

    SDD : float
        Shortest distance between source center and detector plane.
        Calculated automatically by `update()`.

    SOD : float
        Distance between source center and stage center.
        Calculated automatically by `update()`.

    ODD : float
        Shortest distance between stage center and detector plane.
        Calculated automatically by `update()`.

    brightestSpotWorld : Vector
        Location of the intensity maximum on the detector, in world coordinates.
        Assuming an isotropically radiating source.
        Calculated automatically by `update()`.

    brightestSpotDetector : Vector
        Location of the intensity maximum on the detector, in terms of
        detector coordinate system. Assuming an isotropically radiating source.
        Calculated automatically by `update()`.

    Methods
    -------

    &#34;&#34;&#34;

    def __init__(self, jsonFile:str = None, jsonFileFromPkg:str = None):
        &#34;&#34;&#34;Initialize using the provided JSON geometry specification.

        Parameters
        ----------
        jsonFile : str, optional
            Location of a CTSimU scenario description file to
            import the geometry.

        jsonFileFromPkg : str, optional
            Load the geometry from a JSON file included in the package,
            usually for internal purposes only.

        &#34;&#34;&#34;
        self.detector    = Detector()
        self.source      = GeometryObject()
        self.stage       = GeometryObject()

        self.SDD = None
        self.SOD = None
        self.ODD = None
        self.brightestSpotWorld = None
        self.brightestSpotDetector = None

        jsonText = None
        if jsonFileFromPkg is not None:  # from package
            jsonFile = jsonFileFromPkg
            jsonText = pkgutil.get_data(__name__, jsonFileFromPkg).decode()
        elif jsonFile is not None:  # from file
            if os.path.isfile(jsonFile):
                log(&#34;JSON File: {}&#34;.format(jsonFile))
                jsonFilePtr = open(jsonFile, &#34;r&#34;)
                jsonText = jsonFilePtr.read()
                jsonFilePtr.close()
            else:
                raise Exception(&#34;Can&#39;t find &#34; + jsonFile)
        else:
            return

        if(jsonText is not None):
            try:
                jsonDict = json.loads(jsonText)
            except:
                raise Exception(&#34;Error parsing JSON file: {}&#34;.format(jsonFile))

            # Detector size and pixel pitch:
            pixelsU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;columns&#34;, &#34;value&#34;)
            pixelsV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;rows&#34;, &#34;value&#34;)
            pitchU = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;u&#34;, &#34;value&#34;)
            pitchV = getFieldOrNone(jsonDict, &#34;detector&#34;, &#34;pixel_pitch&#34;, &#34;v&#34;, &#34;value&#34;)

            try:
                detectorGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;detector&#34;)
                if detectorGeometry != None:
                    self.detector.setupFromGeometryDefinition(detectorGeometry)
                    self.detector.setSize(pixelsU, pixelsV, pitchU, pitchV)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;detector\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the detector geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                sourceGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;source&#34;)
                if sourceGeometry != None:
                    self.source.setupFromGeometryDefinition(sourceGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;source\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the source geometry using the JSON file description.&#34;)
                raise Exception(e)

            try:
                stageGeometry = getFieldOrNone(jsonDict, &#34;geometry&#34;, &#34;stage&#34;)
                if stageGeometry != None:
                    self.stage.setupFromGeometryDefinition(stageGeometry)
                else:
                    raise Exception(&#34;JSON file does not contain a valid \&#34;stage\&#34; section in \&#34;geometry\&#34;.&#34;)
            except Exception as e:
                log(&#34;Something went wrong when setting up the stage geometry using the JSON file description.&#34;)
                raise Exception(e)

            self.update()            
        else:
            raise Exception(&#34;JSON scenario file not available.&#34;)
        
    def update(self):
        &#34;&#34;&#34;Calculate derived geometry parameters.

        Calculates the SOD, SDD, ODD, and location of the intensity maximum
        on the detector (in world and detector coordinates) for the
        curent geometry. Results are stored in the following member variables
        (attributes).

        SDD: Shortest distance between source center and detector plane.

        SOD: Distance between source center and stage center.

        ODD: Shortest distance between stage center and detector plane.

        brightestSpotWorld: Location of the intensity maximum on the detector,
            in world coordinates.  Assuming an isotropically radiating source.

        brightestSpotDetector: Location of the intensity maximum on the
            detector, in terms of detector coordinate system.
            Assuming an isotropically radiating source.
        &#34;&#34;&#34;

        # SOD, SDD, ODD
        world = GeometryObject()
        source_from_image = copy.deepcopy(self.source)
        stage_from_detector  = copy.deepcopy(self.stage)

        source_from_image.changeReferenceFrame(world, self.detector)
        stage_from_detector.changeReferenceFrame(world, self.detector)

        self.SDD = abs(source_from_image.center.z)
        self.ODD = abs(stage_from_detector.center.z)
        self.SOD = self.source.center.distance(self.stage.center)

        ## Brightest Spot in World Coordinate System:
        self.brightestSpotWorld = copy.deepcopy(self.detector.w)
        self.brightestSpotWorld.scale(self.SDD)
        self.brightestSpotWorld.add(self.source.center)

        ## Brightest Spot in Detector Coordinate System:
        self.brightestSpotDetector = copy.deepcopy(self.brightestSpotWorld)
        self.brightestSpotDetector.subtract(self.detector.center)
        
        pxU = self.brightestSpotDetector.dot(self.detector.u) / self.detector.pitchU + self.detector.cols()/2.0
        pxV = self.brightestSpotDetector.dot(self.detector.v) / self.detector.pitchV + self.detector.rows()/2.0

        self.brightestSpotDetector = Vector(pxU, pxV, 0)


    def info(self) -&gt; str:
        &#34;&#34;&#34;Generate an information string about the current geometry.
    
        Returns
        -------
        txt : string
            Information string for humans.
        &#34;&#34;&#34;

        txt  = &#34;Detector\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.detector.center)
        txt += &#34;u:               {}\n&#34;.format(self.detector.u)
        txt += &#34;v:               {}\n&#34;.format(self.detector.v)
        txt += &#34;w:               {}\n&#34;.format(self.detector.w)
        txt += &#34;Pixels:          {cols} x {rows}\n&#34;.format(cols=self.detector.cols(), rows=self.detector.rows())
        txt += &#34;Pitch:           {pitchU} mm x {pitchV} mm\n&#34;.format(pitchU=self.detector.pitchU, pitchV=self.detector.pitchV)
        txt += &#34;Physical Size:   {width} mm x {height} mm\n&#34;.format(width=self.detector.physWidth, height=self.detector.physHeight)
        txt += &#34;Center Distance: {} mm\n&#34;.format(self.detector.center.distance(self.source.center))

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        txt += &#34;SDD:             {} mm\n&#34;.format(self.SDD)
        txt += &#34;Brightest Spot:\n&#34;
        txt += &#34;  World:         {}\n&#34;.format(self.brightestSpotWorld)
        txt += &#34;  Pixels:        {}\n&#34;.format(self.brightestSpotDetector)

        txt += &#34;\n&#34;
        txt += &#34;Source:\n&#34;
        txt += &#34;===========================================================\n&#34;
        txt += &#34;Center:          {}\n&#34;.format(self.source.center)
        txt += &#34;u:               {}\n&#34;.format(self.source.u)
        txt += &#34;v:               {}\n&#34;.format(self.source.v)
        txt += &#34;w:               {}\n&#34;.format(self.source.w)

        return txt

    def projectionMatrix(self,
                         imageCS:GeometryObject=None,
                         mode:str=None):
        &#34;&#34;&#34;Calculate a projection matrix for the current geometry.

        Parameters
        ----------
        imageCS : GeometryObject
            Position of the image coordinate system in terms of the
            detector coordinate system. See notes for details.

        mode : str
            Pre-defined modes, either &#34;openCT&#34; or &#34;CERA&#34; are supported.
            They override the `imageCS`, which can be set to `None` when
            using one of the pre-defined modes.

        Returns
        -------
        P : Matrix
            Projection matrix.

        Notes
        -----
        The image coordinate system (`imageCS`) should match the notation
        used by the reconstruction software, and is expressed in terms of
        the detector coordinate system.

        The detector coordinate system has its origin at the detector center,
        the u unit vector points in the row vector direction, and the
        v unit vector points in column vector direction (they are always assumed
        to be unit vectors).

        The center (origin) of the `imageCS` should be where the reconstruction
        software places the origin of its own image or detector coordinate
        system. For example, CERA places it at the lower-left corner of the
        projection image. In this case, the `imageCS` center should be set to
        ()
        &#34;&#34;&#34;

        validModes = [&#34;openCT&#34;, &#34;CERA&#34;]

        if mode is not None:
            if mode in validModes:  # Override imageCS
                image = GeometryObject()

                if mode == &#34;openCT&#34;:
                    &#34;&#34;&#34;openCT places the origin of the image CS at the detector 
                    center. The constructor places it at (0,0,0) automatically,
                    so there is nothing to do. Comments for illustration.&#34;&#34;&#34;
                    # image.center.x = 0
                    # image.center.y = 0
                    # image.center.z = 0

                    &#34;&#34;&#34;openCT&#39;s image CS is in mm units. We assume that all
                    other coordinate systems are in mm as well here (at least
                    when imported from JSON file). No scaling of the basis vectors is necessary.&#34;&#34;&#34;
                    # image.u.scale(1.0)
                    # image.v.scale(1.0)
                    # image.w.scale(1.0)

                elif mode == &#34;CERA&#34;:
                    &#34;&#34;&#34;CERA places the origin of the image CS in the center
                    of the lower left pixel of the projection image.&#34;&#34;&#34;
                    image.center.x = -self.detector.physWidth  / 2.0 + 0.5*self.detector.pitchU
                    image.center.y =  self.detector.physHeight / 2.0 - 0.5*self.detector.pitchV
                    # image.center.z = 0

                    &#34;&#34;&#34;CERA&#39;s unit of the image CS is in px, so we need to
                    scale the image CS basis vectors by the pixel size.
                    Also, v points up instead of down.&#34;&#34;&#34;
                    image.u.scale( self.detector.pitchU)
                    image.v.scale(-self.detector.pitchV)
                    image.w.scale(-1.0)
            else:
                raise RuntimeError(&#34;Unsupported mode for projection matrix: \&#34;{}\&#34;&#34;.format(mode))
        elif imageCS is not None:
            image = copy.deepcopy(imageCS)
        else:
            raise RuntimeError(&#34;projectionMatrix: Please provide either a mode or an imageCS.&#34;)

        world    = GeometryObject()
        source   = copy.deepcopy(self.source)
        stage    = copy.deepcopy(self.stage)

        # Detach the image CS from the detector CS and
        # express it in terms of the world CS:
        image.changeReferenceFrame(self.detector, world)

        &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
        vectors of the image CS compared to the detector CS unit vectors.&#34;&#34;&#34;
        scale_u = self.detector.u.dot(image.u)
        scale_v = self.detector.v.dot(image.v)
        scale_w = self.detector.w.dot(image.w)

        # Save a source CS as seen from the detector CS. This is convenient to
        # later get the SDD, ufoc and vfoc:
        source_from_image = copy.deepcopy(self.source)
        source_from_image.changeReferenceFrame(world, image)

        # Make the stage CS the new world CS:
        source.changeReferenceFrame(world, stage)
        image.changeReferenceFrame(world, stage)
        stage.changeReferenceFrame(world, stage)

        # Translation vector from stage to source:
        rfoc = source.center - stage.center
        xfoc = rfoc.x
        yfoc = rfoc.y
        zfoc = rfoc.z

        # Focus point on detector: principal, perpendicular ray.
        # In the detector coordinate system, ufoc and vfoc are the u and v coordinates
        # of the source center; SDD (perpendicular to detector plane) is source w coordinate.
        ufoc = source_from_image.center.x / scale_u
        vfoc = source_from_image.center.y / scale_v
        wfoc = source_from_image.center.z / scale_w
        SDD  = abs(source_from_image.center.z)

        # Mirror volume:
        M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])

        # Translation matrix: stage -&gt; source:
        F = Matrix(values=[[1, 0, 0, xfoc], [0, 1, 0, yfoc], [0, 0, 1, zfoc]])

        # Rotations:
        R = basisTransformMatrix(stage, image)

        # Projection onto detector and scaling:
        D = Matrix(values=[[SDD/scale_u, 0, 0], [0, SDD/scale_v, 0], [0, 0, 1.0/scale_w]])

        # Shift in detector CS: (ufoc and vfoc must be in scaled units)
        V = Matrix(values=[[1, 0, ufoc], [0, 1, vfoc], [0, 0, 1]])

        # Multiply all together:
        P = V * (D * (R * (F*M)))

        # Renormalize:
        lower_right = P.get(col=3, row=2)
        if lower_right != 0:
            P.scale(1.0/lower_right)

        return P

    def createDetectorFlatField_rays(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction. &#34;&#34;&#34;
        width      = self.detector.cols()
        height     = self.detector.rows()
        pixelSizeU = self.detector.pitchU
        pixelSizeV = self.detector.pitchV

        if(width == None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height == None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeU == None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pixelSizeV == None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        log(&#34;Geometry definition from JSON file:\n\
   Detector Angle:    {}\n\
   Detector Distance: {}\n\
   SDD:               {}\n\
   Pixels U:          {}\n\
   Pixels V:          {}\n\
   Pitch U:           {}\n\
   Pitch V:           {}\n\
   Source:            {}, {}, {}\n\
   Detector:          {}, {}, {}\n\
   Connection Vector: {}, {}, {}\n\
   Detector Vector U: {}, {}, {}\n\
   Detector Vector V: {}, {}, {}\n\
   Detector Vector W: {}, {}, {}&#34;.format(alpha, dist, SDD, width, height, pixelSizeU, pixelSizeV, sx, sy, sz, dx, dy, dz, connectionLine.x, connectionLine.y, connectionLine.z, ux, uy, uz, vx, vy, vz, wx, wy, wz))

        maxIntensity = 0
        maxX = 0
        maxY = 0
        minDistToSource = 0
        brightestIncidenceAngle = 0

        gridSize = 3
        gridSizeSq = gridSize*gridSize

        for x in range(width):
            for y in range(height):
                factorSum = 0
                for gx in range(gridSize):
                    for gy in range(gridSize):
                        # Calculate coordinates of pixel center in mm:
                        # Grid with margin:
                        stepSize = 1.0 / (gridSize+1)
                        pixel = self.detector.pixelVector(x+(gx+1)*stepSize, y+(gy+1)*stepSize)

                        # Grid with no margin:
                        #if gridSize &gt; 1:
                        #    stepSize = 1.0 / (gridSize-1)
                        #    pixel = self.detector.pixelVector(x+gx*stepSize, y+gy*stepSize)
                        #else:
                        #    pixel = self.detector.pixelVectorCenter(x, y)

                        distToSource = self.source.center.distance(pixel)

                        # Angle of incident rays:
                        vecSourceToPixel = Vector(pixel.x-sx, pixel.y-sy, pixel.z-sz)
                        incidenceAngle = abs(self.detector.w.angle(vecSourceToPixel))
                        if incidenceAngle &gt; (math.pi/2):
                            incidenceAngle = math.pi - incidenceAngle

                        intensityFactor = math.cos(incidenceAngle)*math.pow(SDD/distToSource, 2)
                        factorSum += intensityFactor

                intensityWeight = factorSum / gridSizeSq

                if intensityWeight &gt; maxIntensity:
                    maxIntensity = intensityWeight
                    maxX = x
                    maxY = y
                    minDistToSource = distToSource
                    brightestIncidenceAngle = incidenceAngle

                flatField.setPixel(x, y, intensityWeight)

            progress = 100*(float(x+1)/float(width))
            print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        return flatField

    def pixelAreaOnUnitSphere(self, A, B, C, D):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C, D must be vectors pointing to pixel corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()
        
        ACin  = A.cross(C)
        DAin  = D.cross(A)
        CDin  = C.cross(D)
        ACout = ACin.inverse()
        DAout = DAin.inverse()
        CDout = CDin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        # areaABC = alpha + beta + gamma - math.pi

        # Spherical Triangle ACD:
        rho   = ACin.angle(DAout)
        sigma = CDin.angle(ACout)
        tau   = DAin.angle(CDout)

        # areaACD = rho + tau + sigma - math.pi

        pxSphericalArea = (alpha + beta + gamma + rho + sigma + tau) - 2*math.pi

        return pxSphericalArea

    def triangleAreaOnUnitSphere(self, A, B, C):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        # Define normals of circular planes, pointing into the
        # triangle or out of the triangle:
        ABin  = A.cross(B)
        BCin  = B.cross(C)
        CAin  = C.cross(A)
        ABout = ABin.inverse()
        BCout = BCin.inverse()
        CAout = CAin.inverse()

        # Spherical Triangle ABC:
        alpha = ABin.angle(CAout)
        beta  = BCin.angle(ABout)
        gamma = CAin.angle(BCout)

        areaABC = alpha + beta + gamma - math.pi

        return areaABC

    def polygonAreaOnUnitSphere(self, polygon):
        # Source must be at (0, 0, 0) relative to given detector,
        # and A, B, C must be vectors pointing to triangle corners in
        # world coordinate system.

        if len(polygon.points) &gt;= 3:
            # Start at first point
            p1 = polygon.points[0]

            area = 0

            for i in range(1, len(polygon.points)-1):
                p2 = polygon.points[i]
                p3 = polygon.points[i+1]

                area += self.triangleAreaOnUnitSphere(p1, p2, p3)

            return area
        else:
            return 0

    &#34;&#34;&#34;
    def createDetectorFlatField_sphere_old(self, clippingPolygon=None):
        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = dist * math.cos(alpha)

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)

        print(&#34;SDD: {}&#34;.format(SDD))
        print(&#34;Pitch: {}, {}&#34;.format(hpu, hpv))
        #print(&#34;Brightest Pixel Area: {}&#34;.format(areaOfBrightestPixel))

        flatField = Image()
        flatField.shape(det.cols(), det.rows(), 0, flatField.getInternalDataType())

        maxArea = 0
        maxX = 0
        maxY = 0
        maxCenter = 0
        # Go through pixels:
        for x in range(det.cols()):
            for y in range(det.rows()):
                # Define Pixel corners:
                A = det.pixelVector(x,   y)
                B = det.pixelVector(x+1, y)
                C = det.pixelVector(x+1, y+1)
                D = det.pixelVector(x,   y+1)

                pxSphericalArea = self.pixelAreaOnUnitSphere(A, B, C, D)
                flatField.setPixel(x, y, pxSphericalArea)

                if pxSphericalArea &gt; maxArea:
                    maxArea = pxSphericalArea
                    maxX = x
                    maxY = y

            progress = 100*(float(x+1)/float(det.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)


        maxCenter = det.pixelVectorCenter(maxX, maxY)
        distToSource = maxCenter.length()
        incidenceAngle = abs(self.detector.w.angle(maxCenter))

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        print(&#34;  Vector: {}, {}, {}&#34;.format(maxCenter.x, maxCenter.y, maxCenter.z))
        print(&#34;  Distance to Source: {}&#34;.format(distToSource))
        print(&#34;  Spherical Area: {}&#34;.format(maxArea))
        print(&#34;  Angle: {} rad = {} deg&#34;.format(incidenceAngle, 180*incidenceAngle/math.pi))

        return flatField
    &#34;&#34;&#34;

    def createDetectorFlatField_sphere(self, *coverPolygons):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Geometrical approach using spherical geometry. &#34;&#34;&#34;

        # Change to the detector coordinate system:
        D = copy.deepcopy(self.detector)
        S = copy.deepcopy(self.source)
        world = GeometryObject()  # will be initialized as world

        S.changeReferenceFrame(world, D)
        D.changeReferenceFrame(world, D)
        D.computeGeometryParameters()

        # Source - Detector distance (SDD) defined by shortest distance between source and detector,
        # or distance between source and spot of highest intensity on detector.
        SDD = abs(S.center.z)

        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        pu = D.pitchU
        pv = D.pitchV
        nRows = D.rows()
        nCols = D.cols()

        hpu = 0.5*pu
        hpv = 0.5*pv
        pA = Vector(SDD,  hpu,  hpv)
        pB = Vector(SDD, -hpu,  hpv)
        pC = Vector(SDD, -hpu, -hpv)
        pD = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(pA, pB, pC, pD)

        # Full flat field image (without any clipping bodies):
        flatField = Image()
        flatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # A second image with a clipping body under consideration: (both will be returned)
        clippedFlatField = None
        if len(coverPolygons) &gt; 0:
            clippedFlatField = Image()
            clippedFlatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

        # Upper left detector corner in world coordinates (remember: world is now the detector CS)
        p00 = D.pixelVector(0, 0)

        stepRight      = Vector(pu, 0,  0)
        stepDown       = Vector(0,  pv, 0)
        stepRightDown  = Vector(pu, pv, 0)

        # Move the clipping polygon to a coordinate system
        # where source is centered:
        for coverPolygon in coverPolygons:
            for p in range(len(coverPolygon.points)):
                coverPolygon.points[p] = coverPolygon.points[p] - S.center

        # Go through pixels:
        for x in range(nCols):
            for y in range(nRows):
                # Pixel in world coordinates (remember: world is now the detector CS)
                shift = Vector(x*pu, y*pv, 0)

                # Define Pixel corners:
                pA = p00 + shift
                pB = pA  + stepRight
                pC = pA  + stepRightDown
                pD = pA  + stepDown

                # Center source at (0, 0, 0):
                pA = pA - S.center
                pB = pB - S.center
                pC = pC - S.center
                pD = pD - S.center

                pixelPolygon = Polygon(pA, pB, pC, pD)
                pxSphericalArea  = self.polygonAreaOnUnitSphere(pixelPolygon)

                flatField.setPixel(x, y, pxSphericalArea)

                if len(coverPolygons) &gt; 0:
                    for coverPolygon in coverPolygons:
                        pixelPolygon = pixelPolygon.clip(coverPolygon)
                        
                    # Remove the intensity covered by the clipping polygon:
                    pixelPolygon.make3D(zComponent=SDD)
                    subarea = self.polygonAreaOnUnitSphere(pixelPolygon)
                    pxSphericalArea -= subarea

                    clippedFlatField.setPixel(x, y, pxSphericalArea)

            progress = 100*(float(x+1)/float(D.cols()))
            print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        # Method #1: renormalize to area of theoretically brightest pixel:
        flatField.divide(areaOfBrightestPixel)
        if clippedFlatField != None:
            clippedFlatField.divide(areaOfBrightestPixel)

        # Method #2: rescale maximum of actual brightest pixel to 1.0:
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

        print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)

        return flatField, clippedFlatField

    def solidAngle(self, l, m):
        &#34;&#34;&#34; Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth. &#34;&#34;&#34;
        if l != 0:
            return (l/abs(l)) * math.atan(abs(l)*m/math.sqrt(1.0+l**2+m**2))
        else:
            return 0

    def createDetectorFlatField_analytical(self):
        &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
            picture for the given detector, to be used for an
            ideal flat field correction.

            Analytical approach by Florian Wohlgemuth. &#34;&#34;&#34;

        width  = self.detector.cols()
        height = self.detector.rows()
        pitchU = self.detector.pitchU
        pitchV = self.detector.pitchV

        if(width == None):
            raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(height == None):
            raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchU == None):
            raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
        if(pitchV == None):
            raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

        flatField = Image()
        flatField.shape(width, height, 0, flatField.getInternalDataType())

        # Positions of detector and source center:
        dx = self.detector.center.x
        dy = self.detector.center.y
        dz = self.detector.center.z

        sx = self.source.center.x
        sy = self.source.center.y
        sz = self.source.center.z

        # Vectors of the detector coordinate system:
        ux = self.detector.u.x
        uy = self.detector.u.y
        uz = self.detector.u.z

        vx = self.detector.v.x
        vy = self.detector.v.y
        vz = self.detector.v.z

        wx = self.detector.w.x
        wy = self.detector.w.y
        wz = self.detector.w.z


        # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
        connectionLine = Vector(dx-sx, dy-sy, dz-sz)

        alpha = abs(self.detector.w.angle(connectionLine))
        if alpha &gt; (math.pi/2):
            alpha = math.pi - alpha

        # Distance between source center and detector center:
        dist = self.detector.center.distance(self.source.center)

        # Source - Detector distance (SDD) defined by shortest distance between source and detector:
        SDD = dist * math.cos(alpha)

        maxIntensity = 0
        maxX = 0
        maxY = 0

        # Create a new detector in a coordinate system where source is at (0, 0, 0):
        det = copy.deepcopy(self.detector)
        translationVector = Vector(-sx, -sy, -sz)
        det.translate(translationVector)
        det.computeGeometryParameters()

        upperLeft_u = det.pixelVector(0, 0).dot(self.detector.u)
        upperLeft_v = det.pixelVector(0, 0).dot(self.detector.v)
        upperLeft_w = det.pixelVector(0, 0).dot(self.detector.w)

        if upperLeft_w != 0:   # check if detector is not facing its edge towards the source
            for x in range(width):
                for y in range(height):
                    nu = x
                    nv = y
                    lambda0 = (upperLeft_u + nu*pitchU) / upperLeft_w
                    lambda1 = (upperLeft_u + (nu+1)*pitchU) / upperLeft_w
                    mu0     = (upperLeft_v + nv*pitchV) / upperLeft_w
                    mu1     = (upperLeft_v + (nv+1)*pitchV) / upperLeft_w

                    omega = self.solidAngle(lambda0, mu0) + self.solidAngle(lambda1, mu1) - self.solidAngle(lambda0, mu1) - self.solidAngle(lambda1, mu0)

                    if omega &gt; maxIntensity:
                        maxIntensity = omega
                        maxX = x
                        maxY = y

                    flatField.setPixel(x, y, omega)

                progress = 100*(float(x+1)/float(width))
                print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

        print(&#34;\rCalculating analytical flat field... 100%  &#34;)

        #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
        # print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
        # print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

        # Method #1: find hypothetical brightest pixel
        # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
        hpu = 0.5*det.pitchU
        hpv = 0.5*det.pitchV
        A = Vector(SDD,  hpu,  hpv)
        B = Vector(SDD, -hpu,  hpv)
        C = Vector(SDD, -hpu, -hpv)
        D = Vector(SDD,  hpu, -hpv)
        areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)
        flatField.divide(areaOfBrightestPixel)

        # Method #2: rescale actual maximum to 1.
        #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

        #flatField.save(&#34;ff.tif&#34;, dataType=&#34;float32&#34;)
        return flatField


    def createDetectorFlatField(self):
        return createDetectorFlatField_analytical()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createDetectorFlatField(self):
    return createDetectorFlatField_analytical()</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField_analytical"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField_analytical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p>
<p>Analytical approach by Florian Wohlgemuth.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createDetectorFlatField_analytical(self):
    &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
        picture for the given detector, to be used for an
        ideal flat field correction.

        Analytical approach by Florian Wohlgemuth. &#34;&#34;&#34;

    width  = self.detector.cols()
    height = self.detector.rows()
    pitchU = self.detector.pitchU
    pitchV = self.detector.pitchV

    if(width == None):
        raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
    if(height == None):
        raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
    if(pitchU == None):
        raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
    if(pitchV == None):
        raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

    flatField = Image()
    flatField.shape(width, height, 0, flatField.getInternalDataType())

    # Positions of detector and source center:
    dx = self.detector.center.x
    dy = self.detector.center.y
    dz = self.detector.center.z

    sx = self.source.center.x
    sy = self.source.center.y
    sz = self.source.center.z

    # Vectors of the detector coordinate system:
    ux = self.detector.u.x
    uy = self.detector.u.y
    uz = self.detector.u.z

    vx = self.detector.v.x
    vy = self.detector.v.y
    vz = self.detector.v.z

    wx = self.detector.w.x
    wy = self.detector.w.y
    wz = self.detector.w.z


    # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
    connectionLine = Vector(dx-sx, dy-sy, dz-sz)

    alpha = abs(self.detector.w.angle(connectionLine))
    if alpha &gt; (math.pi/2):
        alpha = math.pi - alpha

    # Distance between source center and detector center:
    dist = self.detector.center.distance(self.source.center)

    # Source - Detector distance (SDD) defined by shortest distance between source and detector:
    SDD = dist * math.cos(alpha)

    maxIntensity = 0
    maxX = 0
    maxY = 0

    # Create a new detector in a coordinate system where source is at (0, 0, 0):
    det = copy.deepcopy(self.detector)
    translationVector = Vector(-sx, -sy, -sz)
    det.translate(translationVector)
    det.computeGeometryParameters()

    upperLeft_u = det.pixelVector(0, 0).dot(self.detector.u)
    upperLeft_v = det.pixelVector(0, 0).dot(self.detector.v)
    upperLeft_w = det.pixelVector(0, 0).dot(self.detector.w)

    if upperLeft_w != 0:   # check if detector is not facing its edge towards the source
        for x in range(width):
            for y in range(height):
                nu = x
                nv = y
                lambda0 = (upperLeft_u + nu*pitchU) / upperLeft_w
                lambda1 = (upperLeft_u + (nu+1)*pitchU) / upperLeft_w
                mu0     = (upperLeft_v + nv*pitchV) / upperLeft_w
                mu1     = (upperLeft_v + (nv+1)*pitchV) / upperLeft_w

                omega = self.solidAngle(lambda0, mu0) + self.solidAngle(lambda1, mu1) - self.solidAngle(lambda0, mu1) - self.solidAngle(lambda1, mu0)

                if omega &gt; maxIntensity:
                    maxIntensity = omega
                    maxX = x
                    maxY = y

                flatField.setPixel(x, y, omega)

            progress = 100*(float(x+1)/float(width))
            print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

    print(&#34;\rCalculating analytical flat field... 100%  &#34;)

    #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
    # print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
    # print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

    # Method #1: find hypothetical brightest pixel
    # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
    hpu = 0.5*det.pitchU
    hpv = 0.5*det.pitchV
    A = Vector(SDD,  hpu,  hpv)
    B = Vector(SDD, -hpu,  hpv)
    C = Vector(SDD, -hpu, -hpv)
    D = Vector(SDD,  hpu, -hpv)
    areaOfBrightestPixel = self.pixelAreaOnUnitSphere(A, B, C, D)
    flatField.divide(areaOfBrightestPixel)

    # Method #2: rescale actual maximum to 1.
    #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

    #flatField.save(&#34;ff.tif&#34;, dataType=&#34;float32&#34;)
    return flatField</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField_rays"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField_rays</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"> def createDetectorFlatField_rays(self):
     &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
         picture for the given detector, to be used for an
         ideal flat field correction. &#34;&#34;&#34;
     width      = self.detector.cols()
     height     = self.detector.rows()
     pixelSizeU = self.detector.pitchU
     pixelSizeV = self.detector.pitchV

     if(width == None):
         raise Exception(&#34;The detector width (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
     if(height == None):
         raise Exception(&#34;The detector height (in pixels) must be provided through a valid CTSimU JSON file.&#34;)
     if(pixelSizeU == None):
         raise Exception(&#34;The pixel size (in mm) in u direction must be provided through a valid CTSimU JSON file.&#34;)
     if(pixelSizeV == None):
         raise Exception(&#34;The pixel size (in mm) in v direction must be provided through a valid CTSimU JSON file.&#34;)

     flatField = Image()
     flatField.shape(width, height, 0, flatField.getInternalDataType())

     # Positions of detector and source center:
     dx = self.detector.center.x
     dy = self.detector.center.y
     dz = self.detector.center.z

     sx = self.source.center.x
     sy = self.source.center.y
     sz = self.source.center.z

     # Vectors of the detector coordinate system:
     ux = self.detector.u.x
     uy = self.detector.u.y
     uz = self.detector.u.z

     vx = self.detector.v.x
     vy = self.detector.v.y
     vz = self.detector.v.z

     wx = self.detector.w.x
     wy = self.detector.w.y
     wz = self.detector.w.z


     # Angle &#39;alpha&#39; between detector normal and connection line [detector center -- source]:
     connectionLine = Vector(dx-sx, dy-sy, dz-sz)

     alpha = abs(self.detector.w.angle(connectionLine))
     if alpha &gt; (math.pi/2):
         alpha = math.pi - alpha

     # Distance between source center and detector center:
     dist = self.detector.center.distance(self.source.center)

     # Source - Detector distance (SDD) defined by shortest distance between source and detector:
     SDD = dist * math.cos(alpha)

     log(&#34;Geometry definition from JSON file:\n\
Detector Angle:    {}\n\
Detector Distance: {}\n\
SDD:               {}\n\
Pixels U:          {}\n\
Pixels V:          {}\n\
Pitch U:           {}\n\
Pitch V:           {}\n\
Source:            {}, {}, {}\n\
Detector:          {}, {}, {}\n\
Connection Vector: {}, {}, {}\n\
Detector Vector U: {}, {}, {}\n\
Detector Vector V: {}, {}, {}\n\
Detector Vector W: {}, {}, {}&#34;.format(alpha, dist, SDD, width, height, pixelSizeU, pixelSizeV, sx, sy, sz, dx, dy, dz, connectionLine.x, connectionLine.y, connectionLine.z, ux, uy, uz, vx, vy, vz, wx, wy, wz))

     maxIntensity = 0
     maxX = 0
     maxY = 0
     minDistToSource = 0
     brightestIncidenceAngle = 0

     gridSize = 3
     gridSizeSq = gridSize*gridSize

     for x in range(width):
         for y in range(height):
             factorSum = 0
             for gx in range(gridSize):
                 for gy in range(gridSize):
                     # Calculate coordinates of pixel center in mm:
                     # Grid with margin:
                     stepSize = 1.0 / (gridSize+1)
                     pixel = self.detector.pixelVector(x+(gx+1)*stepSize, y+(gy+1)*stepSize)

                     # Grid with no margin:
                     #if gridSize &gt; 1:
                     #    stepSize = 1.0 / (gridSize-1)
                     #    pixel = self.detector.pixelVector(x+gx*stepSize, y+gy*stepSize)
                     #else:
                     #    pixel = self.detector.pixelVectorCenter(x, y)

                     distToSource = self.source.center.distance(pixel)

                     # Angle of incident rays:
                     vecSourceToPixel = Vector(pixel.x-sx, pixel.y-sy, pixel.z-sz)
                     incidenceAngle = abs(self.detector.w.angle(vecSourceToPixel))
                     if incidenceAngle &gt; (math.pi/2):
                         incidenceAngle = math.pi - incidenceAngle

                     intensityFactor = math.cos(incidenceAngle)*math.pow(SDD/distToSource, 2)
                     factorSum += intensityFactor

             intensityWeight = factorSum / gridSizeSq

             if intensityWeight &gt; maxIntensity:
                 maxIntensity = intensityWeight
                 maxX = x
                 maxY = y
                 minDistToSource = distToSource
                 brightestIncidenceAngle = incidenceAngle

             flatField.setPixel(x, y, intensityWeight)

         progress = 100*(float(x+1)/float(width))
         print(&#34;\rCalculating analytical flat field... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

     print(&#34;\rCalculating analytical flat field... 100%  &#34;)

     #print(&#34;Brightest Pixel: {}, {}&#34;.format(maxX, maxY))
     print(&#34;  Dist to Source: {}&#34;.format(minDistToSource))
     print(&#34;  Angle: {} rad = {} deg&#34;.format(brightestIncidenceAngle, 180*brightestIncidenceAngle/math.pi))

     return flatField</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.createDetectorFlatField_sphere"><code class="name flex">
<span>def <span class="ident">createDetectorFlatField_sphere</span></span>(<span>self, *coverPolygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an analytical free beam intensity distribution
picture for the given detector, to be used for an
ideal flat field correction.</p>
<p>Geometrical approach using spherical geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createDetectorFlatField_sphere(self, *coverPolygons):
    &#34;&#34;&#34; Calculate an analytical free beam intensity distribution
        picture for the given detector, to be used for an
        ideal flat field correction.

        Geometrical approach using spherical geometry. &#34;&#34;&#34;

    # Change to the detector coordinate system:
    D = copy.deepcopy(self.detector)
    S = copy.deepcopy(self.source)
    world = GeometryObject()  # will be initialized as world

    S.changeReferenceFrame(world, D)
    D.changeReferenceFrame(world, D)
    D.computeGeometryParameters()

    # Source - Detector distance (SDD) defined by shortest distance between source and detector,
    # or distance between source and spot of highest intensity on detector.
    SDD = abs(S.center.z)

    # Calculate the area of the theoretical &#34;brightest pixel&#34; on the unit sphere:
    pu = D.pitchU
    pv = D.pitchV
    nRows = D.rows()
    nCols = D.cols()

    hpu = 0.5*pu
    hpv = 0.5*pv
    pA = Vector(SDD,  hpu,  hpv)
    pB = Vector(SDD, -hpu,  hpv)
    pC = Vector(SDD, -hpu, -hpv)
    pD = Vector(SDD,  hpu, -hpv)
    areaOfBrightestPixel = self.pixelAreaOnUnitSphere(pA, pB, pC, pD)

    # Full flat field image (without any clipping bodies):
    flatField = Image()
    flatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

    # A second image with a clipping body under consideration: (both will be returned)
    clippedFlatField = None
    if len(coverPolygons) &gt; 0:
        clippedFlatField = Image()
        clippedFlatField.shape(D.cols(), D.rows(), 0, flatField.getInternalDataType())

    # Upper left detector corner in world coordinates (remember: world is now the detector CS)
    p00 = D.pixelVector(0, 0)

    stepRight      = Vector(pu, 0,  0)
    stepDown       = Vector(0,  pv, 0)
    stepRightDown  = Vector(pu, pv, 0)

    # Move the clipping polygon to a coordinate system
    # where source is centered:
    for coverPolygon in coverPolygons:
        for p in range(len(coverPolygon.points)):
            coverPolygon.points[p] = coverPolygon.points[p] - S.center

    # Go through pixels:
    for x in range(nCols):
        for y in range(nRows):
            # Pixel in world coordinates (remember: world is now the detector CS)
            shift = Vector(x*pu, y*pv, 0)

            # Define Pixel corners:
            pA = p00 + shift
            pB = pA  + stepRight
            pC = pA  + stepRightDown
            pD = pA  + stepDown

            # Center source at (0, 0, 0):
            pA = pA - S.center
            pB = pB - S.center
            pC = pC - S.center
            pD = pD - S.center

            pixelPolygon = Polygon(pA, pB, pC, pD)
            pxSphericalArea  = self.polygonAreaOnUnitSphere(pixelPolygon)

            flatField.setPixel(x, y, pxSphericalArea)

            if len(coverPolygons) &gt; 0:
                for coverPolygon in coverPolygons:
                    pixelPolygon = pixelPolygon.clip(coverPolygon)
                    
                # Remove the intensity covered by the clipping polygon:
                pixelPolygon.make3D(zComponent=SDD)
                subarea = self.polygonAreaOnUnitSphere(pixelPolygon)
                pxSphericalArea -= subarea

                clippedFlatField.setPixel(x, y, pxSphericalArea)

        progress = 100*(float(x+1)/float(D.cols()))
        print(&#34;\rCalculating analytical intensity profile... {:0.1f}%    &#34;.format(progress), end=&#39;&#39;)

    # Method #1: renormalize to area of theoretically brightest pixel:
    flatField.divide(areaOfBrightestPixel)
    if clippedFlatField != None:
        clippedFlatField.divide(areaOfBrightestPixel)

    # Method #2: rescale maximum of actual brightest pixel to 1.0:
    #flatField.renormalize(newMin=0, newMax=1.0, currentMin=0)

    #flatField.save(&#34;ff.tif&#34;, numpy.dtype(&#39;float32&#39;))

    print(&#34;\rCalculating analytical intensity profile... 100%  &#34;)

    return flatField, clippedFlatField</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an information string about the current geometry.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>txt</code></strong> :&ensp;<code>string</code></dt>
<dd>Information string for humans.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Generate an information string about the current geometry.

    Returns
    -------
    txt : string
        Information string for humans.
    &#34;&#34;&#34;

    txt  = &#34;Detector\n&#34;
    txt += &#34;===========================================================\n&#34;
    txt += &#34;Center:          {}\n&#34;.format(self.detector.center)
    txt += &#34;u:               {}\n&#34;.format(self.detector.u)
    txt += &#34;v:               {}\n&#34;.format(self.detector.v)
    txt += &#34;w:               {}\n&#34;.format(self.detector.w)
    txt += &#34;Pixels:          {cols} x {rows}\n&#34;.format(cols=self.detector.cols(), rows=self.detector.rows())
    txt += &#34;Pitch:           {pitchU} mm x {pitchV} mm\n&#34;.format(pitchU=self.detector.pitchU, pitchV=self.detector.pitchV)
    txt += &#34;Physical Size:   {width} mm x {height} mm\n&#34;.format(width=self.detector.physWidth, height=self.detector.physHeight)
    txt += &#34;Center Distance: {} mm\n&#34;.format(self.detector.center.distance(self.source.center))

    # Source - Detector distance (SDD) defined by shortest distance between source and detector:
    txt += &#34;SDD:             {} mm\n&#34;.format(self.SDD)
    txt += &#34;Brightest Spot:\n&#34;
    txt += &#34;  World:         {}\n&#34;.format(self.brightestSpotWorld)
    txt += &#34;  Pixels:        {}\n&#34;.format(self.brightestSpotDetector)

    txt += &#34;\n&#34;
    txt += &#34;Source:\n&#34;
    txt += &#34;===========================================================\n&#34;
    txt += &#34;Center:          {}\n&#34;.format(self.source.center)
    txt += &#34;u:               {}\n&#34;.format(self.source.u)
    txt += &#34;v:               {}\n&#34;.format(self.source.v)
    txt += &#34;w:               {}\n&#34;.format(self.source.w)

    return txt</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.pixelAreaOnUnitSphere"><code class="name flex">
<span>def <span class="ident">pixelAreaOnUnitSphere</span></span>(<span>self, A, B, C, D)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixelAreaOnUnitSphere(self, A, B, C, D):
    # Source must be at (0, 0, 0) relative to given detector,
    # and A, B, C, D must be vectors pointing to pixel corners in
    # world coordinate system.

    # Define normals of circular planes, pointing into the
    # triangle or out of the triangle:
    ABin  = A.cross(B)
    BCin  = B.cross(C)
    CAin  = C.cross(A)
    ABout = ABin.inverse()
    BCout = BCin.inverse()
    CAout = CAin.inverse()
    
    ACin  = A.cross(C)
    DAin  = D.cross(A)
    CDin  = C.cross(D)
    ACout = ACin.inverse()
    DAout = DAin.inverse()
    CDout = CDin.inverse()

    # Spherical Triangle ABC:
    alpha = ABin.angle(CAout)
    beta  = BCin.angle(ABout)
    gamma = CAin.angle(BCout)

    # areaABC = alpha + beta + gamma - math.pi

    # Spherical Triangle ACD:
    rho   = ACin.angle(DAout)
    sigma = CDin.angle(ACout)
    tau   = DAin.angle(CDout)

    # areaACD = rho + tau + sigma - math.pi

    pxSphericalArea = (alpha + beta + gamma + rho + sigma + tau) - 2*math.pi

    return pxSphericalArea</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.polygonAreaOnUnitSphere"><code class="name flex">
<span>def <span class="ident">polygonAreaOnUnitSphere</span></span>(<span>self, polygon)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygonAreaOnUnitSphere(self, polygon):
    # Source must be at (0, 0, 0) relative to given detector,
    # and A, B, C must be vectors pointing to triangle corners in
    # world coordinate system.

    if len(polygon.points) &gt;= 3:
        # Start at first point
        p1 = polygon.points[0]

        area = 0

        for i in range(1, len(polygon.points)-1):
            p2 = polygon.points[i]
            p3 = polygon.points[i+1]

            area += self.triangleAreaOnUnitSphere(p1, p2, p3)

        return area
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.projectionMatrix"><code class="name flex">
<span>def <span class="ident">projectionMatrix</span></span>(<span>self, imageCS:<a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a>=None, mode:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a projection matrix for the current geometry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>imageCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></dt>
<dd>Position of the image coordinate system in terms of the
detector coordinate system. See notes for details.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Pre-defined modes, either "openCT" or "CERA" are supported.
They override the <code>imageCS</code>, which can be set to <code>None</code> when
using one of the pre-defined modes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>Projection matrix.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The image coordinate system (<code>imageCS</code>) should match the notation
used by the reconstruction software, and is expressed in terms of
the detector coordinate system.</p>
<p>The detector coordinate system has its origin at the detector center,
the u unit vector points in the row vector direction, and the
v unit vector points in column vector direction (they are always assumed
to be unit vectors).</p>
<p>The center (origin) of the <code>imageCS</code> should be where the reconstruction
software places the origin of its own image or detector coordinate
system. For example, CERA places it at the lower-left corner of the
projection image. In this case, the <code>imageCS</code> center should be set to
()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projectionMatrix(self,
                     imageCS:GeometryObject=None,
                     mode:str=None):
    &#34;&#34;&#34;Calculate a projection matrix for the current geometry.

    Parameters
    ----------
    imageCS : GeometryObject
        Position of the image coordinate system in terms of the
        detector coordinate system. See notes for details.

    mode : str
        Pre-defined modes, either &#34;openCT&#34; or &#34;CERA&#34; are supported.
        They override the `imageCS`, which can be set to `None` when
        using one of the pre-defined modes.

    Returns
    -------
    P : Matrix
        Projection matrix.

    Notes
    -----
    The image coordinate system (`imageCS`) should match the notation
    used by the reconstruction software, and is expressed in terms of
    the detector coordinate system.

    The detector coordinate system has its origin at the detector center,
    the u unit vector points in the row vector direction, and the
    v unit vector points in column vector direction (they are always assumed
    to be unit vectors).

    The center (origin) of the `imageCS` should be where the reconstruction
    software places the origin of its own image or detector coordinate
    system. For example, CERA places it at the lower-left corner of the
    projection image. In this case, the `imageCS` center should be set to
    ()
    &#34;&#34;&#34;

    validModes = [&#34;openCT&#34;, &#34;CERA&#34;]

    if mode is not None:
        if mode in validModes:  # Override imageCS
            image = GeometryObject()

            if mode == &#34;openCT&#34;:
                &#34;&#34;&#34;openCT places the origin of the image CS at the detector 
                center. The constructor places it at (0,0,0) automatically,
                so there is nothing to do. Comments for illustration.&#34;&#34;&#34;
                # image.center.x = 0
                # image.center.y = 0
                # image.center.z = 0

                &#34;&#34;&#34;openCT&#39;s image CS is in mm units. We assume that all
                other coordinate systems are in mm as well here (at least
                when imported from JSON file). No scaling of the basis vectors is necessary.&#34;&#34;&#34;
                # image.u.scale(1.0)
                # image.v.scale(1.0)
                # image.w.scale(1.0)

            elif mode == &#34;CERA&#34;:
                &#34;&#34;&#34;CERA places the origin of the image CS in the center
                of the lower left pixel of the projection image.&#34;&#34;&#34;
                image.center.x = -self.detector.physWidth  / 2.0 + 0.5*self.detector.pitchU
                image.center.y =  self.detector.physHeight / 2.0 - 0.5*self.detector.pitchV
                # image.center.z = 0

                &#34;&#34;&#34;CERA&#39;s unit of the image CS is in px, so we need to
                scale the image CS basis vectors by the pixel size.
                Also, v points up instead of down.&#34;&#34;&#34;
                image.u.scale( self.detector.pitchU)
                image.v.scale(-self.detector.pitchV)
                image.w.scale(-1.0)
        else:
            raise RuntimeError(&#34;Unsupported mode for projection matrix: \&#34;{}\&#34;&#34;.format(mode))
    elif imageCS is not None:
        image = copy.deepcopy(imageCS)
    else:
        raise RuntimeError(&#34;projectionMatrix: Please provide either a mode or an imageCS.&#34;)

    world    = GeometryObject()
    source   = copy.deepcopy(self.source)
    stage    = copy.deepcopy(self.stage)

    # Detach the image CS from the detector CS and
    # express it in terms of the world CS:
    image.changeReferenceFrame(self.detector, world)

    &#34;&#34;&#34;The scale factors are derived from the lengths of the basis
    vectors of the image CS compared to the detector CS unit vectors.&#34;&#34;&#34;
    scale_u = self.detector.u.dot(image.u)
    scale_v = self.detector.v.dot(image.v)
    scale_w = self.detector.w.dot(image.w)

    # Save a source CS as seen from the detector CS. This is convenient to
    # later get the SDD, ufoc and vfoc:
    source_from_image = copy.deepcopy(self.source)
    source_from_image.changeReferenceFrame(world, image)

    # Make the stage CS the new world CS:
    source.changeReferenceFrame(world, stage)
    image.changeReferenceFrame(world, stage)
    stage.changeReferenceFrame(world, stage)

    # Translation vector from stage to source:
    rfoc = source.center - stage.center
    xfoc = rfoc.x
    yfoc = rfoc.y
    zfoc = rfoc.z

    # Focus point on detector: principal, perpendicular ray.
    # In the detector coordinate system, ufoc and vfoc are the u and v coordinates
    # of the source center; SDD (perpendicular to detector plane) is source w coordinate.
    ufoc = source_from_image.center.x / scale_u
    vfoc = source_from_image.center.y / scale_v
    wfoc = source_from_image.center.z / scale_w
    SDD  = abs(source_from_image.center.z)

    # Mirror volume:
    M = Matrix(values=[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])

    # Translation matrix: stage -&gt; source:
    F = Matrix(values=[[1, 0, 0, xfoc], [0, 1, 0, yfoc], [0, 0, 1, zfoc]])

    # Rotations:
    R = basisTransformMatrix(stage, image)

    # Projection onto detector and scaling:
    D = Matrix(values=[[SDD/scale_u, 0, 0], [0, SDD/scale_v, 0], [0, 0, 1.0/scale_w]])

    # Shift in detector CS: (ufoc and vfoc must be in scaled units)
    V = Matrix(values=[[1, 0, ufoc], [0, 1, vfoc], [0, 0, 1]])

    # Multiply all together:
    P = V * (D * (R * (F*M)))

    # Renormalize:
    lower_right = P.get(col=3, row=2)
    if lower_right != 0:
        P.scale(1.0/lower_right)

    return P</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.solidAngle"><code class="name flex">
<span>def <span class="ident">solidAngle</span></span>(<span>self, l, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solidAngle(self, l, m):
    &#34;&#34;&#34; Solid angle helper function for intensity profile. Approach by Florian Wohlgemuth. &#34;&#34;&#34;
    if l != 0:
        return (l/abs(l)) * math.atan(abs(l)*m/math.sqrt(1.0+l**2+m**2))
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.triangleAreaOnUnitSphere"><code class="name flex">
<span>def <span class="ident">triangleAreaOnUnitSphere</span></span>(<span>self, A, B, C)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangleAreaOnUnitSphere(self, A, B, C):
    # Source must be at (0, 0, 0) relative to given detector,
    # and A, B, C must be vectors pointing to triangle corners in
    # world coordinate system.

    # Define normals of circular planes, pointing into the
    # triangle or out of the triangle:
    ABin  = A.cross(B)
    BCin  = B.cross(C)
    CAin  = C.cross(A)
    ABout = ABin.inverse()
    BCout = BCin.inverse()
    CAout = CAin.inverse()

    # Spherical Triangle ABC:
    alpha = ABin.angle(CAout)
    beta  = BCin.angle(ABout)
    gamma = CAin.angle(BCout)

    areaABC = alpha + beta + gamma - math.pi

    return areaABC</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.Geometry.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate derived geometry parameters.</p>
<p>Calculates the SOD, SDD, ODD, and location of the intensity maximum
on the detector (in world and detector coordinates) for the
curent geometry. Results are stored in the following member variables
(attributes).</p>
<p>SDD: Shortest distance between source center and detector plane.</p>
<p>SOD: Distance between source center and stage center.</p>
<p>ODD: Shortest distance between stage center and detector plane.</p>
<p>brightestSpotWorld: Location of the intensity maximum on the detector,
in world coordinates.
Assuming an isotropically radiating source.</p>
<p>brightestSpotDetector: Location of the intensity maximum on the
detector, in terms of detector coordinate system.
Assuming an isotropically radiating source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Calculate derived geometry parameters.

    Calculates the SOD, SDD, ODD, and location of the intensity maximum
    on the detector (in world and detector coordinates) for the
    curent geometry. Results are stored in the following member variables
    (attributes).

    SDD: Shortest distance between source center and detector plane.

    SOD: Distance between source center and stage center.

    ODD: Shortest distance between stage center and detector plane.

    brightestSpotWorld: Location of the intensity maximum on the detector,
        in world coordinates.  Assuming an isotropically radiating source.

    brightestSpotDetector: Location of the intensity maximum on the
        detector, in terms of detector coordinate system.
        Assuming an isotropically radiating source.
    &#34;&#34;&#34;

    # SOD, SDD, ODD
    world = GeometryObject()
    source_from_image = copy.deepcopy(self.source)
    stage_from_detector  = copy.deepcopy(self.stage)

    source_from_image.changeReferenceFrame(world, self.detector)
    stage_from_detector.changeReferenceFrame(world, self.detector)

    self.SDD = abs(source_from_image.center.z)
    self.ODD = abs(stage_from_detector.center.z)
    self.SOD = self.source.center.distance(self.stage.center)

    ## Brightest Spot in World Coordinate System:
    self.brightestSpotWorld = copy.deepcopy(self.detector.w)
    self.brightestSpotWorld.scale(self.SDD)
    self.brightestSpotWorld.add(self.source.center)

    ## Brightest Spot in Detector Coordinate System:
    self.brightestSpotDetector = copy.deepcopy(self.brightestSpotWorld)
    self.brightestSpotDetector.subtract(self.detector.center)
    
    pxU = self.brightestSpotDetector.dot(self.detector.u) / self.detector.pitchU + self.detector.cols()/2.0
    pxV = self.brightestSpotDetector.dot(self.detector.v) / self.detector.pitchV + self.detector.rows()/2.0

    self.brightestSpotDetector = Vector(pxU, pxV, 0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.geometry.GeometryObject"><code class="flex name class">
<span>class <span class="ident">GeometryObject</span></span>
</code></dt>
<dd>
<div class="desc"><p>Coordinate system: center point and axis vectors.</p>
<p>An object according to the CTSimU scenario specification,
containing a center coordinate and an orientation in 3D space.</p>
<p>The center and axis vectors are expressed in terms of the
object's reference coordinate system, which must be known implicitly
when objects of this class are used.</p>
<p>Geometrical objects could be source, stage or detector.
Samples would need additional attention due to possible attachment
to stage coordinate system (instead of world).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>Vector</code></dt>
<dd>The location of the center point in a reference
coordinate system (usually world or stage).</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector for the u axis.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector for the v axis.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector for the w axis.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>setupFromGeometryDefinition(geometry)
Set up geometry from a JSON dictionary.</p>
<p>setup(centerX, centerY, centerZ, uX, uY, uZ, wX, wY, wZ)
Set up center and orientation manually.</p>
<p>makeUnitCS()
Convert all basis vectors to unit vectors.</p>
<p>translate(translationVector)
Move object in space.</p>
<p>translateX(dx)
Move object in x direction.</p>
<p>translateY(dx)
Move object in y direction.</p>
<p>translateZ(dx)
Move object in z direction.</p>
<p>rotateAroundU(angle)
Rotate object around its u axis by given angle [rad].</p>
<p>rotateAroundV(angle)
Rotate object around its v axis by given angle [rad].</p>
<p>rotateAroundW(angle)
Rotate object around its w axis by given angle [rad].</p>
<p>rotate(axis, angle)
Rotate object around a given axis by the given angle [rad].</p>
<p>changeReferenceFrame(fromCS, toCS)
Change the object's reference coordinate system.</p>
<p>Initialize as a standard world coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometryObject:
    &#34;&#34;&#34;Coordinate system: center point and axis vectors.

    An object according to the CTSimU scenario specification,
    containing a center coordinate and an orientation in 3D space.
    
    The center and axis vectors are expressed in terms of the
    object&#39;s reference coordinate system, which must be known implicitly
    when objects of this class are used.

    Geometrical objects could be source, stage or detector.
    Samples would need additional attention due to possible attachment
    to stage coordinate system (instead of world).

    Attributes
    ----------
    center : Vector
        The location of the center point in a reference
        coordinate system (usually world or stage).

    u : Vector
        Basis vector for the u axis.

    v : Vector
        Basis vector for the v axis.

    w : Vector
        Basis vector for the w axis.

    Methods
    -------
    setupFromGeometryDefinition(geometry)
        Set up geometry from a JSON dictionary.

    setup(centerX, centerY, centerZ, uX, uY, uZ, wX, wY, wZ)
        Set up center and orientation manually.

    makeUnitCS()
        Convert all basis vectors to unit vectors.

    translate(translationVector)
        Move object in space.

    translateX(dx)
        Move object in x direction.

    translateY(dx)
        Move object in y direction.

    translateZ(dx)
        Move object in z direction.

    rotateAroundU(angle)
        Rotate object around its u axis by given angle [rad].

    rotateAroundV(angle)
        Rotate object around its v axis by given angle [rad].

    rotateAroundW(angle)
        Rotate object around its w axis by given angle [rad].

    rotate(axis, angle)
        Rotate object around a given axis by the given angle [rad].

    changeReferenceFrame(fromCS, toCS)
        Change the object&#39;s reference coordinate system.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize as a standard world coordinate system.&#34;&#34;&#34;
        self.center  = Vector(0, 0, 0)
        self.u = Vector(1, 0, 0)
        self.v = Vector(0, 1, 0)
        self.w = Vector(0, 0, 1)

    def __str__(self):
        &#34;&#34;&#34;Information string for easy printing.&#34;&#34;&#34;

        txt  = &#34;Center: {}\n&#34;.format(self.center)
        txt += &#34;u:      {}\n&#34;.format(self.u)
        txt += &#34;v:      {}\n&#34;.format(self.v)
        txt += &#34;w:      {}\n&#34;.format(self.w)
        return txt

    def setupFromGeometryDefinition(self, geometry: dict):
        &#34;&#34;&#34;Set up geometry from a JSON dictionary.

        Parameters
        ----------
        geometry : dict
            A parsed JSON dictionary from a CTSimU scenario description file.
            See [2]_.

        Raises
        ------
        KeyError
            When expected JSON keys for center and vector x, y, z
            components are not found in the dictionary.

        References
        ----------
        .. [2] CTSimU Scenario Descriptions, https://bamresearch.github.io/ctsimu-scenarios/
        &#34;&#34;&#34;

        # Get center position from JSON dict:
        if &#34;center&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;center&#34;]:
                cx = in_mm(geometry[&#34;center&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;center&#34;]:
                cy = in_mm(geometry[&#34;center&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;center&#34;]:
                cz = in_mm(geometry[&#34;center&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        # Try old British spelling (up to file format v0.9)
        elif &#34;centre&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;centre&#34;]:
                cx = in_mm(geometry[&#34;centre&#34;][&#34;x&#34;])
            else:
                raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

            if &#34;y&#34; in geometry[&#34;centre&#34;]:
                cy = in_mm(geometry[&#34;centre&#34;][&#34;y&#34;])
            else:
                raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
            
            if &#34;z&#34; in geometry[&#34;centre&#34;]:
                cz = in_mm(geometry[&#34;centre&#34;][&#34;z&#34;])
            else:
                raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

            self.center.set(cx, cy, cz)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;center\&#34; section.&#34;)

        # Get vector u from JSON dict:
        if &#34;vector_u&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_u&#34;]:
                ux = geometry[&#34;vector_u&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector u.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_u&#34;]:
                uy = geometry[&#34;vector_u&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector u.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_u&#34;]:
                uz = geometry[&#34;vector_u&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector u.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_u\&#34; section.&#34;)

        # Get vector w from JSON dict:
        if &#34;vector_w&#34; in geometry:
            if &#34;x&#34; in geometry[&#34;vector_w&#34;]:
                wx = geometry[&#34;vector_w&#34;][&#34;x&#34;]
            else:
                raise KeyError(&#34;No \&#34;x\&#34; component found for vector w.&#34;)

            if &#34;y&#34; in geometry[&#34;vector_w&#34;]:
                wy = geometry[&#34;vector_w&#34;][&#34;y&#34;]
            else:
                raise KeyError(&#34;No \&#34;y\&#34; component found for vector w.&#34;)

            if &#34;z&#34; in geometry[&#34;vector_w&#34;]:
                wz = geometry[&#34;vector_w&#34;][&#34;z&#34;]
            else:
                raise KeyError(&#34;No \&#34;z\&#34; component found for vector w.&#34;)
        else:
            raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_w\&#34; section.&#34;)

        # Set up the geometry from the information given in the JSON file:
        c = Vector(cx, cy, cz)  # center
        u = Vector(ux, uy, uz)  # u basis vector
        w = Vector(wx, wy, wz)  # w basis vector
        v = w.cross(u)
        self.setup(c, u, v, w)
        self.makeUnitCS()

        # Apply deviations from the now-ideal geometry:
        if &#34;deviation&#34; in geometry:
            # Positional deviations:
            if &#34;position&#34; in geometry[&#34;deviation&#34;]:
                if &#34;x&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;] != None:
                        translationX = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;])
                        self.translateX(translationX)
    
                if &#34;y&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;] != None:
                        translationY = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;])
                        self.translateY(translationY)

                if &#34;z&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;] != None:
                        translationZ = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;])
                        self.translateZ(translationZ)

            # Rotations according to w&#39;&#39;v&#39;u convention:
            if &#34;rotation&#34; in geometry[&#34;deviation&#34;]:
                if &#34;w&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;] != None:
                        angleAroundW = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;])
                        self.rotateAroundW(angleAroundW)

                if &#34;v&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;] != None:
                        angleAroundV = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;])
                        self.rotateAroundV(angleAroundV)

                if &#34;u&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                    if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;] != None:
                        angleAroundU = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;])
                        self.rotateAroundU(angleAroundU)

    def setup(self, center:Vector, u:Vector, v:Vector, w:Vector):
        &#34;&#34;&#34;Set up center and orientation manually.

        Parameters
        ----------
        center : Vector
            Object&#39;s center point in reference coordinate system,
            origin of local {u,v,w} coordinate system.

        u : Vector
            Basis vector u in terms of reference coordinate system.

        v : Vector
            Basis vector v in terms of reference coordinate system.

        w : Vector
            Basis vector w in terms of reference coordinate system.

        Notes
        -----
        All basis vectors must be orthogonal.
        &#34;&#34;&#34;

        # Create new vectors from given components:
        self.center  = center
        self.u = u
        self.v = v
        self.w = w

    def makeUnitCS(self):
        &#34;&#34;&#34;Convert all basis vectors to unit vectors.&#34;&#34;&#34;
        self.u.makeUnitVector()
        self.v.makeUnitVector()
        self.w.makeUnitVector()

    def translate(self, translationVector: Vector):
        &#34;&#34;&#34;Move object in space.

        Parameters
        ----------
        translationVector : Vector
            Vector by which the object&#39;s center point should be shifted.
            Its components are added to the center&#39;s components.
        &#34;&#34;&#34;
        self.center.add(translationVector)

    def translateX(self, dx: float):
        &#34;&#34;&#34;Move object in x direction.

        Parameters
        ----------
        dx : float
            Shift amount in x direction.
        &#34;&#34;&#34;
        self.center.setx(self.center.x + float(dx))

    def translateY(self, dy: float):
        &#34;&#34;&#34;Move object in y direction.

        Parameters
        ----------
        dy : float
            Shift amount in y direction.
        &#34;&#34;&#34;
        self.center.sety(self.center.y + float(dy))

    def translateZ(self, dz: float):
        &#34;&#34;&#34;Move object in z direction.

        Parameters
        ----------
        dz : float
            Shift amount in z direction.
        &#34;&#34;&#34;
        self.center.setz(self.center.z + float(dz))

    def rotateAroundU(self, angle: float):
        &#34;&#34;&#34;Rotate object around its u axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.v.rotate(self.u, angle)
        self.w.rotate(self.u, angle)

    def rotateAroundV(self, angle: float):
        &#34;&#34;&#34;Rotate object around its v axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.u.rotate(self.v, angle)
        self.w.rotate(self.v, angle)

    def rotateAroundW(self, angle: float):
        &#34;&#34;&#34;Rotate object around its w axis by given angle [rad].
        
        Parameters
        ----------
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.u.rotate(self.w, angle)
        self.v.rotate(self.w, angle)

    def rotate(self, axis: Vector, angle: float):
        &#34;&#34;&#34;Rotate object around a given axis by the given angle [rad].
        
        Parameters
        ----------
        axis : Vector
            The axis of rotation, in terms of the object&#39;s
            reference coordinate system (e.g. world).
        
        angle : float
            Rotation angle in rad.
        &#34;&#34;&#34;
        self.u.rotate(axis, angle)
        self.v.rotate(axis, angle)
        self.w.rotate(axis, angle)

    def changeReferenceFrame(self, fromCS:&#39;GeometryObject&#39;, toCS:&#39;GeometryObject&#39;):
        &#34;&#34;&#34;Change the object&#39;s reference coordinate system.
        
        Parameters
        ----------
        fromCS : GeometryObject
            Current reference coordinate system.
        
        toCS : GeometryObject
            New reference coordinate system.

        Notes
        -----
        Both fromCS and toCS must be in the same reference coordinate system
        (e.g., the world coordinate system).
        &#34;&#34;&#34;

        # Rotate basis vectors into toCS:
        T = basisTransformMatrix(fromCS, toCS)
        self.u = T * self.u
        self.v = T * self.v
        self.w = T * self.w

        world = GeometryObject()

        # Move center to toCS:
        # 1. Translate self.center by difference of toCS and fromCS
        #    -&gt; Origins are &#34;superimposed&#34;.
        # 2. Rotate self.center from fromCS to toCS.

        # Translation vector in world coordinates:
        translator = fromCS.center - toCS.center  # in world coordinates
        # Translation vector in fromCS coordinates:
        M = basisTransformMatrix(world, fromCS)
        translator = M*translator
        relCenter = self.center + translator
        self.center = T*relCenter</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ctsimu.geometry.Detector" href="#ctsimu.geometry.Detector">Detector</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.geometry.GeometryObject.changeReferenceFrame"><code class="name flex">
<span>def <span class="ident">changeReferenceFrame</span></span>(<span>self, fromCS:<a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a>, toCS:<a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the object's reference coordinate system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></dt>
<dd>Current reference coordinate system.</dd>
<dt><strong><code>toCS</code></strong> :&ensp;<code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></dt>
<dd>New reference coordinate system.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Both fromCS and toCS must be in the same reference coordinate system
(e.g., the world coordinate system).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeReferenceFrame(self, fromCS:&#39;GeometryObject&#39;, toCS:&#39;GeometryObject&#39;):
    &#34;&#34;&#34;Change the object&#39;s reference coordinate system.
    
    Parameters
    ----------
    fromCS : GeometryObject
        Current reference coordinate system.
    
    toCS : GeometryObject
        New reference coordinate system.

    Notes
    -----
    Both fromCS and toCS must be in the same reference coordinate system
    (e.g., the world coordinate system).
    &#34;&#34;&#34;

    # Rotate basis vectors into toCS:
    T = basisTransformMatrix(fromCS, toCS)
    self.u = T * self.u
    self.v = T * self.v
    self.w = T * self.w

    world = GeometryObject()

    # Move center to toCS:
    # 1. Translate self.center by difference of toCS and fromCS
    #    -&gt; Origins are &#34;superimposed&#34;.
    # 2. Rotate self.center from fromCS to toCS.

    # Translation vector in world coordinates:
    translator = fromCS.center - toCS.center  # in world coordinates
    # Translation vector in fromCS coordinates:
    M = basisTransformMatrix(world, fromCS)
    translator = M*translator
    relCenter = self.center + translator
    self.center = T*relCenter</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.makeUnitCS"><code class="name flex">
<span>def <span class="ident">makeUnitCS</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all basis vectors to unit vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeUnitCS(self):
    &#34;&#34;&#34;Convert all basis vectors to unit vectors.&#34;&#34;&#34;
    self.u.makeUnitVector()
    self.v.makeUnitVector()
    self.w.makeUnitVector()</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, axis:<a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, angle:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around a given axis by the given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>Vector</code></dt>
<dd>The axis of rotation, in terms of the object's
reference coordinate system (e.g. world).</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, axis: Vector, angle: float):
    &#34;&#34;&#34;Rotate object around a given axis by the given angle [rad].
    
    Parameters
    ----------
    axis : Vector
        The axis of rotation, in terms of the object&#39;s
        reference coordinate system (e.g. world).
    
    angle : float
        Rotation angle in rad.
    &#34;&#34;&#34;
    self.u.rotate(axis, angle)
    self.v.rotate(axis, angle)
    self.w.rotate(axis, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.rotateAroundU"><code class="name flex">
<span>def <span class="ident">rotateAroundU</span></span>(<span>self, angle:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its u axis by given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotateAroundU(self, angle: float):
    &#34;&#34;&#34;Rotate object around its u axis by given angle [rad].
    
    Parameters
    ----------
    angle : float
        Rotation angle in rad.
    &#34;&#34;&#34;
    self.v.rotate(self.u, angle)
    self.w.rotate(self.u, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.rotateAroundV"><code class="name flex">
<span>def <span class="ident">rotateAroundV</span></span>(<span>self, angle:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its v axis by given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotateAroundV(self, angle: float):
    &#34;&#34;&#34;Rotate object around its v axis by given angle [rad].
    
    Parameters
    ----------
    angle : float
        Rotation angle in rad.
    &#34;&#34;&#34;
    self.u.rotate(self.v, angle)
    self.w.rotate(self.v, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.rotateAroundW"><code class="name flex">
<span>def <span class="ident">rotateAroundW</span></span>(<span>self, angle:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate object around its w axis by given angle [rad].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Rotation angle in rad.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotateAroundW(self, angle: float):
    &#34;&#34;&#34;Rotate object around its w axis by given angle [rad].
    
    Parameters
    ----------
    angle : float
        Rotation angle in rad.
    &#34;&#34;&#34;
    self.u.rotate(self.w, angle)
    self.v.rotate(self.w, angle)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, center:<a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, u:<a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, v:<a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>, w:<a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up center and orientation manually.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Object's center point in reference coordinate system,
origin of local {u,v,w} coordinate system.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector u in terms of reference coordinate system.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector v in terms of reference coordinate system.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Basis vector w in terms of reference coordinate system.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>All basis vectors must be orthogonal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, center:Vector, u:Vector, v:Vector, w:Vector):
    &#34;&#34;&#34;Set up center and orientation manually.

    Parameters
    ----------
    center : Vector
        Object&#39;s center point in reference coordinate system,
        origin of local {u,v,w} coordinate system.

    u : Vector
        Basis vector u in terms of reference coordinate system.

    v : Vector
        Basis vector v in terms of reference coordinate system.

    w : Vector
        Basis vector w in terms of reference coordinate system.

    Notes
    -----
    All basis vectors must be orthogonal.
    &#34;&#34;&#34;

    # Create new vectors from given components:
    self.center  = center
    self.u = u
    self.v = v
    self.w = w</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.setupFromGeometryDefinition"><code class="name flex">
<span>def <span class="ident">setupFromGeometryDefinition</span></span>(<span>self, geometry:dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up geometry from a JSON dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>dict</code></dt>
<dd>A parsed JSON dictionary from a CTSimU scenario description file.
See [2]_.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>When expected JSON keys for center and vector x, y, z
components are not found in the dictionary.</dd>
</dl>
<h2 id="references">References</h2>
<p>.. [2] CTSimU Scenario Descriptions, <a href="https://bamresearch.github.io/ctsimu-scenarios/">https://bamresearch.github.io/ctsimu-scenarios/</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setupFromGeometryDefinition(self, geometry: dict):
    &#34;&#34;&#34;Set up geometry from a JSON dictionary.

    Parameters
    ----------
    geometry : dict
        A parsed JSON dictionary from a CTSimU scenario description file.
        See [2]_.

    Raises
    ------
    KeyError
        When expected JSON keys for center and vector x, y, z
        components are not found in the dictionary.

    References
    ----------
    .. [2] CTSimU Scenario Descriptions, https://bamresearch.github.io/ctsimu-scenarios/
    &#34;&#34;&#34;

    # Get center position from JSON dict:
    if &#34;center&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;center&#34;]:
            cx = in_mm(geometry[&#34;center&#34;][&#34;x&#34;])
        else:
            raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

        if &#34;y&#34; in geometry[&#34;center&#34;]:
            cy = in_mm(geometry[&#34;center&#34;][&#34;y&#34;])
        else:
            raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
        
        if &#34;z&#34; in geometry[&#34;center&#34;]:
            cz = in_mm(geometry[&#34;center&#34;][&#34;z&#34;])
        else:
            raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

        self.center.set(cx, cy, cz)
    # Try old British spelling (up to file format v0.9)
    elif &#34;centre&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;centre&#34;]:
            cx = in_mm(geometry[&#34;centre&#34;][&#34;x&#34;])
        else:
            raise KeyError(&#34;No \&#34;x\&#34; coordinate found for the center.&#34;)

        if &#34;y&#34; in geometry[&#34;centre&#34;]:
            cy = in_mm(geometry[&#34;centre&#34;][&#34;y&#34;])
        else:
            raise KeyError(&#34;No \&#34;y\&#34; coordinate found for the center.&#34;)
        
        if &#34;z&#34; in geometry[&#34;centre&#34;]:
            cz = in_mm(geometry[&#34;centre&#34;][&#34;z&#34;])
        else:
            raise KeyError(&#34;No \&#34;z\&#34; coordinate found for the center.&#34;)

        self.center.set(cx, cy, cz)
    else:
        raise KeyError(&#34;JSON file is missing a geometry \&#34;center\&#34; section.&#34;)

    # Get vector u from JSON dict:
    if &#34;vector_u&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;vector_u&#34;]:
            ux = geometry[&#34;vector_u&#34;][&#34;x&#34;]
        else:
            raise KeyError(&#34;No \&#34;x\&#34; component found for vector u.&#34;)

        if &#34;y&#34; in geometry[&#34;vector_u&#34;]:
            uy = geometry[&#34;vector_u&#34;][&#34;y&#34;]
        else:
            raise KeyError(&#34;No \&#34;y\&#34; component found for vector u.&#34;)

        if &#34;z&#34; in geometry[&#34;vector_u&#34;]:
            uz = geometry[&#34;vector_u&#34;][&#34;z&#34;]
        else:
            raise KeyError(&#34;No \&#34;z\&#34; component found for vector u.&#34;)
    else:
        raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_u\&#34; section.&#34;)

    # Get vector w from JSON dict:
    if &#34;vector_w&#34; in geometry:
        if &#34;x&#34; in geometry[&#34;vector_w&#34;]:
            wx = geometry[&#34;vector_w&#34;][&#34;x&#34;]
        else:
            raise KeyError(&#34;No \&#34;x\&#34; component found for vector w.&#34;)

        if &#34;y&#34; in geometry[&#34;vector_w&#34;]:
            wy = geometry[&#34;vector_w&#34;][&#34;y&#34;]
        else:
            raise KeyError(&#34;No \&#34;y\&#34; component found for vector w.&#34;)

        if &#34;z&#34; in geometry[&#34;vector_w&#34;]:
            wz = geometry[&#34;vector_w&#34;][&#34;z&#34;]
        else:
            raise KeyError(&#34;No \&#34;z\&#34; component found for vector w.&#34;)
    else:
        raise KeyError(&#34;JSON file is missing a geometry \&#34;vector_w\&#34; section.&#34;)

    # Set up the geometry from the information given in the JSON file:
    c = Vector(cx, cy, cz)  # center
    u = Vector(ux, uy, uz)  # u basis vector
    w = Vector(wx, wy, wz)  # w basis vector
    v = w.cross(u)
    self.setup(c, u, v, w)
    self.makeUnitCS()

    # Apply deviations from the now-ideal geometry:
    if &#34;deviation&#34; in geometry:
        # Positional deviations:
        if &#34;position&#34; in geometry[&#34;deviation&#34;]:
            if &#34;x&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;] != None:
                    translationX = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;x&#34;])
                    self.translateX(translationX)

            if &#34;y&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;] != None:
                    translationY = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;y&#34;])
                    self.translateY(translationY)

            if &#34;z&#34; in geometry[&#34;deviation&#34;][&#34;position&#34;]:
                if geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;] != None:
                    translationZ = in_mm(geometry[&#34;deviation&#34;][&#34;position&#34;][&#34;z&#34;])
                    self.translateZ(translationZ)

        # Rotations according to w&#39;&#39;v&#39;u convention:
        if &#34;rotation&#34; in geometry[&#34;deviation&#34;]:
            if &#34;w&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;] != None:
                    angleAroundW = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;w&#34;])
                    self.rotateAroundW(angleAroundW)

            if &#34;v&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;] != None:
                    angleAroundV = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;v&#34;])
                    self.rotateAroundV(angleAroundV)

            if &#34;u&#34; in geometry[&#34;deviation&#34;][&#34;rotation&#34;]:
                if geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;] != None:
                    angleAroundU = in_rad(geometry[&#34;deviation&#34;][&#34;rotation&#34;][&#34;u&#34;])
                    self.rotateAroundU(angleAroundU)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, translationVector:<a title="ctsimu.primitives.Vector" href="primitives.html#ctsimu.primitives.Vector">Vector</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>translationVector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>Vector by which the object's center point should be shifted.
Its components are added to the center's components.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, translationVector: Vector):
    &#34;&#34;&#34;Move object in space.

    Parameters
    ----------
    translationVector : Vector
        Vector by which the object&#39;s center point should be shifted.
        Its components are added to the center&#39;s components.
    &#34;&#34;&#34;
    self.center.add(translationVector)</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.translateX"><code class="name flex">
<span>def <span class="ident">translateX</span></span>(<span>self, dx:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in x direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in x direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateX(self, dx: float):
    &#34;&#34;&#34;Move object in x direction.

    Parameters
    ----------
    dx : float
        Shift amount in x direction.
    &#34;&#34;&#34;
    self.center.setx(self.center.x + float(dx))</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.translateY"><code class="name flex">
<span>def <span class="ident">translateY</span></span>(<span>self, dy:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in y direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in y direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateY(self, dy: float):
    &#34;&#34;&#34;Move object in y direction.

    Parameters
    ----------
    dy : float
        Shift amount in y direction.
    &#34;&#34;&#34;
    self.center.sety(self.center.y + float(dy))</code></pre>
</details>
</dd>
<dt id="ctsimu.geometry.GeometryObject.translateZ"><code class="name flex">
<span>def <span class="ident">translateZ</span></span>(<span>self, dz:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Move object in z direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code></dt>
<dd>Shift amount in z direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateZ(self, dz: float):
    &#34;&#34;&#34;Move object in z direction.

    Parameters
    ----------
    dz : float
        Shift amount in z direction.
    &#34;&#34;&#34;
    self.center.setz(self.center.z + float(dz))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="toolbox.png" alt=""> ctsimu
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu" href="index.html">ctsimu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctsimu.geometry.basisTransformMatrix" href="#ctsimu.geometry.basisTransformMatrix">basisTransformMatrix</a></code></li>
<li><code><a title="ctsimu.geometry.writeCERAconfig" href="#ctsimu.geometry.writeCERAconfig">writeCERAconfig</a></code></li>
<li><code><a title="ctsimu.geometry.writeOpenCTFile" href="#ctsimu.geometry.writeOpenCTFile">writeOpenCTFile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.geometry.Detector" href="#ctsimu.geometry.Detector">Detector</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.Detector.cols" href="#ctsimu.geometry.Detector.cols">cols</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.computeGeometryParameters" href="#ctsimu.geometry.Detector.computeGeometryParameters">computeGeometryParameters</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.pixelVector" href="#ctsimu.geometry.Detector.pixelVector">pixelVector</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.pixelVectorCenter" href="#ctsimu.geometry.Detector.pixelVectorCenter">pixelVectorCenter</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.rows" href="#ctsimu.geometry.Detector.rows">rows</a></code></li>
<li><code><a title="ctsimu.geometry.Detector.setSize" href="#ctsimu.geometry.Detector.setSize">setSize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.geometry.Geometry" href="#ctsimu.geometry.Geometry">Geometry</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField" href="#ctsimu.geometry.Geometry.createDetectorFlatField">createDetectorFlatField</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField_analytical" href="#ctsimu.geometry.Geometry.createDetectorFlatField_analytical">createDetectorFlatField_analytical</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField_rays" href="#ctsimu.geometry.Geometry.createDetectorFlatField_rays">createDetectorFlatField_rays</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.createDetectorFlatField_sphere" href="#ctsimu.geometry.Geometry.createDetectorFlatField_sphere">createDetectorFlatField_sphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.info" href="#ctsimu.geometry.Geometry.info">info</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.pixelAreaOnUnitSphere" href="#ctsimu.geometry.Geometry.pixelAreaOnUnitSphere">pixelAreaOnUnitSphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.polygonAreaOnUnitSphere" href="#ctsimu.geometry.Geometry.polygonAreaOnUnitSphere">polygonAreaOnUnitSphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.projectionMatrix" href="#ctsimu.geometry.Geometry.projectionMatrix">projectionMatrix</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.solidAngle" href="#ctsimu.geometry.Geometry.solidAngle">solidAngle</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.triangleAreaOnUnitSphere" href="#ctsimu.geometry.Geometry.triangleAreaOnUnitSphere">triangleAreaOnUnitSphere</a></code></li>
<li><code><a title="ctsimu.geometry.Geometry.update" href="#ctsimu.geometry.Geometry.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.geometry.GeometryObject" href="#ctsimu.geometry.GeometryObject">GeometryObject</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.geometry.GeometryObject.changeReferenceFrame" href="#ctsimu.geometry.GeometryObject.changeReferenceFrame">changeReferenceFrame</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.makeUnitCS" href="#ctsimu.geometry.GeometryObject.makeUnitCS">makeUnitCS</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotate" href="#ctsimu.geometry.GeometryObject.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotateAroundU" href="#ctsimu.geometry.GeometryObject.rotateAroundU">rotateAroundU</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotateAroundV" href="#ctsimu.geometry.GeometryObject.rotateAroundV">rotateAroundV</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.rotateAroundW" href="#ctsimu.geometry.GeometryObject.rotateAroundW">rotateAroundW</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.setup" href="#ctsimu.geometry.GeometryObject.setup">setup</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.setupFromGeometryDefinition" href="#ctsimu.geometry.GeometryObject.setupFromGeometryDefinition">setupFromGeometryDefinition</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translate" href="#ctsimu.geometry.GeometryObject.translate">translate</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translateX" href="#ctsimu.geometry.GeometryObject.translateX">translateX</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translateY" href="#ctsimu.geometry.GeometryObject.translateY">translateY</a></code></li>
<li><code><a title="ctsimu.geometry.GeometryObject.translateZ" href="#ctsimu.geometry.GeometryObject.translateZ">translateZ</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>