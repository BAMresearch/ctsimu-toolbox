<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctsimu.helpers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.helpers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-
import os
import json
import math
import csv
import pkgutil
import numpy
import numbers
from scipy import optimize, fft

ctsimu_supported_scenario_version = {
    &#34;major&#34;: 1,
    &#34;minor&#34;: 2
}

ctsimu_supported_metadata_version = {
    &#34;major&#34;: 1,
    &#34;minor&#34;: 2
}

ctsimu_valid_axes   = [&#34;z&#34;, &#34;y&#34;, &#34;x&#34;, &#34;w&#34;, &#34;v&#34;, &#34;u&#34;, &#34;t&#34;, &#34;s&#34;, &#34;r&#34;]
ctsimu_axis_strings = [&#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;]
ctsimu_world_axis_designations  = [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;]
ctsimu_local_axis_designations  = [&#34;u&#34;, &#34;v&#34;, &#34;w&#34;]
ctsimu_sample_axis_designations = [&#34;r&#34;, &#34;s&#34;, &#34;t&#34;]

openct_converter = {
    &#34;datatype&#34;: {
        &#34;uint8&#34;: &#34;UInt8&#34;,
        &#34;uint16&#34;: &#34;UInt16&#34;,
        &#34;uint32&#34;: &#34;UInt32&#34;,
        &#34;int8&#34;: &#34;Int8&#34;,
        &#34;int16&#34;: &#34;Int16&#34;,
        &#34;int32&#34;: &#34;Int32&#34;,
        &#34;float32&#34;: &#34;Float32&#34;
    },
    &#34;endian&#34;: {
        &#34;little&#34;: &#34;Little&#34;,
        &#34;big&#34;: &#34;Big&#34;
    }
}

cera_converter = {
    &#34;datatype&#34;: {
        &#34;uint16&#34;: &#34;uint16&#34;,
        &#34;float32&#34;: &#34;float&#34;
    }
}

def is_version_supported(supported_version:dict, version_to_test:dict) -&gt; bool:
    &#34;&#34;&#34;Test if the given version is supported by the toolbox.

    Parameters
    ----------
    supported_version : dict
        The version against which should be tested: a dictionary with the keys
        `&#34;major&#34;` and `&#34;minor&#34;`. Pass the global variable
        `ctsimu_supported_scenario_version` or `ctsimu_supported_metadata_version`.

    version_to_test : dict
        The version to test if it is supported. Must be a dictionary with
        the keys `&#34;major&#34;` and `&#34;minor&#34;`.

    Returns
    -------
    is_supported : bool
        If the given version number is supported by the toolbox scenario module.
    &#34;&#34;&#34;

    if (version_to_test is not None) and (supported_version is not None):
        if supported_version[&#34;major&#34;] &gt; version_to_test[&#34;major&#34;]:
            return True

        if supported_version[&#34;major&#34;] == version_to_test[&#34;major&#34;]:
            if supported_version[&#34;minor&#34;] &gt;= version_to_test[&#34;minor&#34;]:
                return True

    return False

def log(message:str):
    &#34;&#34;&#34;Print an output message.

    Parameters
    ----------
    message : str
        Message to be printed.
    &#34;&#34;&#34;
    print(message)

# ----------------
# JSON Handling
# ----------------
valid_native_units = [
        None, &#34;mm&#34;, &#34;rad&#34;, &#34;deg&#34;, &#34;s&#34;, &#34;mA&#34;, &#34;kV&#34;, &#34;g/cm^3&#34;, &#34;lp/mm&#34;, &#34;deg/s&#34;, &#34;C&#34;, &#34;bool&#34;, &#34;string&#34;
    ]
valid_dummy_units = [&#34;px&#34;, &#34;1/J&#34;, &#34;relative&#34;] # units that are not converted
native_units_to_omit_in_json_file = [None, &#34;bool&#34;, &#34;string&#34;]

def is_valid_native_unit(native_unit:str) -&gt; bool:
    &#34;&#34;&#34;Check if given string is a valid native unit.

    Parameters
    ----------
    native_unit : str
        The string to check if it is a valid native unit.

    Returns
    -------
    is_valid : bool
        `True` if the provided string is a valid native unit, `False` if not.
    &#34;&#34;&#34;

    if (native_unit in valid_native_units) or (native_unit in valid_dummy_units):
        return True

    raise Exception(f&#34;CTSimU: Not a valid native unit: &#39;{native_unit}&#39;. Valid options are: {valid_native_units}.&#34;)
    return False

def touch_directory(filename:str):
    &#34;&#34;&#34;Create folder if it doesn&#39;t exist.

    Parameters
    ----------
    filename : str
        Complete path to a file. Can include filename.
    &#34;&#34;&#34;

    folder = os.path.dirname(filename)

    if folder == &#34;&#34; or folder is None:
            folder = &#34;.&#34;

    if not os.path.exists(folder):
        os.makedirs(folder)

    return folder

def backslash_to_slash(s:str) -&gt; str:
    &#34;&#34;&#34;Convert backslashed to slashes, used for Windows paths.

    Parameters
    ----------
    s : str
        String in which the replace will take place.

    Returns
    -------
    converted : str
        String where backslashes are replaced by slashes.
    &#34;&#34;&#34;
    return s.replace(&#34;\\&#34;, &#34;/&#34;)

def join_dir_and_filename(directory:str, filename:str) -&gt; str:
    &#34;&#34;&#34;Joins directory and filename into a meaningful path.

    Parameters
    ----------
    directory: str
        Directory part of the path. Set to `None` for no
        directory.

    filename : str
        Filename part of the path.

    Returns
    -------
    full_path : str
        Fully joined path.
    &#34;&#34;&#34;

    if directory is not None:
        if directory != &#34;&#34;:
            joined = os.path.join(directory, filename)
            return backslash_to_slash(joined)

    return backslash_to_slash(filename)

def abspath_of_referenced_file(filepath:str, referenced:str) -&gt; str:
    &#34;&#34;&#34;Get the absolute path of an external file `referenced` in `file`.

    Parameters
    ----------
    filepath : str
        The path of a file (e.g. scenario or metadata) in which
        an external file is referenced.

    referenced : str
        The path (relative to `filepath` or absolute)
        of the referenced file.

    Returns
    -------
    referenced_abs : str
        Absolute path of the referenced file.
    &#34;&#34;&#34;
    if referenced is None:
        return referenced

    if not os.path.isabs(referenced):
        if filepath is not None:
            file_abspath = os.path.abspath(filepath)
            file_absdir  = os.path.dirname(file_abspath)
            referenced_abspath = join_dir_and_filename(file_absdir, referenced)

            # Simplify relative dots away:
            referenced_abspath = os.path.abspath(referenced_abspath)
            return backslash_to_slash(referenced_abspath)
        else:
            # Assume that an abspath from the current working
            # directory is requested:
            return backslash_to_slash(os.path.abspath(referenced))
    else:
        return backslash_to_slash(referenced)  # already an absolute path

def read_json_file(filename:str) -&gt; dict:
    &#34;&#34;&#34;Read a JSON file into a Python dictionary.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    Returns
    -------
    dictionary : dict
        Dictionary representation of the JSON structure.
    &#34;&#34;&#34;

    if isinstance(filename, str):
        if os.path.isfile(filename):
            if os.path.exists(filename):
                with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
                    json_dict = json.load(f)
                    f.close()
                    return json_dict
            else:
                raise Exception(f&#34;File not found: &#39;{filename}&#39;&#34;)
        else:
            raise Exception(f&#34;File not found: &#39;{filename}&#39;&#34;)

    raise Exception(f&#34;Cannot read JSON file: {filename}&#34;)

def json_from_pkg(filename:str) -&gt; dict:
    &#34;&#34;&#34;Read a JSON file included in the package.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    Returns
    -------
    dictionary : dict
        Dictionary representation of the JSON structure.
    &#34;&#34;&#34;
    json_text = pkgutil.get_data(__name__, filename).decode()
    return json.loads(json_text)

def pkg_scenario(filename:str, level:str=&#34;root&#34;) -&gt; str:
    &#34;&#34;&#34;Return path to scenario file included in this package.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    level : str
        From where the file needs to be reached.

        Possible values: `&#34;root&#34;`, `&#34;test&#34;`

    Returns
    -------
    scenario_path : dict
        Path to the scenario within the package.
    &#34;&#34;&#34;
    if level == &#34;root&#34;:
        return f&#34;evaluation/scenarios/{filename}&#34;
    elif level == &#34;test&#34;:
        return f&#34;scenarios/{filename}&#34;

    raise Exception(f&#34;pkg_scenario: Invalid level: {level}&#34;)

def counter_format(n:int, zero_padding:bool=True) -&gt; str:
    &#34;&#34;&#34;Create a default counter format for sequentially numbered files.

    Parameters
    ----------
    n : int
        Number of files, starting from zero.

    zero_padding : bool
        Are the files zero-padded from the left?

    Returns
    -------
    counter_format : str
        Counter format string, e.g. &#39;%05d&#39; for `n`=20000 files.
        At least four digits will be assumed, even if `n` is smaller.
    &#34;&#34;&#34;
    digits = 4

    # For anything bigger than 10000 projections (0000 ... 9999)
    # we need more filename digits:
    if n &gt; 10000:
        digits = int(math.ceil(math.log10(float(n))))

    if zero_padding:
        pcformat = f&#34;%0{int(digits)}d&#34;
    else:
        pcformat = f&#34;%d&#34;

    return pcformat


def convert(converter_dict:dict, key:str) -&gt; str:
    &#34;&#34;&#34;Map a string to a different (converted) string.

    Parameters
    ----------
    converter_dict : dict
        Mapping dictionary.

    key : str
        Key to be converted.

    Returns
    -------
    mapped_value : str
        String that&#39;s mapped to the key.
    &#34;&#34;&#34;
    if key is None:
        return None

    if key in converter_dict:
        return converter_dict[key]
    else:
        raise Exception(f&#34;Cannot convert: key &#39;{key}&#39; not found in converter dictionary.&#34;)

def write_json_file(filename:str, dictionary:dict):
    &#34;&#34;&#34;Write a JSON file from a given Python dictionary.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    dictionary : dict
        Dictionary for the JSON file.
    &#34;&#34;&#34;

    folder = touch_directory(filename)
    if os.path.exists(folder):
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            json.dump(dictionary, f, ensure_ascii=False, indent=&#34;\t&#34;)
            f.close()
    else:
        raise Exception(f&#34;Error writing JSON file. Directory does not exist: {folder}&#34;)

def read_csv_file(filename:str) -&gt; dict:
    &#34;&#34;&#34;Read a CSV file.

    Parameters
    ----------
    filename : str
        Filename of the CSV file to read.

    Returns
    -------
    data : list
        Each item in the returned list contains the values of one column from the CSV file.
    &#34;&#34;&#34;

    values = []
    n_columns = 0

    with open(filename, newline=&#39;&#39;) as f:
        try:
            # Detect the CSV dialect: comma or tab-separated?
            dialect = csv.Sniffer().sniff(f.read(1024))
        except:
            dialect = None

        # Return to beginning
        f.seek(0)

        reader = csv.reader(f, dialect)
        for row in reader:
            if row[0].startswith(&#39;#&#39;):
                # ignore commented lines
                continue

            if n_columns == 0:
                # Number of columns apparently not initialized yet.
                n_columns = len(row)
                for i in range(n_columns):
                    # Append an empty list for each column:
                    values.append([])

            for col, entry in enumerate(row):
                values[col].append(entry)

    return values

def value_is_null(value) -&gt; bool:
    &#34;&#34;&#34;Check if a specific JSON value is set to `null`.

    Parameters
    ----------
    value
        Value to check for nullness.

    Returns
    -------
    is_null : bool
        `True` if the value corresponds to a JSON `null`,
        `False` if it is something else.
    &#34;&#34;&#34;
    if value is None:
        return True

    return False

def value_is_null_or_zero(value) -&gt; bool:
    &#34;&#34;&#34;Check if a specific value is set to `null` or `0`.

    Parameters
    ----------
    value
        Value to check for nullness or zeroness.

    Returns
    -------
    is_null_or_zero : bool
        `True` if the value corresponds to a JSON `null`
        or has the numerical value `0`, `False` if it is something else.
    &#34;&#34;&#34;
    if value is not None:
        if value != 0:
            return False

    return True

def object_value_is_null(json_obj:dict) -&gt; bool:
    &#34;&#34;&#34;Check if a CTSimU JSON parameter object represents a
    `null` value, either because its `&#34;value&#34;` property is
    set to a JSON `null` or because it does not have
    a `&#34;value&#34;` property at all.

    Parameters
    ----------
    json_obj : dict
        Dictionary (as from a JSON structure) to check.

    Returns
    -------
    is_null : bool
        `True` if the object&#39;s `&#34;value&#34;` corresponds to a JSON `null`
        or if the object does not define a `&#34;value&#34;`.
        `False` if the object value is something else.

    Raises
    ------
    TypeError
        If `json_obj` is not a dictionary.
    &#34;&#34;&#34;
    if json_obj is None:
        return True

    if not isinstance(json_obj, dict):
        return False

    if &#34;value&#34; in json_obj:
        return value_is_null(json_obj[&#34;value&#34;])

    return True

def object_value_is_null_or_zero(json_obj:dict) -&gt; bool:
    &#34;&#34;&#34;Check if a CTSimU JSON parameter object represents
    `null` value or the numerical value `0`, either because
    its `&#34;value&#34;` property is set to a JSON `null` or `0`,
    or because it does not have a `&#34;value&#34;` property at all.

    Parameters
    ----------
    json_obj : dict
        Dictionary (as from a JSON structure) to check.

    Returns
    -------
    is_null_or_zero : bool
        `True` if the object&#39;s `&#34;value&#34;` corresponds to a JSON `null`
        or if the object does not define a `&#34;value&#34;`.
        `False` if the object value is something else.

    Raises
    ------
    TypeError
        If `json_obj` is not a dictionary.
    &#34;&#34;&#34;
    if not isinstance(json_obj, dict):
        raise TypeError(&#34;object_value_is_null_or_zero() expects dict for the `json_obj`.&#34;)

    if &#34;value&#34; in json_obj:
        return value_is_null_or_zero(json_obj[&#34;value&#34;])

    return True

def get_value_or_none(dictionary:dict, *keys:str) -&gt; float | str | bool | dict | list:
    &#34;&#34;&#34;Get the dictionary value that is located at the given
    sequence of `keys`. If it cannot be found, return `None`.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    *keys : str
        Sequence of keys that identify a location in the dictionary tree.

    Returns
    -------
    value : float or str or bool or dict or list
        The entry in the `dictionary`, located by the sequence of `keys`,
        or `None` if the entry cannot be found.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if not isinstance(dictionary, dict):
        raise TypeError(&#34;get_value_or_none() expects dict as first argument for the `dictionary`.&#34;)

    if len(keys) == 0:
        return dictionary

    current_element = dictionary

    if keys is None:
        return None
    else:
        for key in keys:
            if current_element is not None:
                if key in current_element:
                    current_element = current_element[key]
                else:
                    return None
            else:
                return None

    return current_element

def get_value(dictionary:dict, keys:list, fail_value=None) -&gt; float | str | bool | dict | list:
    &#34;&#34;&#34;Get the specific value of the parameter that is
    located at the given sequence of `keys` in the JSON dictionary.

    If that element cannot be found or is set to `null`,
    return the `fail_value`.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    fail_value : float or str or bool or dict or list, optional
        Value to return if the given list of keys cannot be found
        in the dictionary.

    Returns
    -------
    value : float or str or bool or dict or list
        The entry in the `dictionary`, located by the sequence of `keys`
        or the `fail_value` if the entry cannot be found.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if not isinstance(dictionary, dict):
        raise TypeError(&#34;get_value() expects dict as first argument for the `dictionary`.&#34;)

    if len(keys) == 0:
        return dictionary

    result = get_value_or_none(dictionary, *keys)
    if result is None:
        return fail_value

    return result

def json_exists(dictionary:dict, keys:list) -&gt; bool:
    &#34;&#34;&#34;Check if the given key sequence can be found in the dictionary tree.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    exists : bool
        `True` if the given key sequence identifies an object or
        value in the dictionary, `False` if nothing can be found
        at the given sequence of keys.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;

    if not isinstance(dictionary, dict):
        return False

    if len(keys) == 0:
        return True

    current_element = dictionary
    for key in keys:
        if current_element is not None:
            if key in current_element:
                current_element = current_element[key]
            else:
                return False
        else:
            # Current element is &#39;None&#39; but we still
            # need to go down at least another &#39;key&#39;.
            return False

    return True

def json_isnull(dictionary:dict, keys:list) -&gt; bool:
    &#34;&#34;&#34;Check if the value at the given key sequence corresponds
    to a JSON `null`, or if the value cannot be found at all.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    is_null : bool
        `True` if the given key sequence identifies a `null` value
        or if the value cannot be found at all. `False` otherwise.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if not isinstance(dictionary, dict):
        raise TypeError(&#34;json_isnull() expects dict as first argument for the `dictionary`.&#34;)
    if len(keys) == 0:
        return True

    v = get_value(dictionary, keys)
    if v is None:
        return True

    return False

def json_exists_and_not_null(dictionary:dict, keys:list) -&gt; bool:
    &#34;&#34;&#34;Check if the value at the given key sequence
    exists and does not correspond to a JSON `null`.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    exists_and_not_null : bool
        `True` if the given key sequence exists and does
        not identify a `null` value, `False` otherwise.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if json_exists(dictionary, keys):
        if not json_isnull(dictionary, keys):
            return True

    return False

def json_extract(dictionary:dict, keys:list) -&gt; float | str | bool | dict | list:
    &#34;&#34;&#34;Get the JSON sub-object that is located
    at a given sequence of `keys` in the JSON dictionary.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    value : float or str or bool or dict or list
        The value, object or array located at the given key sequence,
        `None` if nothing can be found at the given key sequence.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    return get_value(dictionary, keys)

def json_extract_from_possible_keys(dictionary:dict, key_lists:list):
    &#34;&#34;&#34;Searches the JSON object for each key sequence in the given
    list of key sequences. The first sequence that exists will be used to
    extract and return the corresponding JSON object.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    key_lists : list
        List of lists of keys that possibly specify a valid
        location in the dictionary tree.

    Returns
    -------
    value : float or str or bool or dict or list
        The value, object or array located at the first valid key sequence,
        `None` if nothing can be found at any of the given key sequences.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    for keys in key_lists:
        if json_exists(dictionary, keys):
            return json_extract(dictionary, keys)

    return None

# ------------------------------------
# CTSimU conversions to native units
# ------------------------------------
# Each function supports the allowed units from the CTSimU file format specification.

def in_mm(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a length to mm.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;nm&#34;`, `&#34;um&#34;`, `&#34;mm&#34;`, `&#34;cm&#34;`, `&#34;dm&#34;`, `&#34;m&#34;`

    Returns
    -------
    value_in_mm : float
        The value converted to millimeters,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of length.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;nm&#34;: return (value * 1.0e-6)
        if unit == &#34;um&#34;: return (value * 1.0e-3)
        if unit == &#34;mm&#34;: return value
        if unit == &#34;cm&#34;: return (value * 10.0)
        if unit == &#34;dm&#34;: return (value * 100.0)
        if unit == &#34;m&#34;:  return (value * 1000.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of length: &#39;{unit}&#39;.&#34;)

def in_rad(value:float, unit:str=&#34;deg&#34;) -&gt; float:
    &#34;&#34;&#34;Convert an angle to radians.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;rad&#34;`, `&#34;deg&#34;`

    Returns
    -------
    value_in_rad : float
        The value converted to rad,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid angular unit.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;deg&#34;: return (value * math.pi / 180.0)
        if unit == &#34;rad&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid angular unit: &#39;{unit}&#39;.&#34;)

def in_deg(value:float, unit:str=&#34;rad&#34;) -&gt; float:
    &#34;&#34;&#34;Convert an angle to degrees.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;rad&#34;`, `&#34;deg&#34;`

    Returns
    -------
    value_in_deg : float
        The value converted to degrees,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid angular unit.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;rad&#34;: return (value * 180.0 / math.pi)
        if unit == &#34;deg&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid angular unit: &#39;{unit}&#39;.&#34;)

def in_s(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a time to seconds.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;ms&#34;`, `&#34;s&#34;`, `&#34;min&#34;`, `&#34;h&#34;`

    Returns
    -------
    value_in_s : float
        The value converted to seconds,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of time.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;ms&#34;:  return (value * 1.0e-3)
        if unit == &#34;s&#34;:   return value
        if unit == &#34;min&#34;: return (value * 60.0)
        if unit == &#34;h&#34;:   return (value * 3600.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of time: &#39;{unit}&#39;.&#34;)

def in_mA(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert an electric current to mA.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;uA&#34;`, `&#34;mA&#34;`, `&#34;A&#34;`

    Returns
    -------
    value_in_mA : float
        The value converted to milliamps,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of electric current.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;uA&#34;: return (value * 1.0e-3)
        if unit == &#34;mA&#34;: return value
        if unit == &#34;A&#34;:  return (value * 1000.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of electric current: &#39;{unit}&#39;.&#34;)

def in_kV(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a voltage to kV.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;V&#34;`, `&#34;kV&#34;`, `&#34;MV&#34;`

    Returns
    -------
    value_in_kV : float
        The value converted to kilovolts,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of electric voltage.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;V&#34;:  return (value * 1.0e-3)
        if unit == &#34;kV&#34;: return value
        if unit == &#34;MV&#34;: return (value * 1000.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of electric voltage: &#39;{unit}&#39;.&#34;)

def in_deg_per_s(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert an angular velocity to deg/s.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;rad/s&#34;`, `&#34;rad/min&#34;`, `&#34;rad/h&#34;`, `&#34;deg/s&#34;`,
        `&#34;deg/min&#34;`, `&#34;deg/h&#34;`

    Returns
    -------
    value_in_deg_per_s : float
        The value converted to degrees per second,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of angular velocity.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;rad/s&#34;:   return math.degrees(value)
        if unit == &#34;rad/min&#34;: return math.degrees(value / 60.0)
        if unit == &#34;rad/h&#34;:   return math.degrees(value / 3600.0)
        if unit == &#34;deg/s&#34;:   return value
        if unit == &#34;deg/min&#34;: return value / 60.0
        if unit == &#34;deg/h&#34;:   return value / 3600.0
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of angular velocity: &#39;{unit}&#39;.&#34;)

def in_g_per_cm3(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a mass density to g/cmÂ³.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;kg/m^3&#34;`, `&#34;g/cm^3&#34;`

    Returns
    -------
    value_in_g_per_cm3 : float
        The value converted to grams per cubic centimeter,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of mass density.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;kg/m^3&#34;: return (value * 1.0e-3)
        if unit == &#34;g/cm^3&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of mass density: &#39;{unit}&#39;.&#34;)

def in_lp_per_mm(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a resolution to line pairs per millimeter.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;lp/mm&#34;`, `&#34;lp/cm&#34;`, `&#34;lp/dm&#34;`, `&#34;lp/m&#34;`

    Returns
    -------
    value_in_lp_per_mm : float
        The value converted to line pairs per millimeter,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for resolution.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;lp/mm&#34;: return value
        if unit == &#34;lp/cm&#34;: return (value * 0.1)
        if unit == &#34;lp/dm&#34;: return (value * 0.01)
        if unit == &#34;lp/m&#34;:  return (value * 0.001)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for resolution: &#39;{unit}&#39;.&#34;)

def in_celsius(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a temperature to degree Celsius.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;C&#34;`, `&#34;K&#34;`, `&#34;F&#34;`

    Returns
    -------
    value_in_celsius : float
        The value converted to degree Celsius,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for temperature.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;C&#34;: return value
        if unit == &#34;K&#34;: return (value - 273.15)
        if unit == &#34;F&#34;: return (value - 32) * 5.0/9.0
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for temperature: &#39;{unit}&#39;.&#34;)

def in_kelvin(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a temperature to Kelvin.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;C&#34;`, `&#34;K&#34;`, `&#34;F&#34;`

    Returns
    -------
    value_in_kelvin : float
        The value converted to Kelvin,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for temperature.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;C&#34;: return (value + 273.15)
        if unit == &#34;K&#34;: return value
        if unit == &#34;F&#34;: return (value + 459.67) * 5.0/9.0
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for temperature: &#39;{unit}&#39;.&#34;)

def in_fahrenheit(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a temperature to Fahrenheit.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;C&#34;`, `&#34;K&#34;`, `&#34;F&#34;`

    Returns
    -------
    value_in_fahrenheit : float
        The value converted to Fahrenheit,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for temperature.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;C&#34;: return (value * 9.0/5.0) + 32.0
        if unit == &#34;K&#34;: return (value * 9.0/5.0) - 459.67
        if unit == &#34;F&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for temperature: &#39;{unit}&#39;.&#34;)

def from_bool(value) -&gt; bool:
    &#34;&#34;&#34;Convert `value` into a true Python boolean.
    (For example, `1` becomes `True`, and `0` becomes `False`.)

    Parameters
    ----------
    value
        Any value that can be checked with a Python `if`.

    Returns
    -------
    b : bool
        `True` if the value evaluates to `True`,
        otherwise `False`.
    &#34;&#34;&#34;
    if value:
        return True

    return False

def convert_SNR_FWHM(SNR_or_FWHM:float, mean:float) -&gt; float:
    &#34;&#34;&#34;Converts between SNR and Gaussian FWHM for a
    given `mean` value of the Gaussian distribution (e.g., intensity).

    Parameters
    ----------
    SNR_or_FWHM : float
        SNR value (signal to noise ratio) or
        FWHM value (full width at half maximum).

    mean : float
        Mean value of the Gaussian distribution.

    Returns
    -------
    FWHM_or_SNR : float
        FWHM if an SNR was given, or the SNR if an FWHM was given.
    &#34;&#34;&#34;

    return 2.0 * math.sqrt(2.0 * log(2.0)) * float(mean) / float(SNR_or_FWHM)

def convert_to_native_unit(given_unit:str, native_unit:str, value:float) -&gt; float | str | bool:
    &#34;&#34;&#34;Check which native unit is requested, convert value accordingly.

    If the `native_unit` is set to None, the `value` will simply
    be returned as it is (i.e., unaltered).

    Parameters
    ----------
    given_unit : str
        The unit of the given value.

    native_unit : str
        The native unit into which the value must be converted.
        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`,
        `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

    value : float or str or bool
        Value to convert.

    Returns
    -------
    value_in_native_unit : float or str or bool
        Converted value.

    Raises
    ------
    ValueError
        If the `given_unit` is not compatible with the `native_unit`.
        For example, the function cannot convert a length into a time.
    &#34;&#34;&#34;
    if native_unit is None:
        return value
    elif native_unit in valid_dummy_units:
        return value
    else:
        if native_unit == &#34;string&#34;: return value
        if native_unit == &#34;mm&#34;:     return in_mm(value, given_unit)
        if native_unit == &#34;s&#34;:      return in_s(value, given_unit)
        if native_unit == &#34;deg&#34;:    return in_deg(value, given_unit)
        if native_unit == &#34;rad&#34;:    return in_rad(value, given_unit)
        if native_unit == &#34;mA&#34;:     return in_mA(value, given_unit)
        if native_unit == &#34;kV&#34;:     return in_kV(value, given_unit)
        if native_unit == &#34;deg/s&#34;:  return in_deg_per_s(value, given_unit)
        if native_unit == &#34;g/cm^3&#34;: return in_g_per_cm3(value, given_unit)
        if native_unit == &#34;lp/mm&#34;:  return in_lp_per_mm(value, given_unit)
        if native_unit == &#34;C&#34;:      return in_celsius(value, given_unit)
        if native_unit == &#34;bool&#34;:   return from_bool(value)

    raise ValueError(f&#34;Native unit &#39;{native_unit}&#39; is incompatible with the given unit &#39;{given_unit}&#39;.&#34;)
    return None

def json_convert_to_native_unit(native_unit:str, value_and_unit:dict, fallback_json_unit:str=None) -&gt; float | str | bool:
    &#34;&#34;&#34;Convert a value/unit pair from a dictionary into
    the requested `native_unit`.

    Works like the function `convert_to_native_unit`, but takes
    a JSON object `value_and_unit`, i.e. a dictionary that must contain
    a `value` and an associated `unit`. Checks which native unit is requested,
    and converts the JSON `value` accordingly.

    `fallback_json_unit` is used if the unit is not specified
    in the `value_and_unit` JSON object.

    Parameters
    ----------
    native_unit : str
        The native unit into which the value will be converted.
        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`,
        `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

    value_and_unit : dict
        Dictionary that specifies a `&#34;value&#34;` and a `&#34;unit&#34;`,
        as imported from a CTSimU JSON parameter object.

    fallback_json_unit : str, optional
        The fallback unit to be used if the `value_and_unit` dictionary
        does not specify a unit.

    Returns
    -------
    value_in_native_unit : float or str or bool
        Converted value.

    Raises
    ------
    ValueError
        If the unit given in the dictionary is not compatible
        with the requested `native_unit`. For example, the function
        cannot convert a length into a time.
        Also, if no valid value/unit pair is provided in the given
        `value_and_unit` dictionary.
    &#34;&#34;&#34;

    if native_unit is None:
        # No native unit given. Simply return the value.
        return get_value(value_and_unit, [&#34;value&#34;])
    elif native_unit == &#34;bool&#34;:
        # This is not a value/unit dictionary, but a boolean.
        return from_bool(value_and_unit)
    elif native_unit == &#34;string&#34;:
        if json_exists(value_and_unit, [&#34;value&#34;]):
            return str(get_value(value_and_unit, [&#34;value&#34;]))
        else:
            if isinstance(value_and_unit, str):
                return value_and_unit

        raise TypeError(f&#34;Given value does not seem to be a string: {value_and_unit}&#34;)
    else:
        if json_exists(value_and_unit, [&#34;value&#34;]):
            value = get_value(value_and_unit, [&#34;value&#34;])
            unit = fallback_json_unit
            if json_exists(value_and_unit, [&#34;unit&#34;]):
                # The unit does not necessarily have to exist.
                # For example, in the case of strings it is clear
                # just from the native unit.
                unit = get_value(value_and_unit, [&#34;unit&#34;])

            return convert_to_native_unit(unit, native_unit, value)

    raise ValueError(f&#34;Failed to convert a value to &#39;{native_unit}&#39;: no valid value/unit pair is provided from the JSON object.&#34;)

def convert_to_preferred_unit(preferred_unit:str, native_unit:str, value:float):
    &#34;&#34;&#34;Convert a value from its native unit to the
    preferred unit.

    Parameters
    ----------
    preferred_unit : str
        Preferred unit to be returned.

    native_unit : str
        Value&#39;s current native unit.

    value : float
        Value in its native unit.

    Returns
    -------
    value : float
        Value in preferred unit.
    &#34;&#34;&#34;
    if value is not None:
        if isinstance(value, numbers.Number):
            # Catch temperatures (with non-scaling conversions):
            if preferred_unit == &#34;C&#34;:
                return in_celsius(value, native_unit)
            elif preferred_unit == &#34;K&#34;:
                return in_kelvin(value, native_unit)
            elif preferred_unit == &#34;F&#34;:
                return in_fahrenheit(value, native_unit)
            else:
                # Find conversion factor to native:
                conversion_factor = convert_to_native_unit(
                    given_unit=preferred_unit,
                    native_unit=native_unit,
                    value=1)

                # Conversion factor to preferred unit is
                # just the inverse:
                if conversion_factor != 0:
                    return value / conversion_factor

    return value

def get_value_in_native_unit(native_unit:str, dictionary:dict, keys:list, fail_value=None) -&gt; float | str | bool:
    &#34;&#34;&#34;Get a parameter value in the `native_unit`,
    located at a sequence of `keys` in a given `dictionary`.

    Parameters
    ----------
    native_unit : str
        The native unit into which the value will be converted.
        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`,
        `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

    dictionary : dict
        Dictionary representation of the JSON structure.

    keys : list
        List of strings that identify the location of the paramter in
        the dictionary.

    fail_value : float or str or bool
        The value that will be returned if nothing can be found
        at the given sequence of `keys`.

    Returns
    -------
    value_in_native_unit : float or str or bool
        Converted value or `fail_value` if nothing could be found.

    Raises
    ------
    ValueError
        If the unit given in the dictionary is not compatible
        with the requested `native_unit`. For example, the function
        cannot convert a length into a time.
        Also, if no valid value/unit pair is provided in the given
        `value_and_unit` dictionary.
    &#34;&#34;&#34;
    if json_exists_and_not_null(dictionary, keys):
        value_unit_pair = json_extract(dictionary, keys)
        if (not object_value_is_null(value_unit_pair) or (native_unit==&#34;string&#34;) or (native_unit==&#34;bool&#34;)):
            value = json_convert_to_native_unit(native_unit, value_unit_pair)

            if value is not None:
                return value

    return fail_value

# -----------------------
# Further little helpers
# -----------------------

def list_mean(l:list) -&gt; float:
    &#34;&#34;&#34;Mean value for a list of values.

    Parameters
    ----------
    l : list
        List of values, e.g. &#39;float&#39;.

    Returns
    -------
    mean : float
        The mean of the value list.
    &#34;&#34;&#34;
    return sum(l) / len(l)

def list_mean_and_stddev(l:list) -&gt; tuple[float, float]:
    &#34;&#34;&#34;Mean and standard deviation of a list of values.

    Parameters
    ----------
    l : list
        List of values, e.g. &#39;float&#39;.

    Returns
    -------
    mean : float
        The mean of the value list.

    standard_deviation : float
        Root mean square deviation (RMSD) of the value list.
    &#34;&#34;&#34;
    msqDev = 0
    mean = list_mean(l)
    for v in l:
        msqDev += math.pow(v - mean, 2)

    msqDev /= len(l)

    return mean, math.sqrt(msqDev)

def gaussian(x:float, mu:float, sigma:float, A:float) -&gt; float:
    &#34;&#34;&#34;Gaussian function.

    Parameters
    ----------
    x : float
        Input value (x axis).

    mu : float
        Distribution&#39;s mean value.

    sigma : float
        Distribution&#39;s standard deviation.

    A : float
        Distribution&#39;s amplitude, i.e., the maximum value.

    Returns
    -------
    y : float
        Output value (y axis).
        `y = A * exp((x-mu)**2 / (2*sigma**2))`
    &#34;&#34;&#34;
    return A*numpy.exp(-(x-mu)*(x-mu)/(2.0*sigma*sigma))

def poly4(x, a:float, b:float, c:float, d:float, e:float) -&gt; float:
    &#34;&#34;&#34; Fourth order polynomial, used for smoothing.

    Parameters
    ----------
    x : float
        Input value (x axis).

    a : float

    b : float

    c : float

    d : float

    e : float

    Returns
    -------
    y : float
        Output value (y axis).
        `y = ax^4 + bx^3 + cx^2 + dx + e`
    &#34;&#34;&#34;
    return a*(x**4) + b*(x**3) + c*(x**2) + d*x + e

def divide_and_error(muA:float, muB:float, errA:float, errB:float) -&gt; tuple[float, float]:
    &#34;&#34;&#34; Error propagation upon division; estimation of largest error. &#34;&#34;&#34;
    value = muA / muB
    err = errA/abs(muB) + errB*abs(muA/(muB**2))
    return value, err

def divide_and_gaussian_error(muA:float, muB:float, sigmaA:float, sigmaB:float) -&gt; tuple[float, float]:
    &#34;&#34;&#34; Gaussian error propagation upon division. &#34;&#34;&#34;
    value = muA / muB
    uncertainty = math.sqrt((sigmaA**2)/(muB**2) + (sigmaB**2)*(muA**2)/(muB**4))
    return value, uncertainty

def ratios(values:list) -&gt; list:
    &#34;&#34;&#34; Calculate ratio to preceding value, needed for step wedge evaluations. &#34;&#34;&#34;
    results = []
    for v in range(1, len(values)):
        results.append(values[v] / values[v-1])

    return results


&#34;&#34;&#34; Unit conversions for values from CTSimU scenario descriptions (JSON files). &#34;&#34;&#34;

def in_mm_json(jsonVal:dict) -&gt; float:
    &#34;&#34;&#34; Convert JSON value/unit pair to mm. &#34;&#34;&#34;
    if (&#34;value&#34; in jsonVal) and (&#34;unit&#34; in jsonVal):
        value = jsonVal[&#34;value&#34;]
        unit  = jsonVal[&#34;unit&#34;]

        if(unit == &#34;mm&#34;):
            return value
        elif(unit == &#34;nm&#34;):
            return (value * 1e-6)
        elif(unit == &#34;um&#34;):
            return (value * 1e-3)
        elif(unit == &#34;cm&#34;):
            return (value * 10)
        elif(unit == &#34;dm&#34;):
            return (value * 100)
        elif(unit == &#34;m&#34;):
            return (value * 1000)

        raise Exception(unit + &#34; is not a valid unit of length.&#34;)
    else:
        raise KeyError(&#34;\&#34;value\&#34; or \&#34;unit\&#34; missing.&#34;)

def in_rad_json(jsonVal:dict) -&gt; float:
    &#34;&#34;&#34; Convert JSON value/unit pair to radians. &#34;&#34;&#34;
    if (&#34;value&#34; in jsonVal) and (&#34;unit&#34; in jsonVal):
        value = jsonVal[&#34;value&#34;]
        unit  = jsonVal[&#34;unit&#34;]

        if(unit == &#34;rad&#34;):
            return value
        elif(unit == &#34;deg&#34;):
            return ((value * math.pi) / 180.0)

        raise Exception(unit + &#34; is not a valid angular unit.&#34;)
    else:
        raise KeyError(&#34;\&#34;value\&#34; or \&#34;unit\&#34; missing.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctsimu.helpers.abspath_of_referenced_file"><code class="name flex">
<span>def <span class="ident">abspath_of_referenced_file</span></span>(<span>filepath:Â str, referenced:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the absolute path of an external file <code>referenced</code> in <code>file</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of a file (e.g. scenario or metadata) in which
an external file is referenced.</dd>
<dt><strong><code>referenced</code></strong> :&ensp;<code>str</code></dt>
<dd>The path (relative to <code>filepath</code> or absolute)
of the referenced file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>referenced_abs</code></strong> :&ensp;<code>str</code></dt>
<dd>Absolute path of the referenced file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abspath_of_referenced_file(filepath:str, referenced:str) -&gt; str:
    &#34;&#34;&#34;Get the absolute path of an external file `referenced` in `file`.

    Parameters
    ----------
    filepath : str
        The path of a file (e.g. scenario or metadata) in which
        an external file is referenced.

    referenced : str
        The path (relative to `filepath` or absolute)
        of the referenced file.

    Returns
    -------
    referenced_abs : str
        Absolute path of the referenced file.
    &#34;&#34;&#34;
    if referenced is None:
        return referenced

    if not os.path.isabs(referenced):
        if filepath is not None:
            file_abspath = os.path.abspath(filepath)
            file_absdir  = os.path.dirname(file_abspath)
            referenced_abspath = join_dir_and_filename(file_absdir, referenced)

            # Simplify relative dots away:
            referenced_abspath = os.path.abspath(referenced_abspath)
            return backslash_to_slash(referenced_abspath)
        else:
            # Assume that an abspath from the current working
            # directory is requested:
            return backslash_to_slash(os.path.abspath(referenced))
    else:
        return backslash_to_slash(referenced)  # already an absolute path</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.backslash_to_slash"><code class="name flex">
<span>def <span class="ident">backslash_to_slash</span></span>(<span>s:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert backslashed to slashes, used for Windows paths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>String in which the replace will take place.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>converted</code></strong> :&ensp;<code>str</code></dt>
<dd>String where backslashes are replaced by slashes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backslash_to_slash(s:str) -&gt; str:
    &#34;&#34;&#34;Convert backslashed to slashes, used for Windows paths.

    Parameters
    ----------
    s : str
        String in which the replace will take place.

    Returns
    -------
    converted : str
        String where backslashes are replaced by slashes.
    &#34;&#34;&#34;
    return s.replace(&#34;\\&#34;, &#34;/&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>converter_dict:Â dict, key:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Map a string to a different (converted) string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>converter_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping dictionary.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Key to be converted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mapped_value</code></strong> :&ensp;<code>str</code></dt>
<dd>String that's mapped to the key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(converter_dict:dict, key:str) -&gt; str:
    &#34;&#34;&#34;Map a string to a different (converted) string.

    Parameters
    ----------
    converter_dict : dict
        Mapping dictionary.

    key : str
        Key to be converted.

    Returns
    -------
    mapped_value : str
        String that&#39;s mapped to the key.
    &#34;&#34;&#34;
    if key is None:
        return None

    if key in converter_dict:
        return converter_dict[key]
    else:
        raise Exception(f&#34;Cannot convert: key &#39;{key}&#39; not found in converter dictionary.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.convert_SNR_FWHM"><code class="name flex">
<span>def <span class="ident">convert_SNR_FWHM</span></span>(<span>SNR_or_FWHM:Â float, mean:Â float) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Converts between SNR and Gaussian FWHM for a
given <code>mean</code> value of the Gaussian distribution (e.g., intensity).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>SNR_or_FWHM</code></strong> :&ensp;<code>float</code></dt>
<dd>SNR value (signal to noise ratio) or
FWHM value (full width at half maximum).</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean value of the Gaussian distribution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>FWHM_or_SNR</code></strong> :&ensp;<code>float</code></dt>
<dd>FWHM if an SNR was given, or the SNR if an FWHM was given.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_SNR_FWHM(SNR_or_FWHM:float, mean:float) -&gt; float:
    &#34;&#34;&#34;Converts between SNR and Gaussian FWHM for a
    given `mean` value of the Gaussian distribution (e.g., intensity).

    Parameters
    ----------
    SNR_or_FWHM : float
        SNR value (signal to noise ratio) or
        FWHM value (full width at half maximum).

    mean : float
        Mean value of the Gaussian distribution.

    Returns
    -------
    FWHM_or_SNR : float
        FWHM if an SNR was given, or the SNR if an FWHM was given.
    &#34;&#34;&#34;

    return 2.0 * math.sqrt(2.0 * log(2.0)) * float(mean) / float(SNR_or_FWHM)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.convert_to_native_unit"><code class="name flex">
<span>def <span class="ident">convert_to_native_unit</span></span>(<span>given_unit:Â str, native_unit:Â str, value:Â float) â>Â floatÂ |Â strÂ |Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check which native unit is requested, convert value accordingly.</p>
<p>If the <code>native_unit</code> is set to None, the <code>value</code> will simply
be returned as it is (i.e., unaltered).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>given_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit of the given value.</dd>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The native unit into which the value must be converted.
Possible values: <code>None</code>, <code>"mm"</code>, <code>"rad"</code>, <code>"deg"</code>, <code>"s"</code>, <code>"mA"</code>,
<code>"kV"</code>, <code>"g/cm^3"</code>, <code>"lp/mm"</code>, <code>"deg/s"</code>, <code>"C"</code>, <code>"bool"</code>, <code>"string"</code>.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code></dt>
<dd>Value to convert.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_native_unit</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code></dt>
<dd>Converted value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the <code>given_unit</code> is not compatible with the <code>native_unit</code>.
For example, the function cannot convert a length into a time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_native_unit(given_unit:str, native_unit:str, value:float) -&gt; float | str | bool:
    &#34;&#34;&#34;Check which native unit is requested, convert value accordingly.

    If the `native_unit` is set to None, the `value` will simply
    be returned as it is (i.e., unaltered).

    Parameters
    ----------
    given_unit : str
        The unit of the given value.

    native_unit : str
        The native unit into which the value must be converted.
        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`,
        `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

    value : float or str or bool
        Value to convert.

    Returns
    -------
    value_in_native_unit : float or str or bool
        Converted value.

    Raises
    ------
    ValueError
        If the `given_unit` is not compatible with the `native_unit`.
        For example, the function cannot convert a length into a time.
    &#34;&#34;&#34;
    if native_unit is None:
        return value
    elif native_unit in valid_dummy_units:
        return value
    else:
        if native_unit == &#34;string&#34;: return value
        if native_unit == &#34;mm&#34;:     return in_mm(value, given_unit)
        if native_unit == &#34;s&#34;:      return in_s(value, given_unit)
        if native_unit == &#34;deg&#34;:    return in_deg(value, given_unit)
        if native_unit == &#34;rad&#34;:    return in_rad(value, given_unit)
        if native_unit == &#34;mA&#34;:     return in_mA(value, given_unit)
        if native_unit == &#34;kV&#34;:     return in_kV(value, given_unit)
        if native_unit == &#34;deg/s&#34;:  return in_deg_per_s(value, given_unit)
        if native_unit == &#34;g/cm^3&#34;: return in_g_per_cm3(value, given_unit)
        if native_unit == &#34;lp/mm&#34;:  return in_lp_per_mm(value, given_unit)
        if native_unit == &#34;C&#34;:      return in_celsius(value, given_unit)
        if native_unit == &#34;bool&#34;:   return from_bool(value)

    raise ValueError(f&#34;Native unit &#39;{native_unit}&#39; is incompatible with the given unit &#39;{given_unit}&#39;.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.convert_to_preferred_unit"><code class="name flex">
<span>def <span class="ident">convert_to_preferred_unit</span></span>(<span>preferred_unit:Â str, native_unit:Â str, value:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a value from its native unit to the
preferred unit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>preferred_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Preferred unit to be returned.</dd>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Value's current native unit.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value in its native unit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value in preferred unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_preferred_unit(preferred_unit:str, native_unit:str, value:float):
    &#34;&#34;&#34;Convert a value from its native unit to the
    preferred unit.

    Parameters
    ----------
    preferred_unit : str
        Preferred unit to be returned.

    native_unit : str
        Value&#39;s current native unit.

    value : float
        Value in its native unit.

    Returns
    -------
    value : float
        Value in preferred unit.
    &#34;&#34;&#34;
    if value is not None:
        if isinstance(value, numbers.Number):
            # Catch temperatures (with non-scaling conversions):
            if preferred_unit == &#34;C&#34;:
                return in_celsius(value, native_unit)
            elif preferred_unit == &#34;K&#34;:
                return in_kelvin(value, native_unit)
            elif preferred_unit == &#34;F&#34;:
                return in_fahrenheit(value, native_unit)
            else:
                # Find conversion factor to native:
                conversion_factor = convert_to_native_unit(
                    given_unit=preferred_unit,
                    native_unit=native_unit,
                    value=1)

                # Conversion factor to preferred unit is
                # just the inverse:
                if conversion_factor != 0:
                    return value / conversion_factor

    return value</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.counter_format"><code class="name flex">
<span>def <span class="ident">counter_format</span></span>(<span>n:Â int, zero_padding:Â boolÂ =Â True) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a default counter format for sequentially numbered files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of files, starting from zero.</dd>
<dt><strong><code>zero_padding</code></strong> :&ensp;<code>bool</code></dt>
<dd>Are the files zero-padded from the left?</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>counter_format</code></strong> :&ensp;<code>str</code></dt>
<dd>Counter format string, e.g. '%05d' for <code>n</code>=20000 files.
At least four digits will be assumed, even if <code>n</code> is smaller.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counter_format(n:int, zero_padding:bool=True) -&gt; str:
    &#34;&#34;&#34;Create a default counter format for sequentially numbered files.

    Parameters
    ----------
    n : int
        Number of files, starting from zero.

    zero_padding : bool
        Are the files zero-padded from the left?

    Returns
    -------
    counter_format : str
        Counter format string, e.g. &#39;%05d&#39; for `n`=20000 files.
        At least four digits will be assumed, even if `n` is smaller.
    &#34;&#34;&#34;
    digits = 4

    # For anything bigger than 10000 projections (0000 ... 9999)
    # we need more filename digits:
    if n &gt; 10000:
        digits = int(math.ceil(math.log10(float(n))))

    if zero_padding:
        pcformat = f&#34;%0{int(digits)}d&#34;
    else:
        pcformat = f&#34;%d&#34;

    return pcformat</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.divide_and_error"><code class="name flex">
<span>def <span class="ident">divide_and_error</span></span>(<span>muA:Â float, muB:Â float, errA:Â float, errB:Â float) â>Â tuple[float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Error propagation upon division; estimation of largest error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide_and_error(muA:float, muB:float, errA:float, errB:float) -&gt; tuple[float, float]:
    &#34;&#34;&#34; Error propagation upon division; estimation of largest error. &#34;&#34;&#34;
    value = muA / muB
    err = errA/abs(muB) + errB*abs(muA/(muB**2))
    return value, err</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.divide_and_gaussian_error"><code class="name flex">
<span>def <span class="ident">divide_and_gaussian_error</span></span>(<span>muA:Â float, muB:Â float, sigmaA:Â float, sigmaB:Â float) â>Â tuple[float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Gaussian error propagation upon division.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide_and_gaussian_error(muA:float, muB:float, sigmaA:float, sigmaB:float) -&gt; tuple[float, float]:
    &#34;&#34;&#34; Gaussian error propagation upon division. &#34;&#34;&#34;
    value = muA / muB
    uncertainty = math.sqrt((sigmaA**2)/(muB**2) + (sigmaB**2)*(muA**2)/(muB**4))
    return value, uncertainty</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.from_bool"><code class="name flex">
<span>def <span class="ident">from_bool</span></span>(<span>value) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Convert <code>value</code> into a true Python boolean.
(For example, <code>1</code> becomes <code>True</code>, and <code>0</code> becomes <code>False</code>.)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Any value that can be checked with a Python <code>if</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>b</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the value evaluates to <code>True</code>,
otherwise <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_bool(value) -&gt; bool:
    &#34;&#34;&#34;Convert `value` into a true Python boolean.
    (For example, `1` becomes `True`, and `0` becomes `False`.)

    Parameters
    ----------
    value
        Any value that can be checked with a Python `if`.

    Returns
    -------
    b : bool
        `True` if the value evaluates to `True`,
        otherwise `False`.
    &#34;&#34;&#34;
    if value:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.gaussian"><code class="name flex">
<span>def <span class="ident">gaussian</span></span>(<span>x:Â float, mu:Â float, sigma:Â float, A:Â float) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Gaussian function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Input value (x axis).</dd>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>Distribution's mean value.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Distribution's standard deviation.</dd>
<dt><strong><code>A</code></strong> :&ensp;<code>float</code></dt>
<dd>Distribution's amplitude, i.e., the maximum value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Output value (y axis).
<code>y = A * exp((x-mu)**2 / (2*sigma**2))</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian(x:float, mu:float, sigma:float, A:float) -&gt; float:
    &#34;&#34;&#34;Gaussian function.

    Parameters
    ----------
    x : float
        Input value (x axis).

    mu : float
        Distribution&#39;s mean value.

    sigma : float
        Distribution&#39;s standard deviation.

    A : float
        Distribution&#39;s amplitude, i.e., the maximum value.

    Returns
    -------
    y : float
        Output value (y axis).
        `y = A * exp((x-mu)**2 / (2*sigma**2))`
    &#34;&#34;&#34;
    return A*numpy.exp(-(x-mu)*(x-mu)/(2.0*sigma*sigma))</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>dictionary:Â dict, keys:Â list, fail_value=None) â>Â floatÂ |Â strÂ |Â boolÂ |Â dictÂ |Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Get the specific value of the parameter that is
located at the given sequence of <code>keys</code> in the JSON dictionary.</p>
<p>If that element cannot be found or is set to <code>null</code>,
return the <code>fail_value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure).</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>List of keys that identify a location in the dictionary tree.</dd>
<dt><strong><code>fail_value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code> or <code>dict</code> or <code>list</code>, optional</dt>
<dd>Value to return if the given list of keys cannot be found
in the dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code> or <code>dict</code> or <code>list</code></dt>
<dd>The entry in the <code>dictionary</code>, located by the sequence of <code>keys</code>
or the <code>fail_value</code> if the entry cannot be found.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dictionary</code> is not a Python <code>dict</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(dictionary:dict, keys:list, fail_value=None) -&gt; float | str | bool | dict | list:
    &#34;&#34;&#34;Get the specific value of the parameter that is
    located at the given sequence of `keys` in the JSON dictionary.

    If that element cannot be found or is set to `null`,
    return the `fail_value`.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    fail_value : float or str or bool or dict or list, optional
        Value to return if the given list of keys cannot be found
        in the dictionary.

    Returns
    -------
    value : float or str or bool or dict or list
        The entry in the `dictionary`, located by the sequence of `keys`
        or the `fail_value` if the entry cannot be found.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if not isinstance(dictionary, dict):
        raise TypeError(&#34;get_value() expects dict as first argument for the `dictionary`.&#34;)

    if len(keys) == 0:
        return dictionary

    result = get_value_or_none(dictionary, *keys)
    if result is None:
        return fail_value

    return result</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.get_value_in_native_unit"><code class="name flex">
<span>def <span class="ident">get_value_in_native_unit</span></span>(<span>native_unit:Â str, dictionary:Â dict, keys:Â list, fail_value=None) â>Â floatÂ |Â strÂ |Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Get a parameter value in the <code>native_unit</code>,
located at a sequence of <code>keys</code> in a given <code>dictionary</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The native unit into which the value will be converted.
Possible values: <code>None</code>, <code>"mm"</code>, <code>"rad"</code>, <code>"deg"</code>, <code>"s"</code>, <code>"mA"</code>,
<code>"kV"</code>, <code>"g/cm^3"</code>, <code>"lp/mm"</code>, <code>"deg/s"</code>, <code>"C"</code>, <code>"bool"</code>, <code>"string"</code>.</dd>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary representation of the JSON structure.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>List of strings that identify the location of the paramter in
the dictionary.</dd>
<dt><strong><code>fail_value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code></dt>
<dd>The value that will be returned if nothing can be found
at the given sequence of <code>keys</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_native_unit</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code></dt>
<dd>Converted value or <code>fail_value</code> if nothing could be found.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the unit given in the dictionary is not compatible
with the requested <code>native_unit</code>. For example, the function
cannot convert a length into a time.
Also, if no valid value/unit pair is provided in the given
<code>value_and_unit</code> dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_in_native_unit(native_unit:str, dictionary:dict, keys:list, fail_value=None) -&gt; float | str | bool:
    &#34;&#34;&#34;Get a parameter value in the `native_unit`,
    located at a sequence of `keys` in a given `dictionary`.

    Parameters
    ----------
    native_unit : str
        The native unit into which the value will be converted.
        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`,
        `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

    dictionary : dict
        Dictionary representation of the JSON structure.

    keys : list
        List of strings that identify the location of the paramter in
        the dictionary.

    fail_value : float or str or bool
        The value that will be returned if nothing can be found
        at the given sequence of `keys`.

    Returns
    -------
    value_in_native_unit : float or str or bool
        Converted value or `fail_value` if nothing could be found.

    Raises
    ------
    ValueError
        If the unit given in the dictionary is not compatible
        with the requested `native_unit`. For example, the function
        cannot convert a length into a time.
        Also, if no valid value/unit pair is provided in the given
        `value_and_unit` dictionary.
    &#34;&#34;&#34;
    if json_exists_and_not_null(dictionary, keys):
        value_unit_pair = json_extract(dictionary, keys)
        if (not object_value_is_null(value_unit_pair) or (native_unit==&#34;string&#34;) or (native_unit==&#34;bool&#34;)):
            value = json_convert_to_native_unit(native_unit, value_unit_pair)

            if value is not None:
                return value

    return fail_value</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.get_value_or_none"><code class="name flex">
<span>def <span class="ident">get_value_or_none</span></span>(<span>dictionary:Â dict, *keys:Â str) â>Â floatÂ |Â strÂ |Â boolÂ |Â dictÂ |Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Get the dictionary value that is located at the given
sequence of <code>keys</code>. If it cannot be found, return <code>None</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure).</dd>
<dt><strong><code>*keys</code></strong> :&ensp;<code>str</code></dt>
<dd>Sequence of keys that identify a location in the dictionary tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code> or <code>dict</code> or <code>list</code></dt>
<dd>The entry in the <code>dictionary</code>, located by the sequence of <code>keys</code>,
or <code>None</code> if the entry cannot be found.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dictionary</code> is not a Python <code>dict</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_or_none(dictionary:dict, *keys:str) -&gt; float | str | bool | dict | list:
    &#34;&#34;&#34;Get the dictionary value that is located at the given
    sequence of `keys`. If it cannot be found, return `None`.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    *keys : str
        Sequence of keys that identify a location in the dictionary tree.

    Returns
    -------
    value : float or str or bool or dict or list
        The entry in the `dictionary`, located by the sequence of `keys`,
        or `None` if the entry cannot be found.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if not isinstance(dictionary, dict):
        raise TypeError(&#34;get_value_or_none() expects dict as first argument for the `dictionary`.&#34;)

    if len(keys) == 0:
        return dictionary

    current_element = dictionary

    if keys is None:
        return None
    else:
        for key in keys:
            if current_element is not None:
                if key in current_element:
                    current_element = current_element[key]
                else:
                    return None
            else:
                return None

    return current_element</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_celsius"><code class="name flex">
<span>def <span class="ident">in_celsius</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a temperature to degree Celsius.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"C"</code>, <code>"K"</code>, <code>"F"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_celsius</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to degree Celsius,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit for temperature.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_celsius(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a temperature to degree Celsius.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;C&#34;`, `&#34;K&#34;`, `&#34;F&#34;`

    Returns
    -------
    value_in_celsius : float
        The value converted to degree Celsius,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for temperature.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;C&#34;: return value
        if unit == &#34;K&#34;: return (value - 273.15)
        if unit == &#34;F&#34;: return (value - 32) * 5.0/9.0
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for temperature: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_deg"><code class="name flex">
<span>def <span class="ident">in_deg</span></span>(<span>value:Â float, unit:Â strÂ =Â 'rad') â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an angle to degrees.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"rad"</code>, <code>"deg"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to degrees,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid angular unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_deg(value:float, unit:str=&#34;rad&#34;) -&gt; float:
    &#34;&#34;&#34;Convert an angle to degrees.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;rad&#34;`, `&#34;deg&#34;`

    Returns
    -------
    value_in_deg : float
        The value converted to degrees,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid angular unit.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;rad&#34;: return (value * 180.0 / math.pi)
        if unit == &#34;deg&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid angular unit: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_deg_per_s"><code class="name flex">
<span>def <span class="ident">in_deg_per_s</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an angular velocity to deg/s.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"rad/s"</code>, <code>"rad/min"</code>, <code>"rad/h"</code>, <code>"deg/s"</code>,
<code>"deg/min"</code>, <code>"deg/h"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_deg_per_s</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to degrees per second,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit of angular velocity.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_deg_per_s(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert an angular velocity to deg/s.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;rad/s&#34;`, `&#34;rad/min&#34;`, `&#34;rad/h&#34;`, `&#34;deg/s&#34;`,
        `&#34;deg/min&#34;`, `&#34;deg/h&#34;`

    Returns
    -------
    value_in_deg_per_s : float
        The value converted to degrees per second,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of angular velocity.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;rad/s&#34;:   return math.degrees(value)
        if unit == &#34;rad/min&#34;: return math.degrees(value / 60.0)
        if unit == &#34;rad/h&#34;:   return math.degrees(value / 3600.0)
        if unit == &#34;deg/s&#34;:   return value
        if unit == &#34;deg/min&#34;: return value / 60.0
        if unit == &#34;deg/h&#34;:   return value / 3600.0
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of angular velocity: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_fahrenheit"><code class="name flex">
<span>def <span class="ident">in_fahrenheit</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a temperature to Fahrenheit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"C"</code>, <code>"K"</code>, <code>"F"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_fahrenheit</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to Fahrenheit,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit for temperature.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_fahrenheit(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a temperature to Fahrenheit.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;C&#34;`, `&#34;K&#34;`, `&#34;F&#34;`

    Returns
    -------
    value_in_fahrenheit : float
        The value converted to Fahrenheit,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for temperature.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;C&#34;: return (value * 9.0/5.0) + 32.0
        if unit == &#34;K&#34;: return (value * 9.0/5.0) - 459.67
        if unit == &#34;F&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for temperature: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_g_per_cm3"><code class="name flex">
<span>def <span class="ident">in_g_per_cm3</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a mass density to g/cmÂ³.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"kg/m^3"</code>, <code>"g/cm^3"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_g_per_cm3</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to grams per cubic centimeter,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit of mass density.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_g_per_cm3(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a mass density to g/cmÂ³.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;kg/m^3&#34;`, `&#34;g/cm^3&#34;`

    Returns
    -------
    value_in_g_per_cm3 : float
        The value converted to grams per cubic centimeter,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of mass density.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;kg/m^3&#34;: return (value * 1.0e-3)
        if unit == &#34;g/cm^3&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of mass density: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_kV"><code class="name flex">
<span>def <span class="ident">in_kV</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a voltage to kV.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"V"</code>, <code>"kV"</code>, <code>"MV"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_kV</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to kilovolts,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit of electric voltage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kV(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a voltage to kV.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;V&#34;`, `&#34;kV&#34;`, `&#34;MV&#34;`

    Returns
    -------
    value_in_kV : float
        The value converted to kilovolts,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of electric voltage.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;V&#34;:  return (value * 1.0e-3)
        if unit == &#34;kV&#34;: return value
        if unit == &#34;MV&#34;: return (value * 1000.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of electric voltage: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_kelvin"><code class="name flex">
<span>def <span class="ident">in_kelvin</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a temperature to Kelvin.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"C"</code>, <code>"K"</code>, <code>"F"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_kelvin</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to Kelvin,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit for temperature.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kelvin(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a temperature to Kelvin.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;C&#34;`, `&#34;K&#34;`, `&#34;F&#34;`

    Returns
    -------
    value_in_kelvin : float
        The value converted to Kelvin,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for temperature.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;C&#34;: return (value + 273.15)
        if unit == &#34;K&#34;: return value
        if unit == &#34;F&#34;: return (value + 459.67) * 5.0/9.0
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for temperature: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_lp_per_mm"><code class="name flex">
<span>def <span class="ident">in_lp_per_mm</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a resolution to line pairs per millimeter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"lp/mm"</code>, <code>"lp/cm"</code>, <code>"lp/dm"</code>, <code>"lp/m"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_lp_per_mm</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to line pairs per millimeter,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit for resolution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_lp_per_mm(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a resolution to line pairs per millimeter.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;lp/mm&#34;`, `&#34;lp/cm&#34;`, `&#34;lp/dm&#34;`, `&#34;lp/m&#34;`

    Returns
    -------
    value_in_lp_per_mm : float
        The value converted to line pairs per millimeter,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit for resolution.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;lp/mm&#34;: return value
        if unit == &#34;lp/cm&#34;: return (value * 0.1)
        if unit == &#34;lp/dm&#34;: return (value * 0.01)
        if unit == &#34;lp/m&#34;:  return (value * 0.001)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit for resolution: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_mA"><code class="name flex">
<span>def <span class="ident">in_mA</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an electric current to mA.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"uA"</code>, <code>"mA"</code>, <code>"A"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_mA</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to milliamps,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit of electric current.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_mA(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert an electric current to mA.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;uA&#34;`, `&#34;mA&#34;`, `&#34;A&#34;`

    Returns
    -------
    value_in_mA : float
        The value converted to milliamps,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of electric current.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;uA&#34;: return (value * 1.0e-3)
        if unit == &#34;mA&#34;: return value
        if unit == &#34;A&#34;:  return (value * 1000.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of electric current: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_mm"><code class="name flex">
<span>def <span class="ident">in_mm</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a length to mm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"nm"</code>, <code>"um"</code>, <code>"mm"</code>, <code>"cm"</code>, <code>"dm"</code>, <code>"m"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_mm</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to millimeters,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit of length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_mm(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a length to mm.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;nm&#34;`, `&#34;um&#34;`, `&#34;mm&#34;`, `&#34;cm&#34;`, `&#34;dm&#34;`, `&#34;m&#34;`

    Returns
    -------
    value_in_mm : float
        The value converted to millimeters,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of length.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;nm&#34;: return (value * 1.0e-6)
        if unit == &#34;um&#34;: return (value * 1.0e-3)
        if unit == &#34;mm&#34;: return value
        if unit == &#34;cm&#34;: return (value * 10.0)
        if unit == &#34;dm&#34;: return (value * 100.0)
        if unit == &#34;m&#34;:  return (value * 1000.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of length: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_mm_json"><code class="name flex">
<span>def <span class="ident">in_mm_json</span></span>(<span>jsonVal:Â dict) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert JSON value/unit pair to mm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_mm_json(jsonVal:dict) -&gt; float:
    &#34;&#34;&#34; Convert JSON value/unit pair to mm. &#34;&#34;&#34;
    if (&#34;value&#34; in jsonVal) and (&#34;unit&#34; in jsonVal):
        value = jsonVal[&#34;value&#34;]
        unit  = jsonVal[&#34;unit&#34;]

        if(unit == &#34;mm&#34;):
            return value
        elif(unit == &#34;nm&#34;):
            return (value * 1e-6)
        elif(unit == &#34;um&#34;):
            return (value * 1e-3)
        elif(unit == &#34;cm&#34;):
            return (value * 10)
        elif(unit == &#34;dm&#34;):
            return (value * 100)
        elif(unit == &#34;m&#34;):
            return (value * 1000)

        raise Exception(unit + &#34; is not a valid unit of length.&#34;)
    else:
        raise KeyError(&#34;\&#34;value\&#34; or \&#34;unit\&#34; missing.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_rad"><code class="name flex">
<span>def <span class="ident">in_rad</span></span>(<span>value:Â float, unit:Â strÂ =Â 'deg') â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an angle to radians.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"rad"</code>, <code>"deg"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_rad</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to rad,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid angular unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_rad(value:float, unit:str=&#34;deg&#34;) -&gt; float:
    &#34;&#34;&#34;Convert an angle to radians.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;rad&#34;`, `&#34;deg&#34;`

    Returns
    -------
    value_in_rad : float
        The value converted to rad,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid angular unit.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;deg&#34;: return (value * math.pi / 180.0)
        if unit == &#34;rad&#34;: return value
    else:
        return None

    raise ValueError(f&#34;Not a valid angular unit: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_rad_json"><code class="name flex">
<span>def <span class="ident">in_rad_json</span></span>(<span>jsonVal:Â dict) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert JSON value/unit pair to radians.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_rad_json(jsonVal:dict) -&gt; float:
    &#34;&#34;&#34; Convert JSON value/unit pair to radians. &#34;&#34;&#34;
    if (&#34;value&#34; in jsonVal) and (&#34;unit&#34; in jsonVal):
        value = jsonVal[&#34;value&#34;]
        unit  = jsonVal[&#34;unit&#34;]

        if(unit == &#34;rad&#34;):
            return value
        elif(unit == &#34;deg&#34;):
            return ((value * math.pi) / 180.0)

        raise Exception(unit + &#34; is not a valid angular unit.&#34;)
    else:
        raise KeyError(&#34;\&#34;value\&#34; or \&#34;unit\&#34; missing.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.in_s"><code class="name flex">
<span>def <span class="ident">in_s</span></span>(<span>value:Â float, unit:Â str) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a time to seconds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value to convert.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The value's current unit.
Options are: <code>"ms"</code>, <code>"s"</code>, <code>"min"</code>, <code>"h"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_s</code></strong> :&ensp;<code>float</code></dt>
<dd>The value converted to seconds,
or 'None' if the original value was <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given <code>unit</code> is not a valid unit of time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_s(value:float, unit:str) -&gt; float:
    &#34;&#34;&#34;Convert a time to seconds.

    Parameters
    ----------
    value : float
        The value to convert.

    unit : str
        The value&#39;s current unit.
        Options are: `&#34;ms&#34;`, `&#34;s&#34;`, `&#34;min&#34;`, `&#34;h&#34;`

    Returns
    -------
    value_in_s : float
        The value converted to seconds,
        or &#39;None&#39; if the original value was `None`.

    Raises
    ------
    ValueError
        If the given `unit` is not a valid unit of time.
    &#34;&#34;&#34;
    if value is not None:
        if unit == &#34;ms&#34;:  return (value * 1.0e-3)
        if unit == &#34;s&#34;:   return value
        if unit == &#34;min&#34;: return (value * 60.0)
        if unit == &#34;h&#34;:   return (value * 3600.0)
    else:
        return None

    raise ValueError(f&#34;Not a valid unit of time: &#39;{unit}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.is_valid_native_unit"><code class="name flex">
<span>def <span class="ident">is_valid_native_unit</span></span>(<span>native_unit:Â str) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if given string is a valid native unit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The string to check if it is a valid native unit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_valid</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the provided string is a valid native unit, <code>False</code> if not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_native_unit(native_unit:str) -&gt; bool:
    &#34;&#34;&#34;Check if given string is a valid native unit.

    Parameters
    ----------
    native_unit : str
        The string to check if it is a valid native unit.

    Returns
    -------
    is_valid : bool
        `True` if the provided string is a valid native unit, `False` if not.
    &#34;&#34;&#34;

    if (native_unit in valid_native_units) or (native_unit in valid_dummy_units):
        return True

    raise Exception(f&#34;CTSimU: Not a valid native unit: &#39;{native_unit}&#39;. Valid options are: {valid_native_units}.&#34;)
    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.is_version_supported"><code class="name flex">
<span>def <span class="ident">is_version_supported</span></span>(<span>supported_version:Â dict, version_to_test:Â dict) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the given version is supported by the toolbox.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>supported_version</code></strong> :&ensp;<code>dict</code></dt>
<dd>The version against which should be tested: a dictionary with the keys
<code>"major"</code> and <code>"minor"</code>. Pass the global variable
<code>ctsimu_supported_scenario_version</code> or <code>ctsimu_supported_metadata_version</code>.</dd>
<dt><strong><code>version_to_test</code></strong> :&ensp;<code>dict</code></dt>
<dd>The version to test if it is supported. Must be a dictionary with
the keys <code>"major"</code> and <code>"minor"</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_supported</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the given version number is supported by the toolbox scenario module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_version_supported(supported_version:dict, version_to_test:dict) -&gt; bool:
    &#34;&#34;&#34;Test if the given version is supported by the toolbox.

    Parameters
    ----------
    supported_version : dict
        The version against which should be tested: a dictionary with the keys
        `&#34;major&#34;` and `&#34;minor&#34;`. Pass the global variable
        `ctsimu_supported_scenario_version` or `ctsimu_supported_metadata_version`.

    version_to_test : dict
        The version to test if it is supported. Must be a dictionary with
        the keys `&#34;major&#34;` and `&#34;minor&#34;`.

    Returns
    -------
    is_supported : bool
        If the given version number is supported by the toolbox scenario module.
    &#34;&#34;&#34;

    if (version_to_test is not None) and (supported_version is not None):
        if supported_version[&#34;major&#34;] &gt; version_to_test[&#34;major&#34;]:
            return True

        if supported_version[&#34;major&#34;] == version_to_test[&#34;major&#34;]:
            if supported_version[&#34;minor&#34;] &gt;= version_to_test[&#34;minor&#34;]:
                return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.join_dir_and_filename"><code class="name flex">
<span>def <span class="ident">join_dir_and_filename</span></span>(<span>directory:Â str, filename:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Joins directory and filename into a meaningful path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory part of the path. Set to <code>None</code> for no
directory.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename part of the path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>full_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Fully joined path.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_dir_and_filename(directory:str, filename:str) -&gt; str:
    &#34;&#34;&#34;Joins directory and filename into a meaningful path.

    Parameters
    ----------
    directory: str
        Directory part of the path. Set to `None` for no
        directory.

    filename : str
        Filename part of the path.

    Returns
    -------
    full_path : str
        Fully joined path.
    &#34;&#34;&#34;

    if directory is not None:
        if directory != &#34;&#34;:
            joined = os.path.join(directory, filename)
            return backslash_to_slash(joined)

    return backslash_to_slash(filename)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.json_convert_to_native_unit"><code class="name flex">
<span>def <span class="ident">json_convert_to_native_unit</span></span>(<span>native_unit:Â str, value_and_unit:Â dict, fallback_json_unit:Â strÂ =Â None) â>Â floatÂ |Â strÂ |Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a value/unit pair from a dictionary into
the requested <code>native_unit</code>.</p>
<p>Works like the function <code><a title="ctsimu.helpers.convert_to_native_unit" href="#ctsimu.helpers.convert_to_native_unit">convert_to_native_unit()</a></code>, but takes
a JSON object <code>value_and_unit</code>, i.e. a dictionary that must contain
a <code>value</code> and an associated <code>unit</code>. Checks which native unit is requested,
and converts the JSON <code>value</code> accordingly.</p>
<p><code>fallback_json_unit</code> is used if the unit is not specified
in the <code>value_and_unit</code> JSON object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>native_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The native unit into which the value will be converted.
Possible values: <code>None</code>, <code>"mm"</code>, <code>"rad"</code>, <code>"deg"</code>, <code>"s"</code>, <code>"mA"</code>,
<code>"kV"</code>, <code>"g/cm^3"</code>, <code>"lp/mm"</code>, <code>"deg/s"</code>, <code>"C"</code>, <code>"bool"</code>, <code>"string"</code>.</dd>
<dt><strong><code>value_and_unit</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary that specifies a <code>"value"</code> and a <code>"unit"</code>,
as imported from a CTSimU JSON parameter object.</dd>
<dt><strong><code>fallback_json_unit</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The fallback unit to be used if the <code>value_and_unit</code> dictionary
does not specify a unit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_in_native_unit</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code></dt>
<dd>Converted value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the unit given in the dictionary is not compatible
with the requested <code>native_unit</code>. For example, the function
cannot convert a length into a time.
Also, if no valid value/unit pair is provided in the given
<code>value_and_unit</code> dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_convert_to_native_unit(native_unit:str, value_and_unit:dict, fallback_json_unit:str=None) -&gt; float | str | bool:
    &#34;&#34;&#34;Convert a value/unit pair from a dictionary into
    the requested `native_unit`.

    Works like the function `convert_to_native_unit`, but takes
    a JSON object `value_and_unit`, i.e. a dictionary that must contain
    a `value` and an associated `unit`. Checks which native unit is requested,
    and converts the JSON `value` accordingly.

    `fallback_json_unit` is used if the unit is not specified
    in the `value_and_unit` JSON object.

    Parameters
    ----------
    native_unit : str
        The native unit into which the value will be converted.
        Possible values: `None`, `&#34;mm&#34;`, `&#34;rad&#34;`, `&#34;deg&#34;`, `&#34;s&#34;`, `&#34;mA&#34;`,
        `&#34;kV&#34;`, `&#34;g/cm^3&#34;`, `&#34;lp/mm&#34;`, `&#34;deg/s&#34;`, `&#34;C&#34;`, `&#34;bool&#34;`, `&#34;string&#34;`.

    value_and_unit : dict
        Dictionary that specifies a `&#34;value&#34;` and a `&#34;unit&#34;`,
        as imported from a CTSimU JSON parameter object.

    fallback_json_unit : str, optional
        The fallback unit to be used if the `value_and_unit` dictionary
        does not specify a unit.

    Returns
    -------
    value_in_native_unit : float or str or bool
        Converted value.

    Raises
    ------
    ValueError
        If the unit given in the dictionary is not compatible
        with the requested `native_unit`. For example, the function
        cannot convert a length into a time.
        Also, if no valid value/unit pair is provided in the given
        `value_and_unit` dictionary.
    &#34;&#34;&#34;

    if native_unit is None:
        # No native unit given. Simply return the value.
        return get_value(value_and_unit, [&#34;value&#34;])
    elif native_unit == &#34;bool&#34;:
        # This is not a value/unit dictionary, but a boolean.
        return from_bool(value_and_unit)
    elif native_unit == &#34;string&#34;:
        if json_exists(value_and_unit, [&#34;value&#34;]):
            return str(get_value(value_and_unit, [&#34;value&#34;]))
        else:
            if isinstance(value_and_unit, str):
                return value_and_unit

        raise TypeError(f&#34;Given value does not seem to be a string: {value_and_unit}&#34;)
    else:
        if json_exists(value_and_unit, [&#34;value&#34;]):
            value = get_value(value_and_unit, [&#34;value&#34;])
            unit = fallback_json_unit
            if json_exists(value_and_unit, [&#34;unit&#34;]):
                # The unit does not necessarily have to exist.
                # For example, in the case of strings it is clear
                # just from the native unit.
                unit = get_value(value_and_unit, [&#34;unit&#34;])

            return convert_to_native_unit(unit, native_unit, value)

    raise ValueError(f&#34;Failed to convert a value to &#39;{native_unit}&#39;: no valid value/unit pair is provided from the JSON object.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.json_exists"><code class="name flex">
<span>def <span class="ident">json_exists</span></span>(<span>dictionary:Â dict, keys:Â list) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the given key sequence can be found in the dictionary tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure).</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>List of keys that identify a location in the dictionary tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exists</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the given key sequence identifies an object or
value in the dictionary, <code>False</code> if nothing can be found
at the given sequence of keys.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dictionary</code> is not a Python <code>dict</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_exists(dictionary:dict, keys:list) -&gt; bool:
    &#34;&#34;&#34;Check if the given key sequence can be found in the dictionary tree.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    exists : bool
        `True` if the given key sequence identifies an object or
        value in the dictionary, `False` if nothing can be found
        at the given sequence of keys.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;

    if not isinstance(dictionary, dict):
        return False

    if len(keys) == 0:
        return True

    current_element = dictionary
    for key in keys:
        if current_element is not None:
            if key in current_element:
                current_element = current_element[key]
            else:
                return False
        else:
            # Current element is &#39;None&#39; but we still
            # need to go down at least another &#39;key&#39;.
            return False

    return True</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.json_exists_and_not_null"><code class="name flex">
<span>def <span class="ident">json_exists_and_not_null</span></span>(<span>dictionary:Â dict, keys:Â list) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the value at the given key sequence
exists and does not correspond to a JSON <code>null</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure).</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>List of keys that identify a location in the dictionary tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exists_and_not_null</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the given key sequence exists and does
not identify a <code>null</code> value, <code>False</code> otherwise.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dictionary</code> is not a Python <code>dict</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_exists_and_not_null(dictionary:dict, keys:list) -&gt; bool:
    &#34;&#34;&#34;Check if the value at the given key sequence
    exists and does not correspond to a JSON `null`.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    exists_and_not_null : bool
        `True` if the given key sequence exists and does
        not identify a `null` value, `False` otherwise.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if json_exists(dictionary, keys):
        if not json_isnull(dictionary, keys):
            return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.json_extract"><code class="name flex">
<span>def <span class="ident">json_extract</span></span>(<span>dictionary:Â dict, keys:Â list) â>Â floatÂ |Â strÂ |Â boolÂ |Â dictÂ |Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Get the JSON sub-object that is located
at a given sequence of <code>keys</code> in the JSON dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure).</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>List of keys that identify a location in the dictionary tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code> or <code>dict</code> or <code>list</code></dt>
<dd>The value, object or array located at the given key sequence,
<code>None</code> if nothing can be found at the given key sequence.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dictionary</code> is not a Python <code>dict</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_extract(dictionary:dict, keys:list) -&gt; float | str | bool | dict | list:
    &#34;&#34;&#34;Get the JSON sub-object that is located
    at a given sequence of `keys` in the JSON dictionary.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    value : float or str or bool or dict or list
        The value, object or array located at the given key sequence,
        `None` if nothing can be found at the given key sequence.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    return get_value(dictionary, keys)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.json_extract_from_possible_keys"><code class="name flex">
<span>def <span class="ident">json_extract_from_possible_keys</span></span>(<span>dictionary:Â dict, key_lists:Â list)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches the JSON object for each key sequence in the given
list of key sequences. The first sequence that exists will be used to
extract and return the corresponding JSON object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure).</dd>
<dt><strong><code>key_lists</code></strong> :&ensp;<code>list</code></dt>
<dd>List of lists of keys that possibly specify a valid
location in the dictionary tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code> or <code>str</code> or <code>bool</code> or <code>dict</code> or <code>list</code></dt>
<dd>The value, object or array located at the first valid key sequence,
<code>None</code> if nothing can be found at any of the given key sequences.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dictionary</code> is not a Python <code>dict</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_extract_from_possible_keys(dictionary:dict, key_lists:list):
    &#34;&#34;&#34;Searches the JSON object for each key sequence in the given
    list of key sequences. The first sequence that exists will be used to
    extract and return the corresponding JSON object.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    key_lists : list
        List of lists of keys that possibly specify a valid
        location in the dictionary tree.

    Returns
    -------
    value : float or str or bool or dict or list
        The value, object or array located at the first valid key sequence,
        `None` if nothing can be found at any of the given key sequences.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    for keys in key_lists:
        if json_exists(dictionary, keys):
            return json_extract(dictionary, keys)

    return None</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.json_from_pkg"><code class="name flex">
<span>def <span class="ident">json_from_pkg</span></span>(<span>filename:Â str) â>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Read a JSON file included in the package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename of the JSON file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary representation of the JSON structure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_from_pkg(filename:str) -&gt; dict:
    &#34;&#34;&#34;Read a JSON file included in the package.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    Returns
    -------
    dictionary : dict
        Dictionary representation of the JSON structure.
    &#34;&#34;&#34;
    json_text = pkgutil.get_data(__name__, filename).decode()
    return json.loads(json_text)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.json_isnull"><code class="name flex">
<span>def <span class="ident">json_isnull</span></span>(<span>dictionary:Â dict, keys:Â list) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the value at the given key sequence corresponds
to a JSON <code>null</code>, or if the value cannot be found at all.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure).</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>List of keys that identify a location in the dictionary tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_null</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the given key sequence identifies a <code>null</code> value
or if the value cannot be found at all. <code>False</code> otherwise.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dictionary</code> is not a Python <code>dict</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_isnull(dictionary:dict, keys:list) -&gt; bool:
    &#34;&#34;&#34;Check if the value at the given key sequence corresponds
    to a JSON `null`, or if the value cannot be found at all.

    Parameters
    ----------
    dictionary : dict
        Dictionary (as from a JSON structure).

    keys : list
        List of keys that identify a location in the dictionary tree.

    Returns
    -------
    is_null : bool
        `True` if the given key sequence identifies a `null` value
        or if the value cannot be found at all. `False` otherwise.

    Raises
    ------
    TypeError
        If `dictionary` is not a Python `dict`.
    &#34;&#34;&#34;
    if not isinstance(dictionary, dict):
        raise TypeError(&#34;json_isnull() expects dict as first argument for the `dictionary`.&#34;)
    if len(keys) == 0:
        return True

    v = get_value(dictionary, keys)
    if v is None:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.list_mean"><code class="name flex">
<span>def <span class="ident">list_mean</span></span>(<span>l:Â list) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Mean value for a list of values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>list</code></dt>
<dd>List of values, e.g. 'float'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code></dt>
<dd>The mean of the value list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_mean(l:list) -&gt; float:
    &#34;&#34;&#34;Mean value for a list of values.

    Parameters
    ----------
    l : list
        List of values, e.g. &#39;float&#39;.

    Returns
    -------
    mean : float
        The mean of the value list.
    &#34;&#34;&#34;
    return sum(l) / len(l)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.list_mean_and_stddev"><code class="name flex">
<span>def <span class="ident">list_mean_and_stddev</span></span>(<span>l:Â list) â>Â tuple[float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Mean and standard deviation of a list of values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>list</code></dt>
<dd>List of values, e.g. 'float'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code></dt>
<dd>The mean of the value list.</dd>
<dt><strong><code>standard_deviation</code></strong> :&ensp;<code>float</code></dt>
<dd>Root mean square deviation (RMSD) of the value list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_mean_and_stddev(l:list) -&gt; tuple[float, float]:
    &#34;&#34;&#34;Mean and standard deviation of a list of values.

    Parameters
    ----------
    l : list
        List of values, e.g. &#39;float&#39;.

    Returns
    -------
    mean : float
        The mean of the value list.

    standard_deviation : float
        Root mean square deviation (RMSD) of the value list.
    &#34;&#34;&#34;
    msqDev = 0
    mean = list_mean(l)
    for v in l:
        msqDev += math.pow(v - mean, 2)

    msqDev /= len(l)

    return mean, math.sqrt(msqDev)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>message:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Print an output message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>Message to be printed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(message:str):
    &#34;&#34;&#34;Print an output message.

    Parameters
    ----------
    message : str
        Message to be printed.
    &#34;&#34;&#34;
    print(message)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.object_value_is_null"><code class="name flex">
<span>def <span class="ident">object_value_is_null</span></span>(<span>json_obj:Â dict) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a CTSimU JSON parameter object represents a
<code>null</code> value, either because its <code>"value"</code> property is
set to a JSON <code>null</code> or because it does not have
a <code>"value"</code> property at all.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>json_obj</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure) to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_null</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the object's <code>"value"</code> corresponds to a JSON <code>null</code>
or if the object does not define a <code>"value"</code>.
<code>False</code> if the object value is something else.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>json_obj</code> is not a dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_value_is_null(json_obj:dict) -&gt; bool:
    &#34;&#34;&#34;Check if a CTSimU JSON parameter object represents a
    `null` value, either because its `&#34;value&#34;` property is
    set to a JSON `null` or because it does not have
    a `&#34;value&#34;` property at all.

    Parameters
    ----------
    json_obj : dict
        Dictionary (as from a JSON structure) to check.

    Returns
    -------
    is_null : bool
        `True` if the object&#39;s `&#34;value&#34;` corresponds to a JSON `null`
        or if the object does not define a `&#34;value&#34;`.
        `False` if the object value is something else.

    Raises
    ------
    TypeError
        If `json_obj` is not a dictionary.
    &#34;&#34;&#34;
    if json_obj is None:
        return True

    if not isinstance(json_obj, dict):
        return False

    if &#34;value&#34; in json_obj:
        return value_is_null(json_obj[&#34;value&#34;])

    return True</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.object_value_is_null_or_zero"><code class="name flex">
<span>def <span class="ident">object_value_is_null_or_zero</span></span>(<span>json_obj:Â dict) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a CTSimU JSON parameter object represents
<code>null</code> value or the numerical value <code>0</code>, either because
its <code>"value"</code> property is set to a JSON <code>null</code> or <code>0</code>,
or because it does not have a <code>"value"</code> property at all.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>json_obj</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (as from a JSON structure) to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_null_or_zero</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the object's <code>"value"</code> corresponds to a JSON <code>null</code>
or if the object does not define a <code>"value"</code>.
<code>False</code> if the object value is something else.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>json_obj</code> is not a dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_value_is_null_or_zero(json_obj:dict) -&gt; bool:
    &#34;&#34;&#34;Check if a CTSimU JSON parameter object represents
    `null` value or the numerical value `0`, either because
    its `&#34;value&#34;` property is set to a JSON `null` or `0`,
    or because it does not have a `&#34;value&#34;` property at all.

    Parameters
    ----------
    json_obj : dict
        Dictionary (as from a JSON structure) to check.

    Returns
    -------
    is_null_or_zero : bool
        `True` if the object&#39;s `&#34;value&#34;` corresponds to a JSON `null`
        or if the object does not define a `&#34;value&#34;`.
        `False` if the object value is something else.

    Raises
    ------
    TypeError
        If `json_obj` is not a dictionary.
    &#34;&#34;&#34;
    if not isinstance(json_obj, dict):
        raise TypeError(&#34;object_value_is_null_or_zero() expects dict for the `json_obj`.&#34;)

    if &#34;value&#34; in json_obj:
        return value_is_null_or_zero(json_obj[&#34;value&#34;])

    return True</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.pkg_scenario"><code class="name flex">
<span>def <span class="ident">pkg_scenario</span></span>(<span>filename:Â str, level:Â strÂ =Â 'root') â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Return path to scenario file included in this package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename of the JSON file.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>From where the file needs to be reached.</p>
<p>Possible values: <code>"root"</code>, <code>"test"</code></p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>scenario_path</code></strong> :&ensp;<code>dict</code></dt>
<dd>Path to the scenario within the package.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pkg_scenario(filename:str, level:str=&#34;root&#34;) -&gt; str:
    &#34;&#34;&#34;Return path to scenario file included in this package.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    level : str
        From where the file needs to be reached.

        Possible values: `&#34;root&#34;`, `&#34;test&#34;`

    Returns
    -------
    scenario_path : dict
        Path to the scenario within the package.
    &#34;&#34;&#34;
    if level == &#34;root&#34;:
        return f&#34;evaluation/scenarios/{filename}&#34;
    elif level == &#34;test&#34;:
        return f&#34;scenarios/{filename}&#34;

    raise Exception(f&#34;pkg_scenario: Invalid level: {level}&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.poly4"><code class="name flex">
<span>def <span class="ident">poly4</span></span>(<span>x, a:Â float, b:Â float, c:Â float, d:Â float, e:Â float) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Fourth order polynomial, used for smoothing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Input value (x axis).</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>e</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Output value (y axis).
<code>y = ax^4 + bx^3 + cx^2 + dx + e</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poly4(x, a:float, b:float, c:float, d:float, e:float) -&gt; float:
    &#34;&#34;&#34; Fourth order polynomial, used for smoothing.

    Parameters
    ----------
    x : float
        Input value (x axis).

    a : float

    b : float

    c : float

    d : float

    e : float

    Returns
    -------
    y : float
        Output value (y axis).
        `y = ax^4 + bx^3 + cx^2 + dx + e`
    &#34;&#34;&#34;
    return a*(x**4) + b*(x**3) + c*(x**2) + d*x + e</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.ratios"><code class="name flex">
<span>def <span class="ident">ratios</span></span>(<span>values:Â list) â>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate ratio to preceding value, needed for step wedge evaluations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ratios(values:list) -&gt; list:
    &#34;&#34;&#34; Calculate ratio to preceding value, needed for step wedge evaluations. &#34;&#34;&#34;
    results = []
    for v in range(1, len(values)):
        results.append(values[v] / values[v-1])

    return results</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.read_csv_file"><code class="name flex">
<span>def <span class="ident">read_csv_file</span></span>(<span>filename:Â str) â>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Read a CSV file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename of the CSV file to read.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code></dt>
<dd>Each item in the returned list contains the values of one column from the CSV file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_csv_file(filename:str) -&gt; dict:
    &#34;&#34;&#34;Read a CSV file.

    Parameters
    ----------
    filename : str
        Filename of the CSV file to read.

    Returns
    -------
    data : list
        Each item in the returned list contains the values of one column from the CSV file.
    &#34;&#34;&#34;

    values = []
    n_columns = 0

    with open(filename, newline=&#39;&#39;) as f:
        try:
            # Detect the CSV dialect: comma or tab-separated?
            dialect = csv.Sniffer().sniff(f.read(1024))
        except:
            dialect = None

        # Return to beginning
        f.seek(0)

        reader = csv.reader(f, dialect)
        for row in reader:
            if row[0].startswith(&#39;#&#39;):
                # ignore commented lines
                continue

            if n_columns == 0:
                # Number of columns apparently not initialized yet.
                n_columns = len(row)
                for i in range(n_columns):
                    # Append an empty list for each column:
                    values.append([])

            for col, entry in enumerate(row):
                values[col].append(entry)

    return values</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.read_json_file"><code class="name flex">
<span>def <span class="ident">read_json_file</span></span>(<span>filename:Â str) â>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Read a JSON file into a Python dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename of the JSON file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary representation of the JSON structure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json_file(filename:str) -&gt; dict:
    &#34;&#34;&#34;Read a JSON file into a Python dictionary.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    Returns
    -------
    dictionary : dict
        Dictionary representation of the JSON structure.
    &#34;&#34;&#34;

    if isinstance(filename, str):
        if os.path.isfile(filename):
            if os.path.exists(filename):
                with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
                    json_dict = json.load(f)
                    f.close()
                    return json_dict
            else:
                raise Exception(f&#34;File not found: &#39;{filename}&#39;&#34;)
        else:
            raise Exception(f&#34;File not found: &#39;{filename}&#39;&#34;)

    raise Exception(f&#34;Cannot read JSON file: {filename}&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.touch_directory"><code class="name flex">
<span>def <span class="ident">touch_directory</span></span>(<span>filename:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create folder if it doesn't exist.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Complete path to a file. Can include filename.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def touch_directory(filename:str):
    &#34;&#34;&#34;Create folder if it doesn&#39;t exist.

    Parameters
    ----------
    filename : str
        Complete path to a file. Can include filename.
    &#34;&#34;&#34;

    folder = os.path.dirname(filename)

    if folder == &#34;&#34; or folder is None:
            folder = &#34;.&#34;

    if not os.path.exists(folder):
        os.makedirs(folder)

    return folder</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.value_is_null"><code class="name flex">
<span>def <span class="ident">value_is_null</span></span>(<span>value) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a specific JSON value is set to <code>null</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Value to check for nullness.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_null</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the value corresponds to a JSON <code>null</code>,
<code>False</code> if it is something else.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def value_is_null(value) -&gt; bool:
    &#34;&#34;&#34;Check if a specific JSON value is set to `null`.

    Parameters
    ----------
    value
        Value to check for nullness.

    Returns
    -------
    is_null : bool
        `True` if the value corresponds to a JSON `null`,
        `False` if it is something else.
    &#34;&#34;&#34;
    if value is None:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.value_is_null_or_zero"><code class="name flex">
<span>def <span class="ident">value_is_null_or_zero</span></span>(<span>value) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a specific value is set to <code>null</code> or <code>0</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Value to check for nullness or zeroness.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_null_or_zero</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the value corresponds to a JSON <code>null</code>
or has the numerical value <code>0</code>, <code>False</code> if it is something else.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def value_is_null_or_zero(value) -&gt; bool:
    &#34;&#34;&#34;Check if a specific value is set to `null` or `0`.

    Parameters
    ----------
    value
        Value to check for nullness or zeroness.

    Returns
    -------
    is_null_or_zero : bool
        `True` if the value corresponds to a JSON `null`
        or has the numerical value `0`, `False` if it is something else.
    &#34;&#34;&#34;
    if value is not None:
        if value != 0:
            return False

    return True</code></pre>
</details>
</dd>
<dt id="ctsimu.helpers.write_json_file"><code class="name flex">
<span>def <span class="ident">write_json_file</span></span>(<span>filename:Â str, dictionary:Â dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a JSON file from a given Python dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename of the JSON file.</dd>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary for the JSON file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_json_file(filename:str, dictionary:dict):
    &#34;&#34;&#34;Write a JSON file from a given Python dictionary.

    Parameters
    ----------
    filename : str
        Filename of the JSON file.

    dictionary : dict
        Dictionary for the JSON file.
    &#34;&#34;&#34;

    folder = touch_directory(filename)
    if os.path.exists(folder):
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            json.dump(dictionary, f, ensure_ascii=False, indent=&#34;\t&#34;)
            f.close()
    else:
        raise Exception(f&#34;Error writing JSON file. Directory does not exist: {folder}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu" href="index.html">ctsimu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctsimu.helpers.abspath_of_referenced_file" href="#ctsimu.helpers.abspath_of_referenced_file">abspath_of_referenced_file</a></code></li>
<li><code><a title="ctsimu.helpers.backslash_to_slash" href="#ctsimu.helpers.backslash_to_slash">backslash_to_slash</a></code></li>
<li><code><a title="ctsimu.helpers.convert" href="#ctsimu.helpers.convert">convert</a></code></li>
<li><code><a title="ctsimu.helpers.convert_SNR_FWHM" href="#ctsimu.helpers.convert_SNR_FWHM">convert_SNR_FWHM</a></code></li>
<li><code><a title="ctsimu.helpers.convert_to_native_unit" href="#ctsimu.helpers.convert_to_native_unit">convert_to_native_unit</a></code></li>
<li><code><a title="ctsimu.helpers.convert_to_preferred_unit" href="#ctsimu.helpers.convert_to_preferred_unit">convert_to_preferred_unit</a></code></li>
<li><code><a title="ctsimu.helpers.counter_format" href="#ctsimu.helpers.counter_format">counter_format</a></code></li>
<li><code><a title="ctsimu.helpers.divide_and_error" href="#ctsimu.helpers.divide_and_error">divide_and_error</a></code></li>
<li><code><a title="ctsimu.helpers.divide_and_gaussian_error" href="#ctsimu.helpers.divide_and_gaussian_error">divide_and_gaussian_error</a></code></li>
<li><code><a title="ctsimu.helpers.from_bool" href="#ctsimu.helpers.from_bool">from_bool</a></code></li>
<li><code><a title="ctsimu.helpers.gaussian" href="#ctsimu.helpers.gaussian">gaussian</a></code></li>
<li><code><a title="ctsimu.helpers.get_value" href="#ctsimu.helpers.get_value">get_value</a></code></li>
<li><code><a title="ctsimu.helpers.get_value_in_native_unit" href="#ctsimu.helpers.get_value_in_native_unit">get_value_in_native_unit</a></code></li>
<li><code><a title="ctsimu.helpers.get_value_or_none" href="#ctsimu.helpers.get_value_or_none">get_value_or_none</a></code></li>
<li><code><a title="ctsimu.helpers.in_celsius" href="#ctsimu.helpers.in_celsius">in_celsius</a></code></li>
<li><code><a title="ctsimu.helpers.in_deg" href="#ctsimu.helpers.in_deg">in_deg</a></code></li>
<li><code><a title="ctsimu.helpers.in_deg_per_s" href="#ctsimu.helpers.in_deg_per_s">in_deg_per_s</a></code></li>
<li><code><a title="ctsimu.helpers.in_fahrenheit" href="#ctsimu.helpers.in_fahrenheit">in_fahrenheit</a></code></li>
<li><code><a title="ctsimu.helpers.in_g_per_cm3" href="#ctsimu.helpers.in_g_per_cm3">in_g_per_cm3</a></code></li>
<li><code><a title="ctsimu.helpers.in_kV" href="#ctsimu.helpers.in_kV">in_kV</a></code></li>
<li><code><a title="ctsimu.helpers.in_kelvin" href="#ctsimu.helpers.in_kelvin">in_kelvin</a></code></li>
<li><code><a title="ctsimu.helpers.in_lp_per_mm" href="#ctsimu.helpers.in_lp_per_mm">in_lp_per_mm</a></code></li>
<li><code><a title="ctsimu.helpers.in_mA" href="#ctsimu.helpers.in_mA">in_mA</a></code></li>
<li><code><a title="ctsimu.helpers.in_mm" href="#ctsimu.helpers.in_mm">in_mm</a></code></li>
<li><code><a title="ctsimu.helpers.in_mm_json" href="#ctsimu.helpers.in_mm_json">in_mm_json</a></code></li>
<li><code><a title="ctsimu.helpers.in_rad" href="#ctsimu.helpers.in_rad">in_rad</a></code></li>
<li><code><a title="ctsimu.helpers.in_rad_json" href="#ctsimu.helpers.in_rad_json">in_rad_json</a></code></li>
<li><code><a title="ctsimu.helpers.in_s" href="#ctsimu.helpers.in_s">in_s</a></code></li>
<li><code><a title="ctsimu.helpers.is_valid_native_unit" href="#ctsimu.helpers.is_valid_native_unit">is_valid_native_unit</a></code></li>
<li><code><a title="ctsimu.helpers.is_version_supported" href="#ctsimu.helpers.is_version_supported">is_version_supported</a></code></li>
<li><code><a title="ctsimu.helpers.join_dir_and_filename" href="#ctsimu.helpers.join_dir_and_filename">join_dir_and_filename</a></code></li>
<li><code><a title="ctsimu.helpers.json_convert_to_native_unit" href="#ctsimu.helpers.json_convert_to_native_unit">json_convert_to_native_unit</a></code></li>
<li><code><a title="ctsimu.helpers.json_exists" href="#ctsimu.helpers.json_exists">json_exists</a></code></li>
<li><code><a title="ctsimu.helpers.json_exists_and_not_null" href="#ctsimu.helpers.json_exists_and_not_null">json_exists_and_not_null</a></code></li>
<li><code><a title="ctsimu.helpers.json_extract" href="#ctsimu.helpers.json_extract">json_extract</a></code></li>
<li><code><a title="ctsimu.helpers.json_extract_from_possible_keys" href="#ctsimu.helpers.json_extract_from_possible_keys">json_extract_from_possible_keys</a></code></li>
<li><code><a title="ctsimu.helpers.json_from_pkg" href="#ctsimu.helpers.json_from_pkg">json_from_pkg</a></code></li>
<li><code><a title="ctsimu.helpers.json_isnull" href="#ctsimu.helpers.json_isnull">json_isnull</a></code></li>
<li><code><a title="ctsimu.helpers.list_mean" href="#ctsimu.helpers.list_mean">list_mean</a></code></li>
<li><code><a title="ctsimu.helpers.list_mean_and_stddev" href="#ctsimu.helpers.list_mean_and_stddev">list_mean_and_stddev</a></code></li>
<li><code><a title="ctsimu.helpers.log" href="#ctsimu.helpers.log">log</a></code></li>
<li><code><a title="ctsimu.helpers.object_value_is_null" href="#ctsimu.helpers.object_value_is_null">object_value_is_null</a></code></li>
<li><code><a title="ctsimu.helpers.object_value_is_null_or_zero" href="#ctsimu.helpers.object_value_is_null_or_zero">object_value_is_null_or_zero</a></code></li>
<li><code><a title="ctsimu.helpers.pkg_scenario" href="#ctsimu.helpers.pkg_scenario">pkg_scenario</a></code></li>
<li><code><a title="ctsimu.helpers.poly4" href="#ctsimu.helpers.poly4">poly4</a></code></li>
<li><code><a title="ctsimu.helpers.ratios" href="#ctsimu.helpers.ratios">ratios</a></code></li>
<li><code><a title="ctsimu.helpers.read_csv_file" href="#ctsimu.helpers.read_csv_file">read_csv_file</a></code></li>
<li><code><a title="ctsimu.helpers.read_json_file" href="#ctsimu.helpers.read_json_file">read_json_file</a></code></li>
<li><code><a title="ctsimu.helpers.touch_directory" href="#ctsimu.helpers.touch_directory">touch_directory</a></code></li>
<li><code><a title="ctsimu.helpers.value_is_null" href="#ctsimu.helpers.value_is_null">value_is_null</a></code></li>
<li><code><a title="ctsimu.helpers.value_is_null_or_zero" href="#ctsimu.helpers.value_is_null_or_zero">value_is_null_or_zero</a></code></li>
<li><code><a title="ctsimu.helpers.write_json_file" href="#ctsimu.helpers.write_json_file">write_json_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>