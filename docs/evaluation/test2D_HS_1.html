<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctsimu.evaluation.test2D_HS_1 API documentation</title>
<meta name="description" content="Test 2D-HS-1: Object and detector placement â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.evaluation.test2D_HS_1</code></h1>
</header>
<section id="section-intro">
<h1 id="test-2d-hs-1-object-and-detector-placement">Test 2D-HS-1: Object and detector placement</h1>
<p>This test checks for correct positioning of sample and detector. An STL file that represents a thin foil with ten holes must be placed according to the correct bounding box position and orientation as described in the scenario. The STL file's native coordinates do not match the coordinates where it has to be placed. Additionally, the correct detector position and orientation must be set up in order to get the correct projection image. The evaluation procedure will calculate translation vectors, rotation angles and scale factors relative to the ideal pixel coordinates of the holes.</p>
<pre><code class="language-python">from ctsimu.toolbox import Toolbox
Toolbox(&quot;2D-HS-1&quot;, &quot;2D-HS-1_metadata.json&quot;)
</code></pre>
<p>The test tries to find the ten holes in the projection image. If it cannot identify exactly ten holes, the test will be aborted completely. The centers of the holes are determined by fitting a circle to each hole boundary (<a href="https://doi.org/10.1007/BF00939613">Coope et al., 1993</a>) after application of an edge filter. Hole number 0 has a bigger diameter than the other holes and serves as a symmetry breaker and reference anchor from which all other holes are identified.</p>
<p><img alt="Hole sheet standard" src="../pictures/hole_sheet.png" title="Hole sheet standard with holes labeled"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-
&#34;&#34;&#34;# Test 2D-HS-1: Object and detector placement

.. include:: ./test2D_HS_1.md
&#34;&#34;&#34;

from ..test import *
from ..geometry import Vector, in_mm_json
from ..helpers import *
from ..scenario import Scenario

class ballCollector():
    &#34;&#34;&#34; We will add the circles to the ball collector. It decides which circle is which. &#34;&#34;&#34;

    def __init__(self):
        # Prepare a list to contain the circle vectors:
        self.n_circles_expected = 10
        self.circlesUnordered = []
        self.circlesInOrder = [None] * self.n_circles_expected
        #self.distancesToCorners = [None] * self.n_circles_expected

        self.greatCircleIndex = 0
        self.maxCircleRadius = 0


    def addCircle(self, coords, R):  # tuple: coords = (cx, cy)
        if self.maxCircleRadius &lt; R:  # Remember the biggest circle
            self.maxCircleRadius = R
            self.greatCircleIndex = len(self.circlesUnordered)

        circle2Dpos = Vector(coords[0], coords[1], 0)
        self.circlesUnordered.append(circle2Dpos)

    def sortCircles(self):
        if len(self.circlesUnordered) == self.n_circles_expected:
            # Find all connection vectors from the great hole to the other holes:
            greatCircle = self.circlesUnordered.pop(self.greatCircleIndex)
            self.circlesInOrder[0] = greatCircle

            # circlesUnordered now only contains the 9 small circles, and must remain so (not to mess up indices).

            ## Create list of connection vectors:
            connectionVectors = []
            for i in range(len(self.circlesUnordered)):
                connectionVectors.append(Vector.connection(greatCircle, self.circlesUnordered[i]))

            ## Find vector pair with smallest and biggest angle:
            small = None
            hole9idx = None

            smallestAngle = math.pi
            smallestDistance = connectionVectors[0].length()

            for i in range(len(connectionVectors)):
                # Hole 9 is the hole with the smallest distance to the great hole:
                if smallestDistance &gt; connectionVectors[i].length():
                    hole9idx = i
                    smallestDistance = connectionVectors[i].length()

                # Find angles between connection vectors of each circle pair:
                for j in range(i+1, len(connectionVectors)):
                    angle = connectionVectors[i].angle(connectionVectors[j])
                    if smallestAngle &gt; abs(angle):
                        smallestAngle = abs(angle)
                        small = (i, j)


            # Hole 1 is the hole from the connection vector pair with the smallest angle
            # that is also the farthest away from the great circle.
            # Hole 5 is the one that is closer to the great circle.
            connection0to1 = None

            if self.circlesUnordered[small[0]].distance(greatCircle) &gt; self.circlesUnordered[small[1]].distance(greatCircle):
                self.circlesInOrder[1] = self.circlesUnordered[small[0]]
                self.circlesInOrder[5] = self.circlesUnordered[small[1]]
            else:
                self.circlesInOrder[5] = self.circlesUnordered[small[0]]
                self.circlesInOrder[1] = self.circlesUnordered[small[1]]

            # Hole 9 is one of the circles with the smallest distance to the big hole:
            self.circlesInOrder[9] = self.circlesUnordered[hole9idx]

            # Diagonal from hole 9 to hole 1:
            diagonal91 = Vector.connection(self.circlesInOrder[9], self.circlesInOrder[1])

            remainingCirclesAndDiagonalAngles = []
            for i in range(len(connectionVectors)):
                if not ((i in small) or (i == hole9idx)):
                    angle = diagonal91.angle(connectionVectors[i])
                    remainingCirclesAndDiagonalAngles.append((i, angle))

            # Sort list by angles:
            remainingCirclesAndDiagonalAngles = sorted(remainingCirclesAndDiagonalAngles, key=lambda x: x[1])
            i = 0
            for circle in remainingCirclesAndDiagonalAngles:
                # The sign of the cross product&#39;s z component tells us
                # which side of the diagonal the circle lies on:
                idx = circle[0]
                angle = circle[1]

                cross = diagonal91.cross(connectionVectors[idx])

                if i &lt; 2: # First vector pair with smallest angle towards diagonal
                    if cross.z() &gt; 0:  # To the &#34;right&#34;
                        self.circlesInOrder[2] = self.circlesUnordered[idx]
                    else:  # To the &#34;left&#34;
                        self.circlesInOrder[4] = self.circlesUnordered[idx]
                elif i &lt; 4: # Second vector pair with medium-sized angle towards diagonal
                    if cross.z() &gt; 0:  # To the &#34;right&#34;
                        self.circlesInOrder[3] = self.circlesUnordered[idx]
                    else:  # To the &#34;left&#34;
                        self.circlesInOrder[7] = self.circlesUnordered[idx]
                elif i &lt; 6: # Second vector pair with medium-sized angle towards diagonal
                    if cross.z() &gt; 0:  # To the &#34;right&#34;
                        self.circlesInOrder[6] = self.circlesUnordered[idx]
                    else:  # To the &#34;left&#34;
                        self.circlesInOrder[8] = self.circlesUnordered[idx]

                i += 1
        else:
            raise Exception(&#34;A total of {} holes is needed. Found: {} holes.&#34;.format(self.n_circles_expected, len(self.circlesUnordered)))


    def nCircles(self):
        return len(self.circlesInOrder)

    def nCirclesFound(self):
        n = 0
        for c in self.circlesInOrder:
            if c is not None:
                n = n+1

        return n

    def getCircle(self, i):
        if i &gt;= 0 and i &lt; self.nCircles():
            return self.circlesInOrder[i]
        else:
            raise Exception(&#34;Circle with index {i} does not exist.&#34;.format(i=i))

    def scale(self, factor, aroundHole):
        for i in range(len(self.circlesInOrder)):
            if i != aroundHole:
                connection = Vector.connection(self.circlesInOrder[aroundHole], self.circlesInOrder[i])
                connection.scale(factor)
                connection.add(self.circlesInOrder[aroundHole])
                self.circlesInOrder[i] = connection

    def rotate(self, angle, aroundHole):
        axis = Vector(0, 0, -1)
        for i in range(len(self.circlesInOrder)):
            if i != aroundHole:
                connection = Vector.connection(self.circlesInOrder[aroundHole], self.circlesInOrder[i])
                connection.rotate(axis, angle)
                connection.add(self.circlesInOrder[aroundHole])
                self.circlesInOrder[i] = connection

    def distance(self, a, b):
        if (a is not None) and (b is not None):
            if (a &gt;= 0) and (a &lt; self.nCircles()):
                if (b &gt;= 0) and (b &lt; self.nCircles()):
                    if self.circlesInOrder[a] is not None:
                        if self.circlesInOrder[b] is not None:
                            return self.circlesInOrder[a].distance(self.circlesInOrder[b])
                        else:
                            raise Exception(&#34;Error: Circle {} not found. Cannot continue with test.&#34;.format(b))
                    else:
                        raise Exception(&#34;Error: Circle {} not found. Cannot continue with test.&#34;.format(a))

        raise Exception(&#34;Requested Distance: Index for circle a ({a}) or b ({b}) out of bounds.&#34;.format(a=a, b=b))

    def printResults(self):
        text = &#34;&#34;
        for i in range(self.nCircles()):
            text += &#34;Hole {:02d}: &#34;.format(i)
            if self.circlesInOrder[i] is None:
                text += &#34;Not found!&#34;
            else:
                text += &#34;   cx = {:.3f} px,\tcy = {:.3f} px&#34;.format(self.circlesInOrder[i].x(), self.circlesInOrder[i].y())

            text += &#34;\n&#34;

        return text

    def printResults_tabular(self):
        text = &#34;Hole\tcenter_x [px]\tcenter_y [px]\n&#34;
        for i in range(self.nCircles()):
            text += &#34;{:02d}\t&#34;.format(i)
            if self.circlesInOrder[i] is None:
                text += &#34;Not found!&#34;
            else:
                text += &#34;{:.3f}\t{:.3f}&#34;.format(self.circlesInOrder[i].x(), self.circlesInOrder[i].y())

            text += &#34;\n&#34;

        return text


class Test2D_HS_1(generalTest):
    &#34;&#34;&#34; CTSimU test 2D-HS-1: object positioning. &#34;&#34;&#34;

    def __init__(self, resultFileDirectory=&#34;.&#34;, name=None, rawOutput=False):

        generalTest.__init__(
            self,
            testName=&#34;2D-HS-1&#34;,
            name=name,
            nExpectedRuns=1,
            resultFileDirectory=resultFileDirectory,
            rawOutput=rawOutput)

        self.success = False

        # Future circle collector (class ballCollector):
        self.circleCollection = None

        self.nominalCircles = ballCollector()

        # Detector parameters:
        self.pixelSizeX = None
        self.pixelSizeY = None
        self.detectorWidthPx  = None
        self.detectorHeightPx = None
        self.detectorWidthMM  = None
        self.detectorHeightMM = None

        # Results of the evaluation:
        self.meanTranslationVector = None
        self.inPlaneRotation = None
        self.scaleFactor = None

    def worldToDetector(self, yWorld, zWorld):
        # mirror x and y:
        x = -yWorld
        y = -zWorld

        x += self.detectorWidthMM/2
        y += self.detectorHeightMM/2

        x /= self.pixelSizeX
        y /= self.pixelSizeY

        return (x, y)

    def prepare(self):
        &#34;&#34;&#34; Preparations before the test will be run with the images from the pipeline. &#34;&#34;&#34;
        self.jsonScenarioFile = &#34;2D-HS-1_2021-03-24v02r00dp.json&#34;

        if self.jsonScenarioFile is not None:
            scenario = Scenario(json_dict=json_from_pkg(pkg_scenario(self.jsonScenarioFile)))

            self.pixelSizeX = scenario.detector.pixel_pitch.u.get()
            self.pixelSizeY = scenario.detector.pixel_pitch.v.get()
            self.detectorWidthPx  = scenario.detector.columns.get()
            self.detectorHeightPx = scenario.detector.rows.get()

            self.detectorWidthMM  = self.detectorWidthPx  * self.pixelSizeX
            self.detectorHeightMM = self.detectorHeightPx * self.pixelSizeY

            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-160, zWorld=-140), R=133)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld= 205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld= 205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld= 205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld=   0), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld=   0), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld=   0), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld=-205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld=-205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld=-205), R=66)

            self.nominalCircles.sortCircles()

            self.prepared = True

    def run(self, image):
        self.prepare()
        self.currentRun += 1

        self.success = False

        log(&#34;Running test {}&#34;.format(self.testName))
        n_circles_expected = 10

        holeImg = copy.deepcopy(image)

        # Thresholding splits image into black and white, to remove artifacts:
        thresh = holeImg.max() - 0.1*(holeImg.max()-holeImg.min())
        log(&#34;Binarization threshold: {:.3f}&#34;.format(thresh))
        holeImg.applyThreshold(threshold=thresh, lower=0, upper=60000)

        if self.rawOutput:
            holeImg.saveRAW(&#34;{dir}/{name}_01_binarized.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;, addInfo=True)
        else: # TIFF
            holeImg.save(&#34;{dir}/{name}_01_binarized.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;)

        # Clean big patch(es) that are not circles:
        nPatches, nCleaned, nRemaining, patchGeometry = holeImg.cleanPatches(min_patch_area=(5*5), max_patch_area=None, remove_border_patches=True)

        if self.rawOutput:
            holeImg.saveRAW(&#34;{dir}/{name}_02_cleaned.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;, addInfo=True)
        else: # TIFF
            holeImg.save(&#34;{dir}/{name}_02_cleaned.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;)

        log(&#34;Looking for {} circles, found {} structures.&#34;.format(n_circles_expected, nRemaining))

        if(nRemaining != n_circles_expected):
            log(&#34;Error: Cannot continue with test.&#34;)
        else:
            log(&#34;That&#39;s good. Trying to fit circles to the following structures at center coordinates (cx, cy).&#34;)

            # Find edges:
            holeImg.filter_edges(mode=&#34;sobel&#34;)
            thresh = (holeImg.max()+holeImg.min())/2.0
            log(&#34;Binarization threshold: {:.3f}&#34;.format(thresh))
            holeImg.applyThreshold(threshold=thresh, lower=0, upper=60000)
            if self.rawOutput:
                holeImg.saveRAW(&#34;{dir}/{name}_03_edges.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;, addInfo=True)
            else:
                holeImg.save(&#34;{dir}/{name}_03_edges.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;)

            i=0
            greatRadius = 0
            greatCircle = -1
            circles = []

            log(&#34;Running the circle fits...&#34;)

            for cx, cy, width, height in patchGeometry:
                #log(&#34;  Structure {:02d}: cx={}, cy={}, width={}, height={}&#34;.format(i, cx, cy, width, height))
                circleImg = copy.deepcopy(holeImg)

                x = int(cx)
                y = int(cy)
                w = int(1.8*width)
                h = int(1.8*height)

                # Crop circle:
                left, right, top, bottom = circleImg.cropROIaroundPoint(x, y, w, h)
                if self.rawOutput:
                    circleImg.saveRAW(f&#34;{self.resultFileDirectory}/{self.name}_04_circle_{i:02d}.raw&#34;, dataType=&#34;uint16&#34;, addInfo=True)
                else:
                    circleImg.save(f&#34;{self.resultFileDirectory}/{self.name}_04_circle_{i:02d}.tif&#34;, dataType=&#34;uint16&#34;)



                # Fit circle:
                #log(&#34;    Fitting circle...&#34;)
                centerX, centerY, radius, meanDifference, minDifference, maxDifference = circleImg.fitCircle()

                print(f&#34;Left: {left}    Top: {top}  x: {centerX}    y: {centerY}&#34;)

                centerX += left
                centerY += top

                log(f&#34;    Found: cx={centerX:.4f}, cy={centerY:.4f}, R={radius:.4f}&#34;)

                # Find the biggest circle. This will be the symmetry breaker.
                if radius &gt; greatRadius:
                    greatRadius = radius
                    greatCircle = i

                circles.append((centerX, centerY, radius))

                i += 1

            if greatCircle &gt;= 0:
                greatX, greatY, greatR = circles[greatCircle]
                self.circleCollection = ballCollector()

                for i in range(len(circles)):
                    cx, cy, R = circles[i]
                    self.circleCollection.addCircle((cx, cy), R)

                self.success = True

            else:
                log(&#34;No circles found. Cannot continue with test.&#34;)

        return image

    def followUp(self):
        if self.success:
            log(&#34;Writing evaluation results...&#34;)
            self.circleCollection.sortCircles()

            summaryText = &#34;# Evaluation of test {}\n&#34;.format(self.testName)

            summaryText += &#34;#\n&#34;
            summaryText += &#34;# Hole Coordinates:\n&#34;

            log(&#34;Hole locations found:&#34;)
            log(self.circleCollection.printResults())

            summaryText += self.circleCollection.printResults_tabular()

            if self.circleCollection.nCirclesFound() &lt; self.circleCollection.n_circles_expected:
                log(&#34;Only {n} of the expected {N} holes were correctly identified. Test cannot continue.&#34;.format(n=self.circleCollection.nCirclesFound(), N=self.circleCollection.n_circles_expected))
                return
            else:
                log(&#34;Okay, all circles identified.&#34;)

            # Mean Scale:
            scaleAgainstCircle = 5
            summaryText += &#34;\n&#34;
            summaryText += &#34;Scale factor,\n&#34;
            summaryText += &#34;from hole distances: scale = 1 - dist(ideal)/dist(real)\n&#34;
            summaryText += &#34;===============================================================\n&#34;
            scaleDevList = []
            for i in range(self.nominalCircles.nCircles()-1):
                for j in range(i+1, self.nominalCircles.nCircles()):
                    length_ideal = self.nominalCircles.getCircle(i).distance(self.nominalCircles.getCircle(j))
                    length_real = self.circleCollection.getCircle(i).distance(self.circleCollection.getCircle(j))
                    scale = 1.0 - length_ideal / length_real

                    summaryText += &#34;Scale dev. ({i}, {j}): {space}{scale:.7f}\n&#34;.format(i=i, j=j, space=&#34; &#34;*(scale&gt;=0), scale=scale)

                    scaleDevList.append(scale)

            meanScaleDeviation, stdDevScaleDeviation = list_mean_and_stddev(scaleDevList)

            summaryText += &#34;---------------------------------------------------------------\n&#34;
            summaryText += &#34;Mean scale deviation:   {space}{value:.7f}\n&#34;.format(space=&#34; &#34;*(meanScaleDeviation&gt;=0), value=meanScaleDeviation)
            summaryText += &#34;StdDev scale deviation: {space}{value:.7f}\n&#34;.format(space=&#34; &#34;*(stdDevScaleDeviation&gt;=0), value=stdDevScaleDeviation)

            ## Scale the real circle collection back by that scale factor...
            self.circleCollection.scale(factor=1-meanScaleDeviation, aroundHole=scaleAgainstCircle)


            # Mean rotation angle:
            rotateAroundCircle = 5
            summaryText += &#34;\n&#34;
            summaryText += &#34;In-plane rotation\n&#34;
            summaryText += &#34;===============================================================\n&#34;
            meanAngle = 0
            stdDevAngle = 0
            angleList = []

            for i in range(self.nominalCircles.nCircles()-1):
                for j in range(i+1, self.nominalCircles.nCircles()):
                    connection_ideal = Vector.connection(self.nominalCircles.getCircle(i), self.nominalCircles.getCircle(j))
                    connection_real  = Vector.connection(self.circleCollection.getCircle(i), self.circleCollection.getCircle(j))
                    angle = connection_ideal.angle(connection_real)

                    # angular orientation:
                    cross = connection_ideal.cross(connection_real)
                    if (cross.z() &lt; 0) and (abs(angle) &lt; (math.pi - 0.0000001)):
                        angle = -abs(angle)
                    else:
                        angle = abs(angle)

                    summaryText += &#34;Tilt angle ({i}, {j}): {space}{angle:.7f} rad = {space}{angleDeg:.7f} deg\n&#34;.format(i=i, j=j, space=&#34; &#34;*(angle&gt;=0), angle=angle, angleDeg=(angle*180.0/math.pi))

                    angleList.append(angle)

            meanAngle, stdDevAngle = list_mean_and_stddev(angleList)

            summaryText += &#34;---------------------------------------------------------------\n&#34;
            summaryText += &#34;Mean rotation angle:   {space}{value:.7f} rad = {space}{angleDeg:.7f} deg\n&#34;.format(space=&#34; &#34;*(meanAngle&gt;=0), value=meanAngle, angleDeg=(meanAngle*180.0/math.pi))
            summaryText += &#34;StdDev rotation angle: {space}{value:.7f} rad = {space}{angleDeg:.7f} deg\n&#34;.format(space=&#34; &#34;*(stdDevAngle&gt;=0), value=stdDevAngle, angleDeg=(stdDevAngle*180.0/math.pi))
            summaryText += &#34;\n&#34;

            ## Rotate the real circle collection back by that angle...
            self.circleCollection.rotate(meanAngle, rotateAroundCircle)


            # Mean translation vector:
            summaryText += &#34;Translation analysis\n&#34;
            summaryText += &#34;===============================================================\n&#34;
            translationsX = []
            translationsY = []

            for i in range(self.nominalCircles.nCircles()):
                translation = Vector.connection(self.nominalCircles.getCircle(i), self.circleCollection.getCircle(i))
                summaryText += &#34;Translation hole {i:02d} [px]: {vec}\n&#34;.format(i=i, vec=translation)

                translationsX.append(translation.x())
                translationsY.append(translation.y())

            meanTranslationX, stdDevTranslationX = list_mean_and_stddev(translationsX)
            meanTranslationY, stdDevTranslationY = list_mean_and_stddev(translationsY)

            meanTranslation = Vector(meanTranslationX, meanTranslationY, 0)
            stdDevTranslation = Vector(stdDevTranslationX, stdDevTranslationY, 0)

            summaryText += &#34;---------------------------------------------------------------\n&#34;
            summaryText += &#34;Mean translation vector [px]: {}\n&#34;.format(meanTranslation)
            summaryText += &#34;StdDev translation [px]:      {}&#34;.format(stdDevTranslation)


            # Special Summary Line:
            #summaryText += &#34;\n\n&#34;
            #summaryText += &#34;{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}&#34;.format(meanScaleDeviation, stdDevScaleDeviation, meanAngle, stdDevAngle, meanTranslation.x(), stdDevTranslation.x(), meanTranslation.y(), stdDevTranslation.y()


            resultFileName = &#34;{}/{}_summary.txt&#34;.format(self.resultFileDirectory, self.name)
            with open(resultFileName, &#39;w&#39;) as resultFile:
                resultFile.write(summaryText)
                resultFile.close()

            self.plotResults()


    def plotResults(self):
        return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.evaluation.test2D_HS_1.Test2D_HS_1"><code class="flex name class">
<span>class <span class="ident">Test2D_HS_1</span></span>
<span>(</span><span>resultFileDirectory='.', name=None, rawOutput=False)</span>
</code></dt>
<dd>
<div class="desc"><p>CTSimU test 2D-HS-1: object positioning.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Test2D_HS_1(generalTest):
    &#34;&#34;&#34; CTSimU test 2D-HS-1: object positioning. &#34;&#34;&#34;

    def __init__(self, resultFileDirectory=&#34;.&#34;, name=None, rawOutput=False):

        generalTest.__init__(
            self,
            testName=&#34;2D-HS-1&#34;,
            name=name,
            nExpectedRuns=1,
            resultFileDirectory=resultFileDirectory,
            rawOutput=rawOutput)

        self.success = False

        # Future circle collector (class ballCollector):
        self.circleCollection = None

        self.nominalCircles = ballCollector()

        # Detector parameters:
        self.pixelSizeX = None
        self.pixelSizeY = None
        self.detectorWidthPx  = None
        self.detectorHeightPx = None
        self.detectorWidthMM  = None
        self.detectorHeightMM = None

        # Results of the evaluation:
        self.meanTranslationVector = None
        self.inPlaneRotation = None
        self.scaleFactor = None

    def worldToDetector(self, yWorld, zWorld):
        # mirror x and y:
        x = -yWorld
        y = -zWorld

        x += self.detectorWidthMM/2
        y += self.detectorHeightMM/2

        x /= self.pixelSizeX
        y /= self.pixelSizeY

        return (x, y)

    def prepare(self):
        &#34;&#34;&#34; Preparations before the test will be run with the images from the pipeline. &#34;&#34;&#34;
        self.jsonScenarioFile = &#34;2D-HS-1_2021-03-24v02r00dp.json&#34;

        if self.jsonScenarioFile is not None:
            scenario = Scenario(json_dict=json_from_pkg(pkg_scenario(self.jsonScenarioFile)))

            self.pixelSizeX = scenario.detector.pixel_pitch.u.get()
            self.pixelSizeY = scenario.detector.pixel_pitch.v.get()
            self.detectorWidthPx  = scenario.detector.columns.get()
            self.detectorHeightPx = scenario.detector.rows.get()

            self.detectorWidthMM  = self.detectorWidthPx  * self.pixelSizeX
            self.detectorHeightMM = self.detectorHeightPx * self.pixelSizeY

            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-160, zWorld=-140), R=133)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld= 205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld= 205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld= 205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld=   0), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld=   0), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld=   0), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld=-205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld=-205), R=66)
            self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld=-205), R=66)

            self.nominalCircles.sortCircles()

            self.prepared = True

    def run(self, image):
        self.prepare()
        self.currentRun += 1

        self.success = False

        log(&#34;Running test {}&#34;.format(self.testName))
        n_circles_expected = 10

        holeImg = copy.deepcopy(image)

        # Thresholding splits image into black and white, to remove artifacts:
        thresh = holeImg.max() - 0.1*(holeImg.max()-holeImg.min())
        log(&#34;Binarization threshold: {:.3f}&#34;.format(thresh))
        holeImg.applyThreshold(threshold=thresh, lower=0, upper=60000)

        if self.rawOutput:
            holeImg.saveRAW(&#34;{dir}/{name}_01_binarized.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;, addInfo=True)
        else: # TIFF
            holeImg.save(&#34;{dir}/{name}_01_binarized.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;)

        # Clean big patch(es) that are not circles:
        nPatches, nCleaned, nRemaining, patchGeometry = holeImg.cleanPatches(min_patch_area=(5*5), max_patch_area=None, remove_border_patches=True)

        if self.rawOutput:
            holeImg.saveRAW(&#34;{dir}/{name}_02_cleaned.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;, addInfo=True)
        else: # TIFF
            holeImg.save(&#34;{dir}/{name}_02_cleaned.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;)

        log(&#34;Looking for {} circles, found {} structures.&#34;.format(n_circles_expected, nRemaining))

        if(nRemaining != n_circles_expected):
            log(&#34;Error: Cannot continue with test.&#34;)
        else:
            log(&#34;That&#39;s good. Trying to fit circles to the following structures at center coordinates (cx, cy).&#34;)

            # Find edges:
            holeImg.filter_edges(mode=&#34;sobel&#34;)
            thresh = (holeImg.max()+holeImg.min())/2.0
            log(&#34;Binarization threshold: {:.3f}&#34;.format(thresh))
            holeImg.applyThreshold(threshold=thresh, lower=0, upper=60000)
            if self.rawOutput:
                holeImg.saveRAW(&#34;{dir}/{name}_03_edges.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;, addInfo=True)
            else:
                holeImg.save(&#34;{dir}/{name}_03_edges.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;uint16&#34;)

            i=0
            greatRadius = 0
            greatCircle = -1
            circles = []

            log(&#34;Running the circle fits...&#34;)

            for cx, cy, width, height in patchGeometry:
                #log(&#34;  Structure {:02d}: cx={}, cy={}, width={}, height={}&#34;.format(i, cx, cy, width, height))
                circleImg = copy.deepcopy(holeImg)

                x = int(cx)
                y = int(cy)
                w = int(1.8*width)
                h = int(1.8*height)

                # Crop circle:
                left, right, top, bottom = circleImg.cropROIaroundPoint(x, y, w, h)
                if self.rawOutput:
                    circleImg.saveRAW(f&#34;{self.resultFileDirectory}/{self.name}_04_circle_{i:02d}.raw&#34;, dataType=&#34;uint16&#34;, addInfo=True)
                else:
                    circleImg.save(f&#34;{self.resultFileDirectory}/{self.name}_04_circle_{i:02d}.tif&#34;, dataType=&#34;uint16&#34;)



                # Fit circle:
                #log(&#34;    Fitting circle...&#34;)
                centerX, centerY, radius, meanDifference, minDifference, maxDifference = circleImg.fitCircle()

                print(f&#34;Left: {left}    Top: {top}  x: {centerX}    y: {centerY}&#34;)

                centerX += left
                centerY += top

                log(f&#34;    Found: cx={centerX:.4f}, cy={centerY:.4f}, R={radius:.4f}&#34;)

                # Find the biggest circle. This will be the symmetry breaker.
                if radius &gt; greatRadius:
                    greatRadius = radius
                    greatCircle = i

                circles.append((centerX, centerY, radius))

                i += 1

            if greatCircle &gt;= 0:
                greatX, greatY, greatR = circles[greatCircle]
                self.circleCollection = ballCollector()

                for i in range(len(circles)):
                    cx, cy, R = circles[i]
                    self.circleCollection.addCircle((cx, cy), R)

                self.success = True

            else:
                log(&#34;No circles found. Cannot continue with test.&#34;)

        return image

    def followUp(self):
        if self.success:
            log(&#34;Writing evaluation results...&#34;)
            self.circleCollection.sortCircles()

            summaryText = &#34;# Evaluation of test {}\n&#34;.format(self.testName)

            summaryText += &#34;#\n&#34;
            summaryText += &#34;# Hole Coordinates:\n&#34;

            log(&#34;Hole locations found:&#34;)
            log(self.circleCollection.printResults())

            summaryText += self.circleCollection.printResults_tabular()

            if self.circleCollection.nCirclesFound() &lt; self.circleCollection.n_circles_expected:
                log(&#34;Only {n} of the expected {N} holes were correctly identified. Test cannot continue.&#34;.format(n=self.circleCollection.nCirclesFound(), N=self.circleCollection.n_circles_expected))
                return
            else:
                log(&#34;Okay, all circles identified.&#34;)

            # Mean Scale:
            scaleAgainstCircle = 5
            summaryText += &#34;\n&#34;
            summaryText += &#34;Scale factor,\n&#34;
            summaryText += &#34;from hole distances: scale = 1 - dist(ideal)/dist(real)\n&#34;
            summaryText += &#34;===============================================================\n&#34;
            scaleDevList = []
            for i in range(self.nominalCircles.nCircles()-1):
                for j in range(i+1, self.nominalCircles.nCircles()):
                    length_ideal = self.nominalCircles.getCircle(i).distance(self.nominalCircles.getCircle(j))
                    length_real = self.circleCollection.getCircle(i).distance(self.circleCollection.getCircle(j))
                    scale = 1.0 - length_ideal / length_real

                    summaryText += &#34;Scale dev. ({i}, {j}): {space}{scale:.7f}\n&#34;.format(i=i, j=j, space=&#34; &#34;*(scale&gt;=0), scale=scale)

                    scaleDevList.append(scale)

            meanScaleDeviation, stdDevScaleDeviation = list_mean_and_stddev(scaleDevList)

            summaryText += &#34;---------------------------------------------------------------\n&#34;
            summaryText += &#34;Mean scale deviation:   {space}{value:.7f}\n&#34;.format(space=&#34; &#34;*(meanScaleDeviation&gt;=0), value=meanScaleDeviation)
            summaryText += &#34;StdDev scale deviation: {space}{value:.7f}\n&#34;.format(space=&#34; &#34;*(stdDevScaleDeviation&gt;=0), value=stdDevScaleDeviation)

            ## Scale the real circle collection back by that scale factor...
            self.circleCollection.scale(factor=1-meanScaleDeviation, aroundHole=scaleAgainstCircle)


            # Mean rotation angle:
            rotateAroundCircle = 5
            summaryText += &#34;\n&#34;
            summaryText += &#34;In-plane rotation\n&#34;
            summaryText += &#34;===============================================================\n&#34;
            meanAngle = 0
            stdDevAngle = 0
            angleList = []

            for i in range(self.nominalCircles.nCircles()-1):
                for j in range(i+1, self.nominalCircles.nCircles()):
                    connection_ideal = Vector.connection(self.nominalCircles.getCircle(i), self.nominalCircles.getCircle(j))
                    connection_real  = Vector.connection(self.circleCollection.getCircle(i), self.circleCollection.getCircle(j))
                    angle = connection_ideal.angle(connection_real)

                    # angular orientation:
                    cross = connection_ideal.cross(connection_real)
                    if (cross.z() &lt; 0) and (abs(angle) &lt; (math.pi - 0.0000001)):
                        angle = -abs(angle)
                    else:
                        angle = abs(angle)

                    summaryText += &#34;Tilt angle ({i}, {j}): {space}{angle:.7f} rad = {space}{angleDeg:.7f} deg\n&#34;.format(i=i, j=j, space=&#34; &#34;*(angle&gt;=0), angle=angle, angleDeg=(angle*180.0/math.pi))

                    angleList.append(angle)

            meanAngle, stdDevAngle = list_mean_and_stddev(angleList)

            summaryText += &#34;---------------------------------------------------------------\n&#34;
            summaryText += &#34;Mean rotation angle:   {space}{value:.7f} rad = {space}{angleDeg:.7f} deg\n&#34;.format(space=&#34; &#34;*(meanAngle&gt;=0), value=meanAngle, angleDeg=(meanAngle*180.0/math.pi))
            summaryText += &#34;StdDev rotation angle: {space}{value:.7f} rad = {space}{angleDeg:.7f} deg\n&#34;.format(space=&#34; &#34;*(stdDevAngle&gt;=0), value=stdDevAngle, angleDeg=(stdDevAngle*180.0/math.pi))
            summaryText += &#34;\n&#34;

            ## Rotate the real circle collection back by that angle...
            self.circleCollection.rotate(meanAngle, rotateAroundCircle)


            # Mean translation vector:
            summaryText += &#34;Translation analysis\n&#34;
            summaryText += &#34;===============================================================\n&#34;
            translationsX = []
            translationsY = []

            for i in range(self.nominalCircles.nCircles()):
                translation = Vector.connection(self.nominalCircles.getCircle(i), self.circleCollection.getCircle(i))
                summaryText += &#34;Translation hole {i:02d} [px]: {vec}\n&#34;.format(i=i, vec=translation)

                translationsX.append(translation.x())
                translationsY.append(translation.y())

            meanTranslationX, stdDevTranslationX = list_mean_and_stddev(translationsX)
            meanTranslationY, stdDevTranslationY = list_mean_and_stddev(translationsY)

            meanTranslation = Vector(meanTranslationX, meanTranslationY, 0)
            stdDevTranslation = Vector(stdDevTranslationX, stdDevTranslationY, 0)

            summaryText += &#34;---------------------------------------------------------------\n&#34;
            summaryText += &#34;Mean translation vector [px]: {}\n&#34;.format(meanTranslation)
            summaryText += &#34;StdDev translation [px]:      {}&#34;.format(stdDevTranslation)


            # Special Summary Line:
            #summaryText += &#34;\n\n&#34;
            #summaryText += &#34;{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}&#34;.format(meanScaleDeviation, stdDevScaleDeviation, meanAngle, stdDevAngle, meanTranslation.x(), stdDevTranslation.x(), meanTranslation.y(), stdDevTranslation.y()


            resultFileName = &#34;{}/{}_summary.txt&#34;.format(self.resultFileDirectory, self.name)
            with open(resultFileName, &#39;w&#39;) as resultFile:
                resultFile.write(summaryText)
                resultFile.close()

            self.plotResults()


    def plotResults(self):
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctsimu.test.generalTest" href="../test.html#ctsimu.test.generalTest">generalTest</a></li>
<li><a title="ctsimu.processing.step.Step" href="../processing/step.html#ctsimu.processing.step.Step">Step</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.evaluation.test2D_HS_1.Test2D_HS_1.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparations before the test will be run with the images from the pipeline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34; Preparations before the test will be run with the images from the pipeline. &#34;&#34;&#34;
    self.jsonScenarioFile = &#34;2D-HS-1_2021-03-24v02r00dp.json&#34;

    if self.jsonScenarioFile is not None:
        scenario = Scenario(json_dict=json_from_pkg(pkg_scenario(self.jsonScenarioFile)))

        self.pixelSizeX = scenario.detector.pixel_pitch.u.get()
        self.pixelSizeY = scenario.detector.pixel_pitch.v.get()
        self.detectorWidthPx  = scenario.detector.columns.get()
        self.detectorHeightPx = scenario.detector.rows.get()

        self.detectorWidthMM  = self.detectorWidthPx  * self.pixelSizeX
        self.detectorHeightMM = self.detectorHeightPx * self.pixelSizeY

        self.nominalCircles.addCircle(self.worldToDetector(yWorld=-160, zWorld=-140), R=133)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld= 205), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld= 205), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld= 205), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld=   0), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld=   0), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld=   0), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld= 205, zWorld=-205), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld=   0, zWorld=-205), R=66)
        self.nominalCircles.addCircle(self.worldToDetector(yWorld=-205, zWorld=-205), R=66)

        self.nominalCircles.sortCircles()

        self.prepared = True</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.Test2D_HS_1.worldToDetector"><code class="name flex">
<span>def <span class="ident">worldToDetector</span></span>(<span>self, yWorld, zWorld)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worldToDetector(self, yWorld, zWorld):
    # mirror x and y:
    x = -yWorld
    y = -zWorld

    x += self.detectorWidthMM/2
    y += self.detectorHeightMM/2

    x /= self.pixelSizeX
    y /= self.pixelSizeY

    return (x, y)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctsimu.test.generalTest" href="../test.html#ctsimu.test.generalTest">generalTest</a></b></code>:
<ul class="hlist">
<li><code><a title="ctsimu.test.generalTest.followUp" href="../processing/step.html#ctsimu.processing.step.Step.followUp">followUp</a></code></li>
<li><code><a title="ctsimu.test.generalTest.plotResults" href="../test.html#ctsimu.test.generalTest.plotResults">plotResults</a></code></li>
<li><code><a title="ctsimu.test.generalTest.run" href="../processing/step.html#ctsimu.processing.step.Step.run">run</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setName" href="../test.html#ctsimu.test.generalTest.setName">setName</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setRawOutput" href="../test.html#ctsimu.test.generalTest.setRawOutput">setRawOutput</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setResultFileDirectory" href="../test.html#ctsimu.test.generalTest.setResultFileDirectory">setResultFileDirectory</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector"><code class="flex name class">
<span>class <span class="ident">ballCollector</span></span>
</code></dt>
<dd>
<div class="desc"><p>We will add the circles to the ball collector. It decides which circle is which.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ballCollector():
    &#34;&#34;&#34; We will add the circles to the ball collector. It decides which circle is which. &#34;&#34;&#34;

    def __init__(self):
        # Prepare a list to contain the circle vectors:
        self.n_circles_expected = 10
        self.circlesUnordered = []
        self.circlesInOrder = [None] * self.n_circles_expected
        #self.distancesToCorners = [None] * self.n_circles_expected

        self.greatCircleIndex = 0
        self.maxCircleRadius = 0


    def addCircle(self, coords, R):  # tuple: coords = (cx, cy)
        if self.maxCircleRadius &lt; R:  # Remember the biggest circle
            self.maxCircleRadius = R
            self.greatCircleIndex = len(self.circlesUnordered)

        circle2Dpos = Vector(coords[0], coords[1], 0)
        self.circlesUnordered.append(circle2Dpos)

    def sortCircles(self):
        if len(self.circlesUnordered) == self.n_circles_expected:
            # Find all connection vectors from the great hole to the other holes:
            greatCircle = self.circlesUnordered.pop(self.greatCircleIndex)
            self.circlesInOrder[0] = greatCircle

            # circlesUnordered now only contains the 9 small circles, and must remain so (not to mess up indices).

            ## Create list of connection vectors:
            connectionVectors = []
            for i in range(len(self.circlesUnordered)):
                connectionVectors.append(Vector.connection(greatCircle, self.circlesUnordered[i]))

            ## Find vector pair with smallest and biggest angle:
            small = None
            hole9idx = None

            smallestAngle = math.pi
            smallestDistance = connectionVectors[0].length()

            for i in range(len(connectionVectors)):
                # Hole 9 is the hole with the smallest distance to the great hole:
                if smallestDistance &gt; connectionVectors[i].length():
                    hole9idx = i
                    smallestDistance = connectionVectors[i].length()

                # Find angles between connection vectors of each circle pair:
                for j in range(i+1, len(connectionVectors)):
                    angle = connectionVectors[i].angle(connectionVectors[j])
                    if smallestAngle &gt; abs(angle):
                        smallestAngle = abs(angle)
                        small = (i, j)


            # Hole 1 is the hole from the connection vector pair with the smallest angle
            # that is also the farthest away from the great circle.
            # Hole 5 is the one that is closer to the great circle.
            connection0to1 = None

            if self.circlesUnordered[small[0]].distance(greatCircle) &gt; self.circlesUnordered[small[1]].distance(greatCircle):
                self.circlesInOrder[1] = self.circlesUnordered[small[0]]
                self.circlesInOrder[5] = self.circlesUnordered[small[1]]
            else:
                self.circlesInOrder[5] = self.circlesUnordered[small[0]]
                self.circlesInOrder[1] = self.circlesUnordered[small[1]]

            # Hole 9 is one of the circles with the smallest distance to the big hole:
            self.circlesInOrder[9] = self.circlesUnordered[hole9idx]

            # Diagonal from hole 9 to hole 1:
            diagonal91 = Vector.connection(self.circlesInOrder[9], self.circlesInOrder[1])

            remainingCirclesAndDiagonalAngles = []
            for i in range(len(connectionVectors)):
                if not ((i in small) or (i == hole9idx)):
                    angle = diagonal91.angle(connectionVectors[i])
                    remainingCirclesAndDiagonalAngles.append((i, angle))

            # Sort list by angles:
            remainingCirclesAndDiagonalAngles = sorted(remainingCirclesAndDiagonalAngles, key=lambda x: x[1])
            i = 0
            for circle in remainingCirclesAndDiagonalAngles:
                # The sign of the cross product&#39;s z component tells us
                # which side of the diagonal the circle lies on:
                idx = circle[0]
                angle = circle[1]

                cross = diagonal91.cross(connectionVectors[idx])

                if i &lt; 2: # First vector pair with smallest angle towards diagonal
                    if cross.z() &gt; 0:  # To the &#34;right&#34;
                        self.circlesInOrder[2] = self.circlesUnordered[idx]
                    else:  # To the &#34;left&#34;
                        self.circlesInOrder[4] = self.circlesUnordered[idx]
                elif i &lt; 4: # Second vector pair with medium-sized angle towards diagonal
                    if cross.z() &gt; 0:  # To the &#34;right&#34;
                        self.circlesInOrder[3] = self.circlesUnordered[idx]
                    else:  # To the &#34;left&#34;
                        self.circlesInOrder[7] = self.circlesUnordered[idx]
                elif i &lt; 6: # Second vector pair with medium-sized angle towards diagonal
                    if cross.z() &gt; 0:  # To the &#34;right&#34;
                        self.circlesInOrder[6] = self.circlesUnordered[idx]
                    else:  # To the &#34;left&#34;
                        self.circlesInOrder[8] = self.circlesUnordered[idx]

                i += 1
        else:
            raise Exception(&#34;A total of {} holes is needed. Found: {} holes.&#34;.format(self.n_circles_expected, len(self.circlesUnordered)))


    def nCircles(self):
        return len(self.circlesInOrder)

    def nCirclesFound(self):
        n = 0
        for c in self.circlesInOrder:
            if c is not None:
                n = n+1

        return n

    def getCircle(self, i):
        if i &gt;= 0 and i &lt; self.nCircles():
            return self.circlesInOrder[i]
        else:
            raise Exception(&#34;Circle with index {i} does not exist.&#34;.format(i=i))

    def scale(self, factor, aroundHole):
        for i in range(len(self.circlesInOrder)):
            if i != aroundHole:
                connection = Vector.connection(self.circlesInOrder[aroundHole], self.circlesInOrder[i])
                connection.scale(factor)
                connection.add(self.circlesInOrder[aroundHole])
                self.circlesInOrder[i] = connection

    def rotate(self, angle, aroundHole):
        axis = Vector(0, 0, -1)
        for i in range(len(self.circlesInOrder)):
            if i != aroundHole:
                connection = Vector.connection(self.circlesInOrder[aroundHole], self.circlesInOrder[i])
                connection.rotate(axis, angle)
                connection.add(self.circlesInOrder[aroundHole])
                self.circlesInOrder[i] = connection

    def distance(self, a, b):
        if (a is not None) and (b is not None):
            if (a &gt;= 0) and (a &lt; self.nCircles()):
                if (b &gt;= 0) and (b &lt; self.nCircles()):
                    if self.circlesInOrder[a] is not None:
                        if self.circlesInOrder[b] is not None:
                            return self.circlesInOrder[a].distance(self.circlesInOrder[b])
                        else:
                            raise Exception(&#34;Error: Circle {} not found. Cannot continue with test.&#34;.format(b))
                    else:
                        raise Exception(&#34;Error: Circle {} not found. Cannot continue with test.&#34;.format(a))

        raise Exception(&#34;Requested Distance: Index for circle a ({a}) or b ({b}) out of bounds.&#34;.format(a=a, b=b))

    def printResults(self):
        text = &#34;&#34;
        for i in range(self.nCircles()):
            text += &#34;Hole {:02d}: &#34;.format(i)
            if self.circlesInOrder[i] is None:
                text += &#34;Not found!&#34;
            else:
                text += &#34;   cx = {:.3f} px,\tcy = {:.3f} px&#34;.format(self.circlesInOrder[i].x(), self.circlesInOrder[i].y())

            text += &#34;\n&#34;

        return text

    def printResults_tabular(self):
        text = &#34;Hole\tcenter_x [px]\tcenter_y [px]\n&#34;
        for i in range(self.nCircles()):
            text += &#34;{:02d}\t&#34;.format(i)
            if self.circlesInOrder[i] is None:
                text += &#34;Not found!&#34;
            else:
                text += &#34;{:.3f}\t{:.3f}&#34;.format(self.circlesInOrder[i].x(), self.circlesInOrder[i].y())

            text += &#34;\n&#34;

        return text</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.addCircle"><code class="name flex">
<span>def <span class="ident">addCircle</span></span>(<span>self, coords, R)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addCircle(self, coords, R):  # tuple: coords = (cx, cy)
    if self.maxCircleRadius &lt; R:  # Remember the biggest circle
        self.maxCircleRadius = R
        self.greatCircleIndex = len(self.circlesUnordered)

    circle2Dpos = Vector(coords[0], coords[1], 0)
    self.circlesUnordered.append(circle2Dpos)</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, a, b):
    if (a is not None) and (b is not None):
        if (a &gt;= 0) and (a &lt; self.nCircles()):
            if (b &gt;= 0) and (b &lt; self.nCircles()):
                if self.circlesInOrder[a] is not None:
                    if self.circlesInOrder[b] is not None:
                        return self.circlesInOrder[a].distance(self.circlesInOrder[b])
                    else:
                        raise Exception(&#34;Error: Circle {} not found. Cannot continue with test.&#34;.format(b))
                else:
                    raise Exception(&#34;Error: Circle {} not found. Cannot continue with test.&#34;.format(a))

    raise Exception(&#34;Requested Distance: Index for circle a ({a}) or b ({b}) out of bounds.&#34;.format(a=a, b=b))</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.getCircle"><code class="name flex">
<span>def <span class="ident">getCircle</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCircle(self, i):
    if i &gt;= 0 and i &lt; self.nCircles():
        return self.circlesInOrder[i]
    else:
        raise Exception(&#34;Circle with index {i} does not exist.&#34;.format(i=i))</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.nCircles"><code class="name flex">
<span>def <span class="ident">nCircles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nCircles(self):
    return len(self.circlesInOrder)</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.nCirclesFound"><code class="name flex">
<span>def <span class="ident">nCirclesFound</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nCirclesFound(self):
    n = 0
    for c in self.circlesInOrder:
        if c is not None:
            n = n+1

    return n</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.printResults"><code class="name flex">
<span>def <span class="ident">printResults</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printResults(self):
    text = &#34;&#34;
    for i in range(self.nCircles()):
        text += &#34;Hole {:02d}: &#34;.format(i)
        if self.circlesInOrder[i] is None:
            text += &#34;Not found!&#34;
        else:
            text += &#34;   cx = {:.3f} px,\tcy = {:.3f} px&#34;.format(self.circlesInOrder[i].x(), self.circlesInOrder[i].y())

        text += &#34;\n&#34;

    return text</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.printResults_tabular"><code class="name flex">
<span>def <span class="ident">printResults_tabular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printResults_tabular(self):
    text = &#34;Hole\tcenter_x [px]\tcenter_y [px]\n&#34;
    for i in range(self.nCircles()):
        text += &#34;{:02d}\t&#34;.format(i)
        if self.circlesInOrder[i] is None:
            text += &#34;Not found!&#34;
        else:
            text += &#34;{:.3f}\t{:.3f}&#34;.format(self.circlesInOrder[i].x(), self.circlesInOrder[i].y())

        text += &#34;\n&#34;

    return text</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle, aroundHole)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, angle, aroundHole):
    axis = Vector(0, 0, -1)
    for i in range(len(self.circlesInOrder)):
        if i != aroundHole:
            connection = Vector.connection(self.circlesInOrder[aroundHole], self.circlesInOrder[i])
            connection.rotate(axis, angle)
            connection.add(self.circlesInOrder[aroundHole])
            self.circlesInOrder[i] = connection</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, factor, aroundHole)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, factor, aroundHole):
    for i in range(len(self.circlesInOrder)):
        if i != aroundHole:
            connection = Vector.connection(self.circlesInOrder[aroundHole], self.circlesInOrder[i])
            connection.scale(factor)
            connection.add(self.circlesInOrder[aroundHole])
            self.circlesInOrder[i] = connection</code></pre>
</details>
</dd>
<dt id="ctsimu.evaluation.test2D_HS_1.ballCollector.sortCircles"><code class="name flex">
<span>def <span class="ident">sortCircles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortCircles(self):
    if len(self.circlesUnordered) == self.n_circles_expected:
        # Find all connection vectors from the great hole to the other holes:
        greatCircle = self.circlesUnordered.pop(self.greatCircleIndex)
        self.circlesInOrder[0] = greatCircle

        # circlesUnordered now only contains the 9 small circles, and must remain so (not to mess up indices).

        ## Create list of connection vectors:
        connectionVectors = []
        for i in range(len(self.circlesUnordered)):
            connectionVectors.append(Vector.connection(greatCircle, self.circlesUnordered[i]))

        ## Find vector pair with smallest and biggest angle:
        small = None
        hole9idx = None

        smallestAngle = math.pi
        smallestDistance = connectionVectors[0].length()

        for i in range(len(connectionVectors)):
            # Hole 9 is the hole with the smallest distance to the great hole:
            if smallestDistance &gt; connectionVectors[i].length():
                hole9idx = i
                smallestDistance = connectionVectors[i].length()

            # Find angles between connection vectors of each circle pair:
            for j in range(i+1, len(connectionVectors)):
                angle = connectionVectors[i].angle(connectionVectors[j])
                if smallestAngle &gt; abs(angle):
                    smallestAngle = abs(angle)
                    small = (i, j)


        # Hole 1 is the hole from the connection vector pair with the smallest angle
        # that is also the farthest away from the great circle.
        # Hole 5 is the one that is closer to the great circle.
        connection0to1 = None

        if self.circlesUnordered[small[0]].distance(greatCircle) &gt; self.circlesUnordered[small[1]].distance(greatCircle):
            self.circlesInOrder[1] = self.circlesUnordered[small[0]]
            self.circlesInOrder[5] = self.circlesUnordered[small[1]]
        else:
            self.circlesInOrder[5] = self.circlesUnordered[small[0]]
            self.circlesInOrder[1] = self.circlesUnordered[small[1]]

        # Hole 9 is one of the circles with the smallest distance to the big hole:
        self.circlesInOrder[9] = self.circlesUnordered[hole9idx]

        # Diagonal from hole 9 to hole 1:
        diagonal91 = Vector.connection(self.circlesInOrder[9], self.circlesInOrder[1])

        remainingCirclesAndDiagonalAngles = []
        for i in range(len(connectionVectors)):
            if not ((i in small) or (i == hole9idx)):
                angle = diagonal91.angle(connectionVectors[i])
                remainingCirclesAndDiagonalAngles.append((i, angle))

        # Sort list by angles:
        remainingCirclesAndDiagonalAngles = sorted(remainingCirclesAndDiagonalAngles, key=lambda x: x[1])
        i = 0
        for circle in remainingCirclesAndDiagonalAngles:
            # The sign of the cross product&#39;s z component tells us
            # which side of the diagonal the circle lies on:
            idx = circle[0]
            angle = circle[1]

            cross = diagonal91.cross(connectionVectors[idx])

            if i &lt; 2: # First vector pair with smallest angle towards diagonal
                if cross.z() &gt; 0:  # To the &#34;right&#34;
                    self.circlesInOrder[2] = self.circlesUnordered[idx]
                else:  # To the &#34;left&#34;
                    self.circlesInOrder[4] = self.circlesUnordered[idx]
            elif i &lt; 4: # Second vector pair with medium-sized angle towards diagonal
                if cross.z() &gt; 0:  # To the &#34;right&#34;
                    self.circlesInOrder[3] = self.circlesUnordered[idx]
                else:  # To the &#34;left&#34;
                    self.circlesInOrder[7] = self.circlesUnordered[idx]
            elif i &lt; 6: # Second vector pair with medium-sized angle towards diagonal
                if cross.z() &gt; 0:  # To the &#34;right&#34;
                    self.circlesInOrder[6] = self.circlesUnordered[idx]
                else:  # To the &#34;left&#34;
                    self.circlesInOrder[8] = self.circlesUnordered[idx]

            i += 1
    else:
        raise Exception(&#34;A total of {} holes is needed. Found: {} holes.&#34;.format(self.n_circles_expected, len(self.circlesUnordered)))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#test-2d-hs-1-object-and-detector-placement">Test 2D-HS-1: Object and detector placement</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu.evaluation" href="index.html">ctsimu.evaluation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.evaluation.test2D_HS_1.Test2D_HS_1" href="#ctsimu.evaluation.test2D_HS_1.Test2D_HS_1">Test2D_HS_1</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.evaluation.test2D_HS_1.Test2D_HS_1.prepare" href="#ctsimu.evaluation.test2D_HS_1.Test2D_HS_1.prepare">prepare</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.Test2D_HS_1.worldToDetector" href="#ctsimu.evaluation.test2D_HS_1.Test2D_HS_1.worldToDetector">worldToDetector</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector" href="#ctsimu.evaluation.test2D_HS_1.ballCollector">ballCollector</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.addCircle" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.addCircle">addCircle</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.distance" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.distance">distance</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.getCircle" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.getCircle">getCircle</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.nCircles" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.nCircles">nCircles</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.nCirclesFound" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.nCirclesFound">nCirclesFound</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.printResults" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.printResults">printResults</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.printResults_tabular" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.printResults_tabular">printResults_tabular</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.rotate" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.scale" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.scale">scale</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_HS_1.ballCollector.sortCircles" href="#ctsimu.evaluation.test2D_HS_1.ballCollector.sortCircles">sortCircles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>