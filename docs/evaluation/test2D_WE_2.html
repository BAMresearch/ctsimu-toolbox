<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>ctsimu.evaluation.test2D_WE_2 API documentation</title>
<meta name="description" content="Test 2D-WE-2: Effect of partial pixel coverage â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.evaluation.test2D_WE_2</code></h1>
</header>
<section id="section-intro">
<h1 id="test-2d-we-2-effect-of-partial-pixel-coverage">Test 2D-WE-2: Effect of partial pixel coverage</h1>
<p>If a detector pixel is partly covered by an ideal absorber, its gray value should (approximately) scale inversely proportionally with the area fraction that is covered. This effect is tested here using a very thin (0.01 mm) edge that is made of a high-density material. Its upper right corner is placed at the center of the detector's central pixel, and then tilted around this point by 3&deg;, as illustrated in the figure below.</p>
<p>To run the evaluation for this test, simply pass its identifier and the name of your metadata file (for projection and flat field) to the toolbox:</p>
<pre><code class="language-python">from ctsimu.toolbox import Toolbox
Toolbox(&quot;2D-WE-2&quot;, &quot;2D-WE-2_metadata.json&quot;)
</code></pre>
<p><img alt="Partial pixel coverage" src="../pictures/edge.png" title="A thin edge partly covers pixels on the detector."></p>
<p>To calculate the ideal projection image of an ideal edge, we use the spherical trigonometry approach (see internal toolbox documentation: "How it works under the hood") to obtain an analytical value for each pixel's intensity. For pixels which are fully exposed or fully covered, this is straightforward. Pixels that are partly covered must be separated into an exposed region and a covered region. To treat the covered regions, we regard each pixel as a square polygon in the detector plane. Each of these polygons is then clipped using the shadow of the edge as a clipping polygon. By employing the <a href="https://doi.org/10.1145/360767.360802">Sutherland-Hodgman polygon clipping</a> algorithm we obtain a clipped polygon for which we can calculate the solid angle in the same way as we do for a full pixel. The edges of these clipped polygons are illustrated by dotted red lines in the figure above.</p>
<p>The intensity of a pixel is therefore proportional to the solid angle of the uncovered area of the full pixel polygon:</p>
<p><span><span class="MathJax_Preview"> I(\text{pixel}) \sim \Omega(\text{full pixel}) - \Omega(\text{clipped pixel}). </span><script type="math/tex; mode=display"> I(\text{pixel}) \sim \Omega(\text{full pixel}) - \Omega(\text{clipped pixel}). </script></span></p>
<p>The toolbox regards any pixel with a gray value above zero and below 60000 as <em>partly covered</em>. For the analytical image, it identifies the set <em>A</em> of partly covered pixels, and for the provided projection image to be evaluated, it identifies a set <em>M</em> of partly covered pixels.</p>
<p>The following results are then calculated.</p>
<ul>
<li>A difference image, showing the gray value difference <span><span class="MathJax_Preview">\Delta = \text{GV}_\text{measured}-\text{GV}_\text{analytical}</span><script type="math/tex">\Delta = \text{GV}_\text{measured}-\text{GV}_\text{analytical}</script></span> for each pixel.</li>
<li>The number of partly covered pixels in the analytical image, <span><span class="MathJax_Preview">\left|A\right|=1053</span><script type="math/tex">\left|A\right|=1053</script></span>, and in the projection image to be evaluated, <span><span class="MathJax_Preview">\left|M\right|</span><script type="math/tex">\left|M\right|</script></span>.</li>
<li>The number of pixels that are partly covered in both images: <span><span class="MathJax_Preview">\left|A \cap M\right|</span><script type="math/tex">\left|A \cap M\right|</script></span>, i.e., the number of pixels in the intersection of both sets. This number should match <span><span class="MathJax_Preview">\left|M\right|</span><script type="math/tex">\left|M\right|</script></span> if the edge is positioned correctly. If <span><span class="MathJax_Preview">\left|M\right|</span><script type="math/tex">\left|M\right|</script></span> is higher, this means that partly covered pixels have been identified in the image to be evaluated which should be either fully exposed or fully covered.</li>
<li>The ratio <em>r</em> of the number of pixels that are covered in both vs. the number of pixels covered in the analytical image:
<span><span class="MathJax_Preview">
r = \frac{\left|A \cap M\right|}{\left|A\right|}
</span><script type="math/tex; mode=display">
r = \frac{\left|A \cap M\right|}{\left|A\right|}
</script></span>
Ideally, this ratio is 1 (i.e., 100%). However, it only makes a statement about the extent to which <em>M</em> covers the ideal set <em>A</em>, and does not take into account any pixels that might be incorrectly partly covered outside of the region of analytically partly-covered pixels.</li>
<li>The root mean square difference between the analytical and the measured image for all pixels in the analytically ideal set <em>A</em>, i.e., for all pixels that are partly covered in the analytical edge image:
<span><span class="MathJax_Preview">
\text{RMSD} = \sqrt{\frac{1}{\left|A\right|} \sum_{p \in A} \left[ I_\text{measured}(p) - I_\text{analytical}(p) \right]^2 }.
</span><script type="math/tex; mode=display">
\text{RMSD} = \sqrt{\frac{1}{\left|A\right|} \sum_{p \in A} \left[ I_\text{measured}(p) - I_\text{analytical}(p) \right]^2 }.
</script></span></li>
<li>A list of the coordinates of <em>partly covered</em> pixels in the analytical edge image (i.e., all pixels from set <span><span class="MathJax_Preview">\left|A\right|</span><script type="math/tex">\left|A\right|</script></span>, their gray value in the analytical and in the measured image, and their respective difference.</li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.evaluation.test2D_WE_2.Test2D_WE_2"><code class="flex name class">
<span>class <span class="ident">Test2D_WE_2</span></span>
<span>(</span><span>resultFileDirectory='.', name=None, rawOutput=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Test2D_WE_2(generalTest):
    &#34;&#34;&#34; CTSimU test 2D-WE-2: Effect of partial pixel coverage. &#34;&#34;&#34;

    def __init__(self, resultFileDirectory=&#34;.&#34;, name=None, rawOutput=False):

        generalTest.__init__(
            self,
            testName=&#34;2D-WE-2&#34;,
            name=name,
            nExpectedRuns=1,
            resultFileDirectory=resultFileDirectory,
            rawOutput=rawOutput)
        
        self.geometry = None
        self.analyticalIntensityProfileImage = None  # analytical flat field
        self.analyticalEdgeImage             = None  # stores the analytically computed edge image
        self.analyticalEdgeImageFF           = None  # stores the analytically computed edge image, flat-field corrected

        self.differenceImage                 = None  # difference between analytical edge image and provided image

        self.numberOfPartlyCoveredPixels_analytical = 0
        self.numberOfPartlyCoveredPixels_measured   = 0
        self.matchingPixels                         = 0  # number of partly covered pixels with matching positions
        self.partlyCovered_rmsd                     = 0  # RMSD of pixels in difference image that are partly covered in analytical image

        # Prepare the clipping rectangle for the analytical
        # calculation of the ideal edge image. In pixel coordinates.
        A = Vector(   0,    0, 0)
        B = Vector(   0,  300, 0)
        C = Vector(-300,  300, 0)
        D = Vector(-300,    0, 0)

        edgeAngle = 3 * (math.pi/180.0)  # 3 deg edge rotation

        #A.rotate_2D_xy(edgeAngle)
        B.rotate_2D_xy(edgeAngle)
        C.rotate_2D_xy(edgeAngle)
        D.rotate_2D_xy(edgeAngle)

        self.clippingRectangle = Polygon(A, B, C, D)


    def prepare(self):
        &#34;&#34;&#34; Preparations before the test will be run with the images from the pipeline. &#34;&#34;&#34;
        if not isinstance(self.pipe, Pipeline):
            self.prepared = False
            raise Exception(&#34;Step must be part of a processing pipeline before it can prepare. Current pipeline: {}&#34;.format(self.pipe))

        if not self.prepared:
            self.jsonScenarioFile = &#34;2D-WE-2_2021-10-13v02r03dp.json&#34;

            # Calculate the analytical image of an edge covering the image:
            if(self.jsonScenarioFile is not None):
                scenario = Scenario(json_dict=json_from_pkg(pkg_scenario(self.jsonScenarioFile)))

                self.geometry = scenario.current_geometry()
                self.geometry.update()
                
                self.analyticalIntensityProfileImage, self.analyticalEdgeImage = self.geometry.create_detector_flat_field_sphere(self.clippingRectangle)
                self.analyticalEdgeImageFF = copy.deepcopy(self.analyticalEdgeImage)
                self.analyticalEdgeImageFF.applyFlatfield(ref=self.analyticalIntensityProfileImage, rescaleFactor=60000.0)

                # Raise analytical images to maximum grey value of 60000 before saving them.
                # This rescaling does not affect the previous FF correction.
                self.analyticalIntensityProfileImage.renormalize(newMin=0.0, newMax=60000.0, currentMin=0.0, currentMax=1.0)
                self.analyticalEdgeImage.renormalize(newMin=0.0, newMax=60000.0, currentMin=0.0, currentMax=1.0)


                # Write analytical images:
                if self.rawOutput:
                    self.analyticalIntensityProfileImage.saveRAW(&#34;{dir}/{name}_analytical_flat.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;, addInfo=True)
                    self.analyticalEdgeImage.saveRAW(&#34;{dir}/{name}_analytical_edge.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;, addInfo=True)
                    self.analyticalEdgeImageFF.saveRAW(&#34;{dir}/{name}_analytical_edge_corrected.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;, addInfo=True)
                else: # TIFF
                    self.analyticalIntensityProfileImage.save(&#34;{dir}/{name}_analytical_flat.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;)
                    self.analyticalEdgeImage.save(&#34;{dir}/{name}_analytical_edge.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;)
                    self.analyticalEdgeImageFF.save(&#34;{dir}/{name}_analytical_edge_corrected.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;)

                self.numberOfPartlyCoveredPixels_analytical = numpy.count_nonzero((self.analyticalEdgeImageFF.px &gt; 0) &amp; (self.analyticalEdgeImageFF.px &lt; 60000))

                print(&#34;Number of partly covered pixels in analytical image: {}&#34;.format(self.numberOfPartlyCoveredPixels_analytical))

                self.prepared = True
            else:
                raise Exception(&#34;Test 2D-WE-2: Please provide a JSON scenario description.&#34;)


    def run(self, image):
        self.prepare()
        self.currentRun += 1

        self.numberOfPartlyCoveredPixels_measured = numpy.count_nonzero((image.px &gt; 0) &amp; (image.px &lt; 60000))

        print(&#34;Number of partly covered pixels in measured image:   {}&#34;.format(self.numberOfPartlyCoveredPixels_measured))

        # Match in covered pixels:
        self.matchingPixels = numpy.count_nonzero((self.analyticalEdgeImageFF.px &gt; 0) &amp; (self.analyticalEdgeImageFF.px &lt; 60000) &amp; (image.px &gt; 0) &amp; (image.px &lt; 60000))

        print(&#34;Number of pixels partly covered in both images:      {}&#34;.format(self.matchingPixels))

        self.matchRatio = self.matchingPixels / self.numberOfPartlyCoveredPixels_analytical

        print(&#34;Ratio (covered in both)/(covered in analytical):     {:.2f}%&#34;.format(100.0*self.matchRatio))


        self.differenceImage = copy.deepcopy(image)
        self.differenceImage.subtractImage(self.analyticalEdgeImageFF)    

        if self.rawOutput:
            self.differenceImage.saveRAW(&#34;{dir}/{name}_difference.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;, addInfo=True)
        else: # TIFF
            self.differenceImage.save(&#34;{dir}/{name}_difference.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;)


        self.differenceImage.square()
        self.partlyCovered_rmsd = math.sqrt(numpy.mean(self.differenceImage.px[numpy.nonzero((self.analyticalEdgeImageFF.px &gt; 0) &amp; (self.analyticalEdgeImageFF.px &lt; 60000))]))

        print(&#34;RMSD of partly covered (analytical) pixels:          {:.2f} GV&#34;.format(self.partlyCovered_rmsd))



        # Write a CSV file with all pixel values and their differences
        csvText = &#34;# x [px]\ty [px]\tAnalytical GV\tMeasured GV\tDifference\n&#34;

        partlyCoveredCoordinates_analytical = numpy.nonzero((self.analyticalEdgeImageFF.px &gt; 0) &amp; (self.analyticalEdgeImageFF.px &lt; 60000))

        for i in range(len(partlyCoveredCoordinates_analytical[0])):
            x = partlyCoveredCoordinates_analytical[1][i]
            y = partlyCoveredCoordinates_analytical[0][i]
            analytical = self.analyticalEdgeImageFF.px[y][x]
            measured   = image.px[y][x]
            difference = measured - analytical

            csvText += &#34;{x}\t{y}\t{analytical:.3f}\t{measured:.3f}\t{delta:.3f}\n&#34;.format(x=x, y=y, analytical=analytical, measured=measured, delta=difference)

        csvFileName = &#34;{dir}/{name}_pixel_list.txt&#34;.format(dir=self.resultFileDirectory, name=self.name)
        with open(csvFileName, &#39;w&#39;) as csvFile:
            csvFile.write(csvText)
            csvFile.close()

        self.plotResults()

        return image

    def plotResults(self):
        pass

    def followUp(self):
        log(&#34;Writing evaluation results...&#34;)

        summaryText  = &#34;# |A| = Number of partly covered pixels in analytical image: {}\n&#34;.format(self.numberOfPartlyCoveredPixels_analytical)
        summaryText += &#34;# |M| = Number of partly covered pixels in measured image:   {}\n&#34;.format(self.numberOfPartlyCoveredPixels_measured)
        summaryText += &#34;# Number of pixels partly covered in both images:            {}\n&#34;.format(self.matchingPixels)
        summaryText += &#34;# r = Ratio (covered in both)/(covered in analytical):       {:.2f}%\n&#34;.format(100.0*self.matchRatio)
        summaryText += &#34;# RMSD [partly covered analytical vs. measured]:             {:.2f} GV&#34;.format(self.partlyCovered_rmsd)

        summaryFileName = &#34;{dir}/{name}_summary.txt&#34;.format(dir=self.resultFileDirectory, name=self.name)
        with open(summaryFileName, &#39;w&#39;) as summaryFile:
            summaryFile.write(summaryText)
            summaryFile.close()</code></pre>
</details>
<div class="desc"><p>CTSimU test 2D-WE-2: Effect of partial pixel coverage.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctsimu.test.generalTest" href="../test.html#ctsimu.test.generalTest">generalTest</a></li>
<li><a title="ctsimu.processing.step.Step" href="../processing/step.html#ctsimu.processing.step.Step">Step</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.evaluation.test2D_WE_2.Test2D_WE_2.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34; Preparations before the test will be run with the images from the pipeline. &#34;&#34;&#34;
    if not isinstance(self.pipe, Pipeline):
        self.prepared = False
        raise Exception(&#34;Step must be part of a processing pipeline before it can prepare. Current pipeline: {}&#34;.format(self.pipe))

    if not self.prepared:
        self.jsonScenarioFile = &#34;2D-WE-2_2021-10-13v02r03dp.json&#34;

        # Calculate the analytical image of an edge covering the image:
        if(self.jsonScenarioFile is not None):
            scenario = Scenario(json_dict=json_from_pkg(pkg_scenario(self.jsonScenarioFile)))

            self.geometry = scenario.current_geometry()
            self.geometry.update()
            
            self.analyticalIntensityProfileImage, self.analyticalEdgeImage = self.geometry.create_detector_flat_field_sphere(self.clippingRectangle)
            self.analyticalEdgeImageFF = copy.deepcopy(self.analyticalEdgeImage)
            self.analyticalEdgeImageFF.applyFlatfield(ref=self.analyticalIntensityProfileImage, rescaleFactor=60000.0)

            # Raise analytical images to maximum grey value of 60000 before saving them.
            # This rescaling does not affect the previous FF correction.
            self.analyticalIntensityProfileImage.renormalize(newMin=0.0, newMax=60000.0, currentMin=0.0, currentMax=1.0)
            self.analyticalEdgeImage.renormalize(newMin=0.0, newMax=60000.0, currentMin=0.0, currentMax=1.0)


            # Write analytical images:
            if self.rawOutput:
                self.analyticalIntensityProfileImage.saveRAW(&#34;{dir}/{name}_analytical_flat.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;, addInfo=True)
                self.analyticalEdgeImage.saveRAW(&#34;{dir}/{name}_analytical_edge.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;, addInfo=True)
                self.analyticalEdgeImageFF.saveRAW(&#34;{dir}/{name}_analytical_edge_corrected.raw&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;, addInfo=True)
            else: # TIFF
                self.analyticalIntensityProfileImage.save(&#34;{dir}/{name}_analytical_flat.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;)
                self.analyticalEdgeImage.save(&#34;{dir}/{name}_analytical_edge.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;)
                self.analyticalEdgeImageFF.save(&#34;{dir}/{name}_analytical_edge_corrected.tif&#34;.format(dir=self.resultFileDirectory, name=self.name), dataType=&#34;float32&#34;)

            self.numberOfPartlyCoveredPixels_analytical = numpy.count_nonzero((self.analyticalEdgeImageFF.px &gt; 0) &amp; (self.analyticalEdgeImageFF.px &lt; 60000))

            print(&#34;Number of partly covered pixels in analytical image: {}&#34;.format(self.numberOfPartlyCoveredPixels_analytical))

            self.prepared = True
        else:
            raise Exception(&#34;Test 2D-WE-2: Please provide a JSON scenario description.&#34;)</code></pre>
</details>
<div class="desc"><p>Preparations before the test will be run with the images from the pipeline.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctsimu.test.generalTest" href="../test.html#ctsimu.test.generalTest">generalTest</a></b></code>:
<ul class="hlist">
<li><code><a title="ctsimu.test.generalTest.followUp" href="../processing/step.html#ctsimu.processing.step.Step.followUp">followUp</a></code></li>
<li><code><a title="ctsimu.test.generalTest.plotResults" href="../test.html#ctsimu.test.generalTest.plotResults">plotResults</a></code></li>
<li><code><a title="ctsimu.test.generalTest.run" href="../processing/step.html#ctsimu.processing.step.Step.run">run</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setName" href="../test.html#ctsimu.test.generalTest.setName">setName</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setRawOutput" href="../test.html#ctsimu.test.generalTest.setRawOutput">setRawOutput</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setResultFileDirectory" href="../test.html#ctsimu.test.generalTest.setResultFileDirectory">setResultFileDirectory</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<div class="toc">
<ul>
<li><a href="#test-2d-we-2-effect-of-partial-pixel-coverage">Test 2D-WE-2: Effect of partial pixel coverage</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu.evaluation" href="index.html">ctsimu.evaluation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.evaluation.test2D_WE_2.Test2D_WE_2" href="#ctsimu.evaluation.test2D_WE_2.Test2D_WE_2">Test2D_WE_2</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.evaluation.test2D_WE_2.Test2D_WE_2.prepare" href="#ctsimu.evaluation.test2D_WE_2.Test2D_WE_2.prepare">prepare</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
