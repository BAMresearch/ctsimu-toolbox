<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>ctsimu.evaluation.test2D_SW_3 API documentation</title>
<meta name="description" content="Test 2D-SW-3: Boolean models, contiguous surfaces â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
<style>
thead {
border-top: 2px solid #000;
border-bottom:1px solid #000;
}
tbody {
border-bottom: 2px solid #000;
}
th, td {
padding: 0.1em;
padding-right: 1em;
white-space: nowrap;
}
tr:hover {background-color: #eee;}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.evaluation.test2D_SW_3</code></h1>
</header>
<section id="section-intro">
<h1 id="test-2d-sw-3-boolean-models-contiguous-surfaces">Test 2D-SW-3: Boolean models, contiguous surfaces</h1>
<p>The term <em>Boolean models</em> refers to defined, reproducible behavior in regions where models overlap. In these regions, an object of higher priority is supposed to completely replace any other object of lower priority. This test employs the step wedge known from the former two scenarios, but splits it into a left-hand piece that shows straight edges in the projection image and a right-hand piece that is beveled (see the following picture). When positioned correctly, both pieces touch at the central three steps (contiguous surfaces). Between the upper three steps, there is a small gap of decreasing width, and for the lower three steps, both pieces overlap. The right-hand piece is supposed to completely replace the left-hand piece in those overlap regions</p>
<p><img alt="Boolean models" src="../pictures/boolean_models.png" title="Boolean models"></p>
<p>The picture shows example projection images for the two tests for 2D-SW-3. In each of the two sub-scenarios, the beveled right-hand piece is supposed to replace the left-hand piece in the region of the lower three steps where both models overlap. For the upper three steps, there remains a gap of decreasing width and at the central three steps, both surfaces touch.</p>
<p>The test considers two sub-scenarios. In the first scenario, the two pieces are both assumed to be of aluminum. In the projection image, there should be no detectable gray value change at the object boundaries for the lower six steps. For the second scenario, the left-hand piece is assumed to be of aluminum and the right-hand piece of titanium. There must be a detectable gray value change at pixels where the expected material boundaries are located. In all other areas, the gray values within each step should not change.</p>
<p>Both scenarios can be evaluated by the toolbox at once, but single evaluations of each sub-scenario are possible as well. Use the keywords <code>Al_Al</code> and <code>Al_Ti</code> as shown in the following example to correctly identify each sub-scenario.</p>
<pre><code class="language-python">from ctsimu.toolbox import Toolbox
Toolbox(&quot;2D-SW-3&quot;,
    Al_Al = &quot;2D-SW-3_Al-Al_metadata.json&quot;,
    Al_Ti = &quot;2D-SW-3_Al-Ti_metadata.json&quot;
)
</code></pre>
<p>To detect locations of gray value changes and possible anomalies, the first step in the evaluation process is to calculate the gray value derivatives for each horizontal line of pixels. The scenario specifies a 1000x1000 pixel projection image. We assume a pixel coordinate system where <em>x</em> denotes the index within a row and <em>y</em> denotes the index within a column. The upper left pixel has index (0, 0), the lower right pixel is located at index (999, 999). In the derivative image, a pixel's gray value <span><span class="MathJax_Preview">p^\prime</span><script type="math/tex">p^\prime</script></span> is calculated as the difference of the original gray value <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> of its successor at position <em>x+1</em> and its own gray value:</p>
<p><span><span class="MathJax_Preview"> p^\prime (x, y) = p(x+1, y) - p(x, y) ~~~~ \forall~x \in [0, 998],~y \in [0, 999]. </span><script type="math/tex; mode=display"> p^\prime (x, y) = p(x+1, y) - p(x, y) ~~~~ \forall~x \in [0, 998],~y \in [0, 999]. </script></span></p>
<p>The last pixel column at <span><span class="MathJax_Preview">x=999</span><script type="math/tex">x=999</script></span> is omitted as it has no successor. We therefore get a derivative image with a size of 999x1000 pixels. Numerical limitations may lead to minor deviations in regions where constant gray values are expected. We ignore any gray value changes below 0.04% of the free beam intensity, which corresponds to 24 gray values for the required free beam gray value of 60000. This leads to cleaned gray value derivatives</p>
<p><span><span class="MathJax_Preview">
p^\prime_{\text{cleaned}}(x, y) = \begin{cases}
0 &amp; p^\prime(x, y) &lt; 24\,\text{GV} \\
p^\prime(x, y) &amp; p^\prime(x, y) \geqslant 24\,\text{GV}
\end{cases}.
</span><script type="math/tex; mode=display">
p^\prime_{\text{cleaned}}(x, y) = \begin{cases}
0 & p^\prime(x, y) < 24\,\text{GV} \\
p^\prime(x, y) & p^\prime(x, y) \geqslant 24\,\text{GV}
\end{cases}.
</script></span></p>
<p>The scenario requires monochromatic radiation with a photon energy of 80 keV. The specified densities of <span><span class="MathJax_Preview">\rho_\text{Al}=2.6989\,\text{g}/\text{cm}^3</span><script type="math/tex">\rho_\text{Al}=2.6989\,\text{g}/\text{cm}^3</script></span> and <span><span class="MathJax_Preview">\rho_\text{Ti}=4.506\,\text{g}/\text{cm}^3</span><script type="math/tex">\rho_\text{Ti}=4.506\,\text{g}/\text{cm}^3</script></span> and the mass attenuation coefficients <span><span class="MathJax_Preview">\mu_\text{Al}/\rho=0.2018\,\text{cm}^2/\text{g}</span><script type="math/tex">\mu_\text{Al}/\rho=0.2018\,\text{cm}^2/\text{g}</script></span> and <span><span class="MathJax_Preview">\mu_\text{Ti}/\rho=0.4052\,\text{cm}^2/\text{g}</span><script type="math/tex">\mu_\text{Ti}/\rho=0.4052\,\text{cm}^2/\text{g}</script></span> (<a href="https://doi.org/10.18434/T4D01F">Hubbell et al.</a>) lead to the specific attenuation coefficients <span><span class="MathJax_Preview">\mu_\text{Al}=0.0544638/\text{mm}</span><script type="math/tex">\mu_\text{Al}=0.0544638/\text{mm}</script></span> and <span><span class="MathJax_Preview">\mu_\text{Ti}=0.18234/\text{mm}</span><script type="math/tex">\mu_\text{Ti}=0.18234/\text{mm}</script></span> for the materials used in this scenario. The Beer-Lambert law of attenuation, the thickness of each step and the requirement for a free beam intensity of 60000 gray values lead to the expected gray values (after flat-field correction) listed in the following table.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Step</th>
<th style="text-align: right;">1</th>
<th style="text-align: right;">2</th>
<th style="text-align: right;">3</th>
<th style="text-align: right;">4</th>
<th style="text-align: right;">5</th>
<th style="text-align: right;">6</th>
<th style="text-align: right;">7</th>
<th style="text-align: right;">8</th>
<th style="text-align: right;">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Thickness in mm</td>
<td style="text-align: right;">41.00</td>
<td style="text-align: right;">35.89</td>
<td style="text-align: right;">30.79</td>
<td style="text-align: right;">25.68</td>
<td style="text-align: right;">20.58</td>
<td style="text-align: right;">15.47</td>
<td style="text-align: right;">10.36</td>
<td style="text-align: right;">5.26</td>
<td style="text-align: right;">0.15</td>
</tr>
<tr>
<td style="text-align: left;">Al gray value</td>
<td style="text-align: right;">6432</td>
<td style="text-align: right;">8496</td>
<td style="text-align: right;">11217</td>
<td style="text-align: right;">14816</td>
<td style="text-align: right;">19560</td>
<td style="text-align: right;">25837</td>
<td style="text-align: right;">34127</td>
<td style="text-align: right;">45054</td>
<td style="text-align: right;">59512</td>
</tr>
<tr>
<td style="text-align: left;">Ti gray value</td>
<td style="text-align: right;">34</td>
<td style="text-align: right;">86</td>
<td style="text-align: right;">219</td>
<td style="text-align: right;">555</td>
<td style="text-align: right;">1407</td>
<td style="text-align: right;">3573</td>
<td style="text-align: right;">9073</td>
<td style="text-align: right;">22994</td>
<td style="text-align: right;">58381</td>
</tr>
<tr>
<td style="text-align: left;">&Delta;</td>
<td style="text-align: right;">6398</td>
<td style="text-align: right;">8410</td>
<td style="text-align: right;">10998</td>
<td style="text-align: right;">14261</td>
<td style="text-align: right;">18153</td>
<td style="text-align: right;">22264</td>
<td style="text-align: right;">25054</td>
<td style="text-align: right;">22060</td>
<td style="text-align: right;">1131</td>
</tr>
<tr>
<td style="text-align: left;">y<sub>0</sub> in px</td>
<td style="text-align: right;">819</td>
<td style="text-align: right;">728</td>
<td style="text-align: right;">637</td>
<td style="text-align: right;">546</td>
<td style="text-align: right;">455</td>
<td style="text-align: right;">364</td>
<td style="text-align: right;">273</td>
<td style="text-align: right;">182</td>
<td style="text-align: right;">91</td>
</tr>
<tr>
<td style="text-align: left;">y<sub>1</sub> in px</td>
<td style="text-align: right;">908</td>
<td style="text-align: right;">817</td>
<td style="text-align: right;">726</td>
<td style="text-align: right;">635</td>
<td style="text-align: right;">544</td>
<td style="text-align: right;">453</td>
<td style="text-align: right;">362</td>
<td style="text-align: right;">271</td>
<td style="text-align: right;">180</td>
</tr>
</tbody>
</table>
<p>The table lists the total material thickness of each step of the spherical wedge that a ray from the source encounters. The expected analytical gray values from the law of radiation attenuation are listed, as well as the difference &Delta; between aluminum and titanium. In the projection image, each step is fully present in their respective region <span><span class="MathJax_Preview">y\in[y_0, y_1]</span><script type="math/tex">y\in[y_0, y_1]</script></span>. The rows in between are <em>forbidden</em> lines where transitions between steps take place.}</p>
<p>Each step of the wedge occupies 1/11 of the height of the projection image. The locations <span><span class="MathJax_Preview">y_\text{step}</span><script type="math/tex">y_\text{step}</script></span> of their boundaries are listed on the right side of the graph. <span><span class="MathJax_Preview">\lfloor y_\text{step} \rfloor</span><script type="math/tex">\lfloor y_\text{step} \rfloor</script></span> gives the floor function value, i.e., the pixel index of the <em>forbidden rows</em> where the transitions from one step to another reside. The maximum widths of the material gap and the overlap region are shown.</p>
<p><img alt="Boolean models" src="../pictures/wedge_step-y-locations.png" title="Boolean models"></p>
<p>The algorithm now treats each horizontal row of the image of gray value derivatives separately. For each row, the following procedure is applied.</p>
<ol>
<li>
<p>The pixels with indices <span><span class="MathJax_Preview">x\in[80, 99]</span><script type="math/tex">x\in[80, 99]</script></span> and <span><span class="MathJax_Preview">x\in[870, 919]</span><script type="math/tex">x\in[870, 919]</script></span> are set to zero. This ignores any gray value transitions and pixel anomalies in the left and right border regions where gray values transition from free beam intensities to material intensities (i.e., where the wedge begins and ends).</p>
</li>
<li>
<p><strong>Gap region.</strong> For each pixel row, the width of the air gap is calculated. For continuous coordinates <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> in the pixel coordinate system, the width <span><span class="MathJax_Preview">w_\text{gap}</span><script type="math/tex">w_\text{gap}</script></span> (in pixels) is given by the linear function
<span><span class="MathJax_Preview">w_{\text{gap}}(y) = -\frac{5\,\text{px}}{3h_{\text{step}}} \left( y - 4h_{\text{step}} \right),</span><script type="math/tex; mode=display">w_{\text{gap}}(y) = -\frac{5\,\text{px}}{3h_{\text{step}}} \left( y - 4h_{\text{step}} \right),</script></span>
with the height of a step <span><span class="MathJax_Preview">h_\text{step} = \frac{1000\,\text{px}}{11}</span><script type="math/tex">h_\text{step} = \frac{1000\,\text{px}}{11}</script></span>. See the above picture for reference. If we only allow discrete integer coordinates for the pixels, each row <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> therefore has an upper and a lower gap width:
<span><span class="MathJax_Preview">w_{\text{gap,upper}}(r) = -\frac{5\,\text{px}}{3h_{\text{step}}} \left( r - 4h_{\text{step}} \right),</span><script type="math/tex; mode=display">w_{\text{gap,upper}}(r) = -\frac{5\,\text{px}}{3h_{\text{step}}} \left( r - 4h_{\text{step}} \right),</script></span>
<span><span class="MathJax_Preview">w_{\text{gap,lower}}(r) = -\frac{5\,\text{px}}{3h_{\text{step}}} \left( (r+1) - 4h_{\text{step}} \right).</span><script type="math/tex; mode=display">w_{\text{gap,lower}}(r) = -\frac{5\,\text{px}}{3h_{\text{step}}} \left( (r+1) - 4h_{\text{step}} \right).</script></span>
The left boundary of the air gap is marked by the pixel at <span><span class="MathJax_Preview">x_{\text{gap,left}}=500</span><script type="math/tex">x_{\text{gap,left}}=500</script></span>, the first one to contain free-beam contributions in the intensity. The location of the right boundary depends on the gap width. We can calculate two pixel indices for the interval in which the boundary should be found, tolerances included:
<span><span class="MathJax_Preview">x_{\text{gap,right,0}} = x_{\text{gap,left}} + \lfloor w_{\text{gap,lower}} \rfloor - 1,</span><script type="math/tex; mode=display">x_{\text{gap,right,0}} = x_{\text{gap,left}} + \lfloor w_{\text{gap,lower}} \rfloor - 1,</script></span>
<span><span class="MathJax_Preview">x_{\text{gap,right,1}} = x_{\text{gap,left}} + \lfloor w_{\text{gap,upper}} \rfloor.</span><script type="math/tex; mode=display">x_{\text{gap,right,1}} = x_{\text{gap,left}} + \lfloor w_{\text{gap,upper}} \rfloor.</script></span>
Now we need to consider the following cases, ordered from highest to lowest priority.</p>
<ul>
<li>
<p>If <span><span class="MathJax_Preview">w_{\text{gap,lower}}\leq 0</span><script type="math/tex">w_{\text{gap,lower}}\leq 0</script></span> we are not in a region where the gap is found (step number is lower than 7). In this case, we can continue with step~3 of the algorithm.</p>
</li>
<li>
<p>If <span><span class="MathJax_Preview">0 &lt; w_\text{gap,lower}\leq 1</span><script type="math/tex">0 < w_\text{gap,lower}\leq 1</script></span> we assume that the air gap is too small to be fully resolved in between the two wedges. The sum of gray value changes across the complete gap region is calculated. It must match (i.e., be within 5% of) the expected gray value transition from the left material (Al) to the right material (Al or Ti). If this is the case, we set the gray value differences in the area of the gap to zero for all <span><span class="MathJax_Preview">x\in\left[ 498, x_{\text{gap,right,1}} \right]</span><script type="math/tex">x\in\left[ 498, x_{\text{gap,right,1}} \right]</script></span>. If the current row <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> is a <em>forbidden row</em>, we ignore the gray value differences and set the pixels to zero as well. If both conditions are not fulfilled, we set the value of the pixel at <span><span class="MathJax_Preview">x=499</span><script type="math/tex">x=499</script></span> to the expected gray value difference and all other pixels in the considered range to zero. This puts the whole weight of the anomaly onto one pixel and makes counting anomalies easier afterwards.</p>
</li>
<li>
<p>If <span><span class="MathJax_Preview">w_{\text{gap,lower}} &gt; 1</span><script type="math/tex">w_{\text{gap,lower}} > 1</script></span> it should be possible to resolve the air gap (i.e., there should be at least one pixel that contains the free beam intensity in the original projection).</p>
<ul>
<li>
<p>At first, we treat the boundary between the material of the left wedge and the environment. In the difference image, the sum over the boundary pixels at <span><span class="MathJax_Preview">x\in\left[ 498, 499 \right]</span><script type="math/tex">x\in\left[ 498, 499 \right]</script></span> should match (within 5%) the expected gray value change from the Al step to the free beam intensity. If <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> is a <em>forbidden row</em>, we only check if the slope of the profile points upwards towards higher gray values, i.e., we check for a positive gray value difference for both pixels under consideration. If any of these two conditions is fulfilled, we set the two boundary pixels to zero in the difference image. Otherwise we set the value of the pixel at <span><span class="MathJax_Preview">x=499</span><script type="math/tex">x=499</script></span> to the expected gray value difference, and all other pixels in the considered range to zero.</p>
</li>
<li>
<p>We repeat this procedure for the right boundary, from environment to the right wedge, for the pixels at <span><span class="MathJax_Preview">x\in \left[x_{\text{gap,right,0}}, x_{\text{gap,right,1}} \right]</span><script type="math/tex">x\in \left[x_{\text{gap,right,0}}, x_{\text{gap,right,1}} \right]</script></span>. It is checked whether there is the expected (within 5%) drop in gray values to lower intensities. For <em>forbidden rows</em>, it is only necessary that there is a negative difference (decreasing slope). Otherwise, an anomaly is introduced to the difference image, as described above.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Contact region.</strong> The pixel rows that belong to steps 4, 5 and 6 are considered. Only the three pixels at the material intersection are treated: <span><span class="MathJax_Preview">x\in\left[ 498, 500 \right]</span><script type="math/tex">x\in\left[ 498, 500 \right]</script></span>. For the Al/Al scenario, nothing is done here. There is no expected gray value difference, and any existing gray value anomaly will persist for the final evaluation. For the Al/Ti scenario, the sum of gray value differences of these three pixels must match (within 5%) the expected gray value difference between Al and Ti. If the current row <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> is a <em>forbidden row</em>, the gray value differences for these three pixels must be zero or negative, i.e. the gray value must not rise at the transition from Al to Ti. If any of these two conditions is fulfilled, we set the value of these three pixels to zero in the difference image. Otherwise, we set the value of the pixel at <span><span class="MathJax_Preview">x=498</span><script type="math/tex">x=498</script></span> to the expected gray value difference, and all other pixels in the considered range to zero.</p>
</li>
<li>
<p><strong>Displacement region.</strong> The pixel rows for steps 1, 2 and 3 are treated very similarly. For the Al/Al scenario, no gray value difference is expected and nothing is done here. For the Al/Ti scenario, the leftmost and rightmost pixel coordinate <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> is calculated that should be considered when checking the gray value changes:
<span><span class="MathJax_Preview">x_{\text{boundary,0}}(r) = 498-\frac{10\,\text{px}}{3h_{\text{step}}} \left( r - 7h_{\text{step}} \right),</span><script type="math/tex; mode=display">x_{\text{boundary,0}}(r) = 498-\frac{10\,\text{px}}{3h_{\text{step}}} \left( r - 7h_{\text{step}} \right),</script></span>
<span><span class="MathJax_Preview">x_{\text{boundary,1}}(r) = 500-\frac{10\,\text{px}}{3h_{\text{step}}} \left( (r+1) - 7h_{\text{step}} \right).</span><script type="math/tex; mode=display">x_{\text{boundary,1}}(r) = 500-\frac{10\,\text{px}}{3h_{\text{step}}} \left( (r+1) - 7h_{\text{step}} \right).</script></span>
The sum of gray value changes for all pixels in <span><span class="MathJax_Preview">x\in\left[x_{\text{boundary,0}}, x_{\text{boundary,1}} \right]</span><script type="math/tex">x\in\left[x_{\text{boundary,0}}, x_{\text{boundary,1}} \right]</script></span> must match (within 5%) the expected gray value difference between Al and Ti. If the current row <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> is a <em>forbidden row</em>, the gray value differences for these three pixels must be zero or negative, i.e., the gray value must not rise at the transition from Al to Ti. If any of these two conditions is fulfilled, we set the value of these three pixels to zero in the difference image. Otherwise, we set the value of the pixel at <span><span class="MathJax_Preview">x_{\text{boundary,1}}</span><script type="math/tex">x_{\text{boundary,1}}</script></span> to the expected gray value difference, and all other pixels in the considered range to zero.</p>
</li>
</ol>
<p>After this algorithm has been applied to each pixel row, all pixels in the difference image should have a value of zero. Pixels with other values are counted as anomalies. The mean gray value difference of all pixel anomalies is calculated.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3"><code class="flex name class">
<span>class <span class="ident">Test2D_SW_3</span></span>
<span>(</span><span>resultFileDirectory='.', name=None, rawOutput=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Test2D_SW_3(generalTest):
    &#34;&#34;&#34; CTSimU test 2D-SW-3: Boolean Models. &#34;&#34;&#34;

    def __init__(self, resultFileDirectory=&#34;.&#34;, name=None, rawOutput=False):
        generalTest.__init__(
            self,
            testName=&#34;2D-SW-3&#34;,
            name=name,
            resultFileDirectory=resultFileDirectory,
            rawOutput=rawOutput)

        self.results = []

        self.gv_deviation_limit = 25  # maximum expected in-material grey value deviation

        self.shrink = 0
        self.leftOffset = 450 - self.shrink
        self.nPixels = 100 + 2*self.shrink

        self.steps = [
            ImageROI(self.leftOffset, 818, self.leftOffset+self.nPixels, 910),
            ImageROI(self.leftOffset, 727, self.leftOffset+self.nPixels, 818),
            ImageROI(self.leftOffset, 636, self.leftOffset+self.nPixels, 727),
            ImageROI(self.leftOffset, 545, self.leftOffset+self.nPixels, 636),
            ImageROI(self.leftOffset, 454, self.leftOffset+self.nPixels, 545),
            ImageROI(self.leftOffset, 363, self.leftOffset+self.nPixels, 454),
            ImageROI(self.leftOffset, 272, self.leftOffset+self.nPixels, 363),
            ImageROI(self.leftOffset, 181, self.leftOffset+self.nPixels, 272),
            ImageROI(self.leftOffset,  90, self.leftOffset+self.nPixels, 181),
            ImageROI(self.leftOffset,   0, self.leftOffset+self.nPixels,  90)  # free beam, not treated.
        ]

        # Step thicknesses:
        self.thicknesses = [41.0, 35.89, 30.79, 25.68, 20.58, 15.47, 10.36, 5.26, 0.15, 0.0]

        # Those pixel lines are between the steps of the wedge:
        self.forbidden_lines = [90, 181, 272, 363, 454, 545, 636, 727, 818, 909]

        # Use Beer-Lambert to calculate expected attenuation at 80 keV:
        # Data source: NIST https://physics.nist.gov/PhysRefData/XrayMassCoef/tab3.html
        muAl = 0.0544638 # /mm
        muTi = 0.18234   # /mm
        self.attenuationsAl = []
        self.attenuationsTi = []

        for d in self.thicknesses:
            attAl = math.exp(-d*muAl)
            attTi = math.exp(-d*muTi)

            self.attenuationsAl.append(attAl)
            self.attenuationsTi.append(attTi)


    def prepare(self):
        &#34;&#34;&#34; Preparations before the test will be run with the images from the pipeline. &#34;&#34;&#34;
        self.prepared = True

    def prepareRun(self, i):
        if i &lt; len(self.subtests):
            if self.subtests[i] == &#34;Al_Al&#34;:
                pass
            elif self.subtests[i] == &#34;Al_Ti&#34;:
                pass
            else:
                raise Exception(&#34;{key} is not a valid subtest identifier for test scenario {test}&#34;.format(key=self.subtests[i], test=self.testName))

            self.results.append(Test2D_SW_3_results())
        else:
            if len(self.subtests) == 0:
                raise Exception(&#34;Please provide keywords that identify which metadata file belongs to which subtest. Test {testname} accepts the following keywords: &#39;Al_Al&#39; and &#39;Al_Ti&#39;.&#34;.format(testname=self.testName))
            else:
                raise Exception(&#34;Number of provided image metadata files exceeds number of test runs ({expected}).&#34;.format(expected=len(self.subtests)))

    def is_near(self, expected, other):
        if expected != 0:  # relative deviation no more than 5%
            return ((abs(other-expected)/abs(expected)) &lt; 0.05)   # 5% maximum deviation from expectation value
        else:
            return (abs(other) &lt; self.gv_deviation_limit)   # If the expected difference is 0, the maximum abs. GV deviation should be within the expected limit.

    def run(self, image):
        self.prepare()
        self.prepareRun(self.currentRun)
        i = self.currentRun
        subtestName = self.subtests[i]

        detectorSize = 1000

        air = self.steps[-1]  # The last ROI is the air ROI.
        airStats = image.stats(air)
        gvAir = airStats[&#34;mean&#34;]

        print(&#34;Air grey value: {}&#34;.format(gvAir))

        # Calculate a derivative image:
        derivative = copy.deepcopy(image)
        derivative.px[:,:-1] = derivative.px[:,1:] - derivative.px[:,:-1]
        derivative.crop(0, 0, 999, 1000)

        # Clean using the 0.04% deviation threshold.
        self.gv_deviation_limit = gvAir * 4e-4  # (0.04% of 60000 = 24)
        print(&#34;GV deviation limit: {}&#34;.format(self.gv_deviation_limit))

        derivative.px[numpy.where(numpy.absolute(derivative.px) &lt; self.gv_deviation_limit)] = 0

        derivative.saveTIFF(filename=&#34;{dir}/{name}_{subname}_derivative_cleaned.tif&#34;.format(dir=self.resultFileDirectory, name=self.name, subname=subtestName), dataType=&#34;float32&#34;)


        # Calculate expected grey values:
        gvAl = [gvAir*att for att in self.attenuationsAl]
        gvTi = [gvAir*att for att in self.attenuationsTi]
        gvRight = gvAl  # grey values for the wedge material to the right (either Al or Ti)

        if subtestName == &#34;Al_Ti&#34;:
            gvRight = gvTi

        for step in range(0, 9):  # only treat the first nine (true) steps, ignore free beam
            roi = self.steps[step]
            y0 = roi.y0
            y1 = roi.y1

            for y in range(y1-1, y0-1, -1):
                # -- LEFT BOUNDARY
                &#34;&#34;&#34;
                # Calculate GV drop for the left boundary at x=89,90:
                sum_across_left_boundary = numpy.sum(derivative.px[y,89:91])

                # The sum over these two columns should represent a drop from GV(air) to GV(Al)
                if self.is_near(-diff_air_al, sum_across_left_boundary):
                    # Set both of them to zero so that they are not counted as an anomaly:
                    derivative.px[y,89:91] = 0
                elif y in self.forbidden_lines:
                    # If this is a forbidden line, only check if all slopes point downward.
                    if not any(diff &gt; 0 for diff in derivative.px[y,89:91]):
                        derivative.px[y,89:91] = 0
                    else:
                        # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                        derivative.px[y,89] = 0
                        derivative.px[y,90] = -diff_air_al
                else:
                    # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                    derivative.px[y,89] = 0
                    derivative.px[y,90] = -diff_air_al
                

                # -- RIGHT BOUNDARY
                x_bevel = 883 - y
                x_right = 908
                padding = 2
                if x_bevel &lt; 0:
                    x_right += x_bevel
                    padding = 5

                x0 = x_right - padding
                x1 = x_right + padding
                sum_across_right_boundary = numpy.sum(derivative.px[y,x0:x1+1])
                if self.is_near(diff_air_right, sum_across_right_boundary):
                    derivative.px[y,x0:x1+1] = 0
                elif y in self.forbidden_lines:
                    # If this is a forbidden line, only check if all slopes point upward.
                    if not any(diff &lt; 0 for diff in derivative.px[y,x0:x1+1]):
                        derivative.px[y,x0:x1+1] = 0
                    else:
                        # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                        derivative.px[y,x0:x1+1] = 0
                        derivative.px[y,x0] = diff_air_right
                else:
                    # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                    derivative.px[y,x0:x1+1] = 0
                    derivative.px[y,x0] = diff_air_right
                &#34;&#34;&#34;

                # We do not treat the outer boundaries anymore.
                # They are not subject to Boolean models or contiguous surfaces.
                # Instead, set the derivatives in these regions to zero.
                derivative.px[y,80:100] = 0
                derivative.px[y,870:920] = 0



                # Width of air gap in the upper third of the wedge, for upper and lower y-line boundary:
                w_gap_upper = (-11*5/(3*1000))*(y - (4*1000)/11)
                w_gap_lower = (-11*5/(3*1000))*((y+1) - (4*1000)/11)

                # Position of material interface:
                x_mat_upper = (-11*10/(3*1000))*(y - (7*1000)/11)
                x_mat_lower = (-11*10/(3*1000))*((y+1) - (7*1000)/11)

                diff_air_al = gvAir - gvAl[step]
                diff_air_right = gvAir - gvRight[step]
                diff_right_al  = gvRight[step] - gvAl[step]
                

                # -- CENTRAL BOUNDARIES
                if w_gap_lower &gt; 0:  # air gap, steps 7, 8, 9
                    # Right x locations of the gap boundary (left is always at 500).
                    # In the variable names, left and right refer to the leftmost
                    # and rightmost pixel to consider for the sloped edge.
                    x_gap_right0 = 500 + int(math.trunc(w_gap_lower)) - 1
                    x_gap_right1 = 500 + int(math.trunc(w_gap_upper))

                    # If the gap is far enough to separate Al, air and Al/Ti:
                    if w_gap_lower &gt; 1:
                        # Check if there is a GV rise to air at x=498,499
                        sum_across_boundary_to_air = numpy.sum(derivative.px[y,498:500])
                        if self.is_near(diff_air_al, sum_across_boundary_to_air):
                            # Set both of them to zero so that they are not counted as an anomaly:
                            derivative.px[y,498:500] = 0
                        elif (y in self.forbidden_lines) and (not any(diff &lt; 0 for diff in derivative.px[y,498:500])):
                            derivative.px[y,498:500] = 0
                        else:
                            # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                            derivative.px[y,498:500] = 0
                            derivative.px[y,499] = diff_air_al

                        # Check if there is a GV drop to the material at the right of the gap (Al/Ti):
                        sum_across_boundary_to_right_material = numpy.sum(derivative.px[y,x_gap_right0:x_gap_right1+1])
                        if self.is_near(-diff_air_right, sum_across_boundary_to_right_material):
                            # Set right gap boundary pixels to zero so that they are not counted as an anomaly:
                            derivative.px[y,x_gap_right0:x_gap_right1+1] = 0
                        elif (y in self.forbidden_lines) and (not any(diff &gt; 0 for diff in derivative.px[y,x_gap_right0:x_gap_right1+1])):
                            derivative.px[y,x_gap_right0:x_gap_right1+1] = 0
                        else:
                            # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                            derivative.px[y,x_gap_right0:x_gap_right1+1] = 0
                            derivative.px[y,x_gap_right0] = -diff_air_right
                    else:  # if the gap is too narrow to separate left and right materials from the air gap
                        # Only the total sum over the gap has to match the material GV difference:
                        sum_across_complete_gap = numpy.sum(derivative.px[y,498:x_gap_right1+1])
                        if self.is_near(diff_right_al, sum_across_complete_gap) or (y in self.forbidden_lines):
                            derivative.px[y,498:x_gap_right1+1] = 0
                        else:
                            # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                            derivative.px[y,498:x_gap_right1+1] = 0
                            derivative.px[y,499] = diff_right_al
                elif subtestName == &#34;Al_Ti&#34;:
                    # We can skip Al_Al because the expected boundary difference is zero.

                    x_boundary_left  = 499 - 1
                    x_boundary_right = 499 + 1

                    if x_mat_lower &lt; 0:  # lower wedge in steps 1, 2, 3
                        x_boundary_left  += int(math.trunc(x_mat_lower))
                        x_boundary_right += int(math.trunc(x_mat_upper))

                    # Check if sum over central boundary matches expected grey value drop from left to right material:
                    sum_across_boundary = numpy.sum(derivative.px[y,x_boundary_left:x_boundary_right+1])
                    if self.is_near(diff_right_al, sum_across_boundary):
                        derivative.px[y,x_boundary_left:x_boundary_right+1] = 0
                    elif (y in self.forbidden_lines) and (not any(diff &gt; 0 for diff in derivative.px[y,x_boundary_left:x_boundary_right+1])):
                        derivative.px[y,x_boundary_left:x_boundary_right+1] = 0
                    else:
                        # Set one of the pixels to the expectation value, the others to zero. -&gt; introduces anomaly
                        derivative.px[y,x_boundary_left:x_boundary_right+1] = 0
                        derivative.px[y,x_boundary_right] = diff_right_al



        derivative.saveTIFF(filename=&#34;{dir}/{name}_{subname}_anomalies.tif&#34;.format(dir=self.resultFileDirectory, name=self.name, subname=subtestName), dataType=&#34;float32&#34;)

        absDevSum = numpy.sum(numpy.absolute(derivative.px))
        anomalies = numpy.where(numpy.absolute(derivative.px) &gt; 0)
        anomalyCount = len(anomalies[0])
        anomalyMean = &#34;-&#34;
        if anomalyCount &gt; 0:
            anomalyMean = absDevSum / anomalyCount

        print(&#34;Number of detected grey value anomalies: {}&#34;.format(anomalyCount))
        print(&#34;Mean grey value difference of all anomalies: {}&#34;.format(anomalyMean))

        summaryText  = &#34;# Evaluation of Test {name}, {subname}:\n&#34;.format(name=self.name, subname=subtestName)
        summaryText += &#34;# \n&#34;
        summaryText += &#34;# Number of detected grey value anomalies: {} \n&#34;.format(anomalyCount)
        summaryText += &#34;# Mean anomaly grey value: {} \n&#34;.format(anomalyMean)

        if anomalyCount &gt; 0:
            summaryText += &#34;# \n&#34;
            if anomalyCount &lt;= 60000:
                summaryText += &#34;# Anomaly positions:\n&#34;
                summaryText += &#34;# x\ty\n&#34;
                for i in range(len(anomalies[0])):
                    summaryText += &#34;{x}\t{y}\n&#34;.format(x=anomalies[1][i], y=anomalies[0][i])
            else:
                summaryText += &#34;# Too many anomalies for a text file. Please use the anomaly image file to inspect anomalies.\n&#34;

        summaryFileName = &#34;{dir}/{name}_{subname}_summary.txt&#34;.format(dir=self.resultFileDirectory, name=self.name, subname=subtestName)
        with open(summaryFileName, &#39;w&#39;) as summaryFile:
            summaryFile.write(summaryText)
            summaryFile.close()

        #self.plotResults()

        self.currentRun += 1
        return image

    def followUp(self):
        pass

    def plotResults(self):
        pass</code></pre>
</details>
<div class="desc"><p>CTSimU test 2D-SW-3: Boolean Models.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctsimu.test.generalTest" href="../test.html#ctsimu.test.generalTest">generalTest</a></li>
<li><a title="ctsimu.processing.step.Step" href="../processing/step.html#ctsimu.processing.step.Step">Step</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.is_near"><code class="name flex">
<span>def <span class="ident">is_near</span></span>(<span>self, expected, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_near(self, expected, other):
    if expected != 0:  # relative deviation no more than 5%
        return ((abs(other-expected)/abs(expected)) &lt; 0.05)   # 5% maximum deviation from expectation value
    else:
        return (abs(other) &lt; self.gv_deviation_limit)   # If the expected difference is 0, the maximum abs. GV deviation should be within the expected limit.</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34; Preparations before the test will be run with the images from the pipeline. &#34;&#34;&#34;
    self.prepared = True</code></pre>
</details>
<div class="desc"><p>Preparations before the test will be run with the images from the pipeline.</p></div>
</dd>
<dt id="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.prepareRun"><code class="name flex">
<span>def <span class="ident">prepareRun</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepareRun(self, i):
    if i &lt; len(self.subtests):
        if self.subtests[i] == &#34;Al_Al&#34;:
            pass
        elif self.subtests[i] == &#34;Al_Ti&#34;:
            pass
        else:
            raise Exception(&#34;{key} is not a valid subtest identifier for test scenario {test}&#34;.format(key=self.subtests[i], test=self.testName))

        self.results.append(Test2D_SW_3_results())
    else:
        if len(self.subtests) == 0:
            raise Exception(&#34;Please provide keywords that identify which metadata file belongs to which subtest. Test {testname} accepts the following keywords: &#39;Al_Al&#39; and &#39;Al_Ti&#39;.&#34;.format(testname=self.testName))
        else:
            raise Exception(&#34;Number of provided image metadata files exceeds number of test runs ({expected}).&#34;.format(expected=len(self.subtests)))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctsimu.test.generalTest" href="../test.html#ctsimu.test.generalTest">generalTest</a></b></code>:
<ul class="hlist">
<li><code><a title="ctsimu.test.generalTest.followUp" href="../processing/step.html#ctsimu.processing.step.Step.followUp">followUp</a></code></li>
<li><code><a title="ctsimu.test.generalTest.plotResults" href="../test.html#ctsimu.test.generalTest.plotResults">plotResults</a></code></li>
<li><code><a title="ctsimu.test.generalTest.run" href="../processing/step.html#ctsimu.processing.step.Step.run">run</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setName" href="../test.html#ctsimu.test.generalTest.setName">setName</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setRawOutput" href="../test.html#ctsimu.test.generalTest.setRawOutput">setRawOutput</a></code></li>
<li><code><a title="ctsimu.test.generalTest.setResultFileDirectory" href="../test.html#ctsimu.test.generalTest.setResultFileDirectory">setResultFileDirectory</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3_results"><code class="flex name class">
<span>class <span class="ident">Test2D_SW_3_results</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Test2D_SW_3_results:
    &#34;&#34;&#34; Results for one sub test. &#34;&#34;&#34;

    def __init__(self):
        # Horizontal Profile Data:
        self.profiles = []  # Horizontal grey value profile for each line</code></pre>
</details>
<div class="desc"><p>Results for one sub test.</p></div>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png" alt=""> ctsimu
</a>
</header>
<div class="toc">
<ul>
<li><a href="#test-2d-sw-3-boolean-models-contiguous-surfaces">Test 2D-SW-3: Boolean models, contiguous surfaces</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu.evaluation" href="index.html">ctsimu.evaluation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3" href="#ctsimu.evaluation.test2D_SW_3.Test2D_SW_3">Test2D_SW_3</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.is_near" href="#ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.is_near">is_near</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.prepare" href="#ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.prepare">prepare</a></code></li>
<li><code><a title="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.prepareRun" href="#ctsimu.evaluation.test2D_SW_3.Test2D_SW_3.prepareRun">prepareRun</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.evaluation.test2D_SW_3.Test2D_SW_3_results" href="#ctsimu.evaluation.test2D_SW_3.Test2D_SW_3_results">Test2D_SW_3_results</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
