<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctsimu.tiffy API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://bamresearch.github.io/ctsimu-toolbox/toolbox.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctsimu.tiffy</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-

# Version 0.1 (2020-09-29)

import os      # to check for files
import sys     # for native byteorder
import struct  # for C-style byte reading
import math    # for floor
import copy    # for deepcopy
import numpy   # for image data arrays

# Define TIFF field types:
TIFF_BYTE      =  1  #  8 bit unsigned
TIFF_ASCII     =  2  #  8 bit character
TIFF_SHORT     =  3  # 16 bit unsigned
TIFF_LONG      =  4  # 32 bit unsigned
TIFF_RATIONAL  =  5  # 2x32 bit unsigned (numerator, denominator)
TIFF_SBYTE     =  6  #  8 bit signed
TIFF_UNDEFINED =  7  #  8 bit of unknown data
TIFF_SSHORT    =  8  # 16 bit signed
TIFF_SLONG     =  9  # 32 bit signed
TIFF_SRATIONAL = 10  # 2x32 bit signed (numerator, denominator)
TIFF_FLOAT     = 11  #  4 byte single precision IEEE float
TIFF_DOUBLE    = 12  #  8 byte double precision IEEE float

TIFF_BYTES_PER_TYPE = [1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8]
TIFF_STRUCT_CHAR_FOR_TYPE = [&#34;B&#34;, &#34;c&#34;, &#34;H&#34;, &#34;L&#34;, &#34;LL&#34;, &#34;b&#34;, &#34;B&#34;, &#34;h&#34;, &#34;l&#34;, &#34;ll&#34;, &#34;f&#34;, &#34;d&#34;]

TIFF_INTTYPES = [TIFF_BYTE, TIFF_SHORT, TIFF_LONG, TIFF_SBYTE, TIFF_SSHORT, TIFF_SLONG]

# TIFF values
# Photometric Interpretation
TIFF_WHITE_IS_ZERO = 0
TIFF_BLACK_IS_ZERO = 1
TIFF_RGB           = 2

# Compression
TIFF_NO_COMPRESSION       = 1
TIFF_CCITT_COMPRESSION    = 2
TIFF_PACKBITS_COMPRESSION = 32773
TIFF_LZW_COMPRESSION      = 5

# Resolution unit
TIFF_RES_NONE       = 1
TIFF_RES_INCH       = 2
TIFF_RES_CENTIMETER = 3

# Sample format
TIFF_SAMPLEFORMAT_UINT   = 1
TIFF_SAMPLEFORMAT_INT    = 2
TIFF_SAMPLEFORMAT_IEEEFP = 3
TIFF_SAMPLEFORMAT_VOID   = 4

# Planar configuration
TIFF_CHUNKY = 1
TIFF_PLANAR = 2

# Fill order
TIFF_MSB2LSB = 1
TIFF_LSB2MSB = 2

# Predictor
TIFF_NO_PREDICTOR = 1
TIFF_HORIZONTAL_DIFFERENCING = 2

TAGNAMES = {
    &#34;254&#34;: &#34;New subfile type&#34;,
    &#34;256&#34;: &#34;Cols&#34;,
    &#34;257&#34;: &#34;Rows&#34;,
    &#34;258&#34;: &#34;Bits per sample&#34;,
    &#34;259&#34;: &#34;Compression&#34;,
    &#34;262&#34;: &#34;Photometric interpretation&#34;,
    &#34;266&#34;: &#34;Fill order&#34;,
    &#34;270&#34;: &#34;Image description&#34;,
    &#34;273&#34;: &#34;Strip offsets&#34;,
    &#34;274&#34;: &#34;Orientation&#34;,
    &#34;277&#34;: &#34;Samples per pixel&#34;,
    &#34;278&#34;: &#34;Rows per strip&#34;,
    &#34;279&#34;: &#34;Strip byte counts&#34;,
    &#34;282&#34;: &#34;Resolution X&#34;,
    &#34;283&#34;: &#34;Resolution Y&#34;,
    &#34;284&#34;: &#34;Planar configuration&#34;,
    &#34;296&#34;: &#34;Resolution unit&#34;,
    &#34;317&#34;: &#34;Predictor&#34;,
    &#34;320&#34;: &#34;Color map&#34;,
    &#34;339&#34;: &#34;Sample format&#34;
}

TIFFY_LOGLEVEL_ERROR   = 0
TIFFY_LOGLEVEL_WARNING = 10
TIFFY_LOGLEVEL_INFO    = 20
TIFFY_LOGLEVEL_DEBUG   = 30

tiffy_currentLogLevel = TIFFY_LOGLEVEL_ERROR

def tiffyLog(level, message):
    if level &lt; tiffy_currentLogLevel:
        print(message)


def getByteOrder(numpyArray):
    byteOrder = numpyArray.dtype.byteorder
    if byteOrder == &#34;=&#34;:  # native byte order
        if sys.byteorder == &#34;big&#34;:
            byteOrder = &#34;&gt;&#34;
        else:
            byteOrder = &#34;&lt;&#34;

    return byteOrder

def tagName(intTag):
    strTag = &#34;{}&#34;.format(intTag)
    if strTag in TAGNAMES:
        return TAGNAMES[strTag]
    else:
        return &#34;Unknown&#34;

def bytesPerTIFFtype(tp):
    if tp &gt; 0 and tp &lt;= len(TIFF_BYTES_PER_TYPE):
        return TIFF_BYTES_PER_TYPE[tp-1]

    raise Exception(&#34;Unknown TIFF data type: {}&#34;.format(tp))

def TIFFtypeStructCharacter(tp):
    if tp &gt; 0 and tp &lt;= len(TIFF_BYTES_PER_TYPE):
        return TIFF_STRUCT_CHAR_FOR_TYPE[tp-1]

    raise Exception(&#34;Unknown TIFF data type: {}&#34;.format(tp))

class bits:
    def __init__(self):
        self.data = bytearray()

    def set(self, n):
        &#34;&#34;&#34; Takes a number n and stores it in self.data in bitwise manner. &#34;&#34;&#34;
        self.data = bytearray()

        pos = 0
        while pos&gt;0:
            self.setBit(pos, n&amp;1)
            n = n &gt;&gt; 1
            pos += 1

    def __str__(self):
        &#34;&#34;&#34; Print in binary representation. &#34;&#34;&#34;
        maxPos = len(self.data)*8
        binString = &#34;&#34;

        pos = 0
        nChunks = 0
        nBytes = 0
        while pos &lt;= maxPos:
            if pos%9 == 0:
                binString = &#34;.&#34; + binString
                nChunks += 1
            if pos%8 == 0:
                binString = &#34;|&#34; + binString
                nBytes += 1

            binString = &#34;{}&#34;.format(self.getBit(pos)) + binString
            pos += 1

        binString += &#34;\n{} chunks in {} bytes.&#34;.format(nChunks, nBytes)
        return binString

    def setBytes(self, b):
        &#34;&#34;&#34; Takes a bytes object b and stores it in self.data. &#34;&#34;&#34;
        self.data = bytearray()
        self.data += b

    def reverseBitsInBytes(self):
        for i in range(len(self.data)):
            newByte = 0
            for b in range(8):
                newByte = newByte &lt;&lt; 1
                newByte += ((self.data[i] &gt;&gt; b) &amp; 1)
                
            self.data[i] = newByte

    &#34;&#34;&#34;
    def reverseBits(self, start, stop):
        newBits = bits()
        pos = 0
        for i in range(stopBit-1, startBit-1, -1):
            newBits.setBit(pos, self.getBit(i))
            pos += 1

        for i in range(startBit, stopBit):
            self.setBit(i, self.getBit(i-startBit))
    &#34;&#34;&#34;

    def byteAndBit(self, pos):
        &#34;&#34;&#34; From a given bit position, returns the byte index and the bit index within this byte. &#34;&#34;&#34;
        byteIdx = int(math.floor(pos/8))
        inByte = pos%8

        return byteIdx, inByte

    def getInt(self, startBit, stopBit):
        s = 0
        if startBit &lt; stopBit:
            for i in range(stopBit-1, startBit-1, -1):
                s = s &lt;&lt; 1
                s += self.getBit(i)

        return int(s)

    def getIntMSBtoLSB(self, startBit, stopBit):
        s = 0
        for i in range(startBit, stopBit):  # MSB to LSB
            s = s &lt;&lt; 1
            s += self.getBit(i)

        return s

    def getIntMSBtoLSB_inBytes(self, startByte, startBit, nBits):
        s = 0

        # Maximum of three masks required (for 9..12 bits)
        mask1 = mask &lt;&lt; startBit
        mask2 = 255 &lt;&lt; (nBits-7)
        mask3 = 255

        &#34;&#34;&#34;
        i = 0
        #print(&#34;StartByte: {}, StartBit: {}, nBits: {}&#34;.format(startByte, startBit, nBits))
        while i&lt;nBits:  # MSB to LSB
            s = s &lt;&lt; 1  # Shift left by 1
            s += ((self.data[startByte] &gt;&gt; (7-startBit)) &amp; 1)

            startBit += 1
            if startBit &gt; 7:
                startBit = 0
                startByte += 1

            i += 1
        &#34;&#34;&#34;

        startBit += nBits
        if startBit &gt; 7:
            startBit = 0
            startByte += 1

        return s, startByte+1, startBit+nBits

    def getIntMSBtoLSB_faster(self, startByte, rightZeros, mask0, mask1, mask2):
        s = ((self.data[startByte]&amp;mask0)&lt;&lt;16) + ((self.data[startByte+1]&amp;mask1)&lt;&lt;8) + (self.data[startByte+2]&amp;mask2)

        s = s &gt;&gt; rightZeros
        #newByte = 0
        #for b in range(9):
        #    newByte = newByte &lt;&lt; 1
        #    newByte += ((s &gt;&gt; b) &amp; 1)

        #return newByte

        return s

    def getBit(self, pos):
        byteIdx, inByte = self.byteAndBit(pos)

        if(byteIdx &gt;= len(self.data)):
            return 0

        return ((self.data[byteIdx] &gt;&gt; inByte) &amp; 1)

    def getBitInByte(self, byteIdx, bitPos):
        return ((self.data[byteIdx] &gt;&gt; bitPos) &amp; 1)

    def setBit(self, pos, value=1):
        byteIdx, inByte = self.byteAndBit(pos)

        while(byteIdx &gt; len(self.data)):
            self.data += bytes(1)

        mask = 1 &lt;&lt; inByte
        if value == 1:   # set bit
            self.data[byteIdx] = self.data[byteIdx] | mask
        else:  # clear bit
            self.data[byteIdx] = self.data[byteIdx] &amp; ~mask

    def setBitInByte(self, byteIdx, bitPos, value=1):
        while(byteIdx &gt; len(self.data)):
            self.data += bytes(1)

        mask = 1 &lt;&lt; bitPos
        if value == 1:   # set bit
            self.data[byteIdx] = self.data[byteIdx] | mask
        else:  # clear bit
            self.data[byteIdx] = self.data[byteIdx] &amp; ~mask       

class lzwStringTable:
    def __init__(self):
        self.byteStrings = []
        self.init()

    def init(self):
        self.byteStrings = []

        # Create all bytes:
        for i in range(256):
            self.byteStrings.append(bytearray(struct.pack(&#34;B&#34;, i)))

        self.byteStrings.append(bytearray())  # ClearCode: 256
        self.byteStrings.append(bytearray())  # EndOfInformation code: 257

    def currentCodeBitWidth(self):
        &#34;&#34;&#34;
        l = len(self.byteStrings) + 1
        bitWidth = 0
        while l != 0:
            l = l &gt;&gt; 1
            bitWidth += 1

        return bitWidth
        &#34;&#34;&#34;

        if len(self.byteStrings) &lt; 255:
            return 8
        elif len(self.byteStrings) &lt; 511:
            return 9
        elif len(self.byteStrings) &lt; 1023:
            return 10
        elif len(self.byteStrings) &lt; 2047:
            return 11
        elif len(self.byteStrings) &lt; 4095:
            return 12
        elif len(self.byteStrings) &lt; 8191:
            return 13
        elif len(self.byteStrings) &lt; 16383:
            return 14
        else:
            raise Exception(&#34;LZW: Dictionary is too big.&#34;)

    def contains(self, code):
        if code &lt; len(self.byteStrings):
            return True

        return False

    def add(self, b):
        self.byteStrings.append(b)

    def isClearCode(self, code):
        if code == 256:
            return True

        return False

    def isEndOfInformation(self, code):
        if code == 257:
            return True

        return False

    def stringFromCode(self, code, codeWidth):
        #if code &lt; 0:
        #    return bytearray()

        return self.byteStrings[code]

        &#34;&#34;&#34;
        if code &lt; len(self.byteStrings):
            #print(&#34;String from code {}: {}&#34;.format(code, self.byteStrings[code]))
            return self.byteStrings[code]
        else:
            raise Exception(&#34;LZW: Requested code #{} not in current string table. Current string table size: {}. Current bit width: {}&#34;.format(code, len(self.byteStrings), codeWidth))
        &#34;&#34;&#34;

class lzwData:
    def __init__(self):
        self.compressed = None
        self.umcompressed = None
        self.stringTable = lzwStringTable()

        self.currentBitPos = 0

        self.currentByteIdx = 0
        self.currentBitPosInByte  = 0  # in byte

        self.codeWidth = 9  # Starting with 9 bit wide codes

        self.masks = {} #[[[0]*3]*8]*14
        self.byteSkips = {} # [[0]*8]*14
        self.leftAlignOffsets = {}

        for codeWidth in range(9, 14):
            fundMask = 2**codeWidth - 1

            for shift in range(0, 8):   # Bitshift / startBit
                leftAlignOffset = 3*8 - codeWidth - shift

                mask = fundMask &lt;&lt; leftAlignOffset
                mask0 = (mask &gt;&gt; 16) &amp; 255  # 00000000 00000000 11111111
                mask1 = (mask &gt;&gt; 8) &amp; 255   # 00000000 11111111 00000000
                mask2 = (mask) &amp; 255        # 11111111 00000000 00000000

                self.masks[codeWidth,shift,0] = mask0
                self.masks[codeWidth,shift,1] = mask1
                self.masks[codeWidth,shift,2] = mask2

                self.byteSkips[codeWidth,shift] = int(math.ceil((codeWidth+shift+1)/8))-1
                self.leftAlignOffsets[codeWidth,shift] = leftAlignOffset

    def resetStringtable(self):
        self.stringTable.init()
        self.codeWidth = 9

    def setCompressed(self, compressed):
        self.compressed = bits()
        self.compressed.setBytes(compressed)
        self.compressed.data += bytes(3)   # for integer conversion

    def getNextCode(self):
        #s1 = self.currentBitPos
        #s2 = s1 + self.codeWidth

        #code = self.compressed.getIntMSBtoLSB(startBit=s1, stopBit=s2)
        #code, self.currentByteIdx, self.currentBitPosInByte = self.compressed.getIntMSBtoLSB_inBytes(startByte=self.currentByteIdx, startBit=self.currentBitPosInByte, nBits=self.codeWidth)

        startByte = self.currentByteIdx
        mask0=self.masks[self.codeWidth,self.currentBitPosInByte,0]
        mask1=self.masks[self.codeWidth,self.currentBitPosInByte,1]
        mask2=self.masks[self.codeWidth,self.currentBitPosInByte,2]

        code = self.compressed.getIntMSBtoLSB_faster(startByte=startByte, rightZeros=self.leftAlignOffsets[self.codeWidth,self.currentBitPosInByte], mask0=mask0, mask1=mask1, mask2=mask2)

        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Requesting {}({}). Skip: {} CodeWidth: {} Offset: {}  Masks: {:08b}.{:08b}.{:08b} -&gt; {}&#34;.format(startByte, self.currentBitPosInByte, self.byteSkips[self.codeWidth,self.currentBitPosInByte], self.codeWidth, self.currentBitPosInByte, mask0, mask1, mask2, code))

        self.currentByteIdx += self.byteSkips[self.codeWidth,self.currentBitPosInByte]
        self.currentBitPosInByte += self.codeWidth
        self.currentBitPosInByte = self.currentBitPosInByte % 8

        return code

    def decompress(self):
        self.uncompressed = bytearray()

        self.currentBitPos = 0
        oldCode = -1
        code = self.getNextCode()

        self.stringTable.init()  # If compressed data doesn&#39;t start with ClearCode

        while not self.stringTable.isEndOfInformation(code):
            if(self.stringTable.isClearCode(code)):
                self.resetStringtable()                

                code = self.getNextCode()
                if(self.stringTable.isEndOfInformation(code)):
                    break

                self.uncompressed += self.stringTable.stringFromCode(code, self.codeWidth)
                oldCode = code
            else:
                if self.stringTable.contains(code):
                    s = self.stringTable.stringFromCode(code, self.codeWidth)
                    self.uncompressed += s
                    self.stringTable.add(self.stringTable.stringFromCode(oldCode, self.codeWidth) + bytes([s[0]]))
                else:
                    s = self.stringTable.stringFromCode(oldCode, self.codeWidth)
                    outString = s + bytes([s[0]])
                    self.uncompressed += outString
                    self.stringTable.add(outString)

                oldCode = code

                self.codeWidth = self.stringTable.currentCodeBitWidth()

            code = self.getNextCode()


class ifdEntry:
    def __init__(self):
        self.tag      = 0  # TIFF Tag ID
        self.type     = 0  # Field Type
        self.count    = 0  # Number of values (NOT bytes)
        self.ifdEntryPos = 0

        self.values = []
        self.extraValuesOffset = 0   # storage offset (in byte) for any extra values that don&#39;t fit in the 4 values bytes of this IFD entry

    def set(self, tag, typ, values):
        self.setTagID(tag)
        self.setType(typ)
        self.setValues(values)

    def setTagID(self, tagid):
        self.tag = tagid

    def setType(self, typ):
        self.type = typ

    def setValue(self, value):
        if self.type in TIFF_INTTYPES:
            value = int(value)

        self.values = [value, ]
        self.count = 1

    def setValues(self, values):
        self.values = [0] * len(values)
     
        for i in range(len(self.values)):
            if self.type in TIFF_INTTYPES:
                self.values[i] = int(values[i])
            else:
                self.values[i] = values[i]

        self.count = len(values)

    def nValueBytes(self):
        return self.count * bytesPerTIFFtype(self.type)

    def read(self, offset, f, byteOrder):
        f.seek(offset)
        buff = f.read(8)
        (self.tag, self.type, self.count) = struct.unpack(&#34;{endian}HHL&#34;.format(endian=byteOrder), buff)

        # Calculate amount of bytes necessary for value(s):
        self.nValueBytes = self.nValueBytes()

        # Read value(s):
        f.seek(offset+8)
        buff = f.read(4)

        if self.nValueBytes &gt; 4:  # The field&#39;s actual value bytes must be read from the provided pointer.
            (valueOffset,) = struct.unpack(&#34;{endian}L&#34;.format(endian=byteOrder), buff)
            f.seek(valueOffset)
            buff = f.read(self.nValueBytes)
      
        # Prepare a struct pattern:
        structPattern = &#34;&#34;
        structCharacter = TIFFtypeStructCharacter(self.type)
        for i in range(self.count):
            structPattern += structCharacter

        # Fill rest of pattern with pad bytes:
        if self.nValueBytes &lt; 4:
            for j in range(4 - self.nValueBytes):
                structPattern += &#34;x&#34;

        tup = struct.unpack(&#34;{endian}{pattern}&#34;.format(endian=byteOrder, pattern=structPattern), buff)

        if self.type == TIFF_RATIONAL or self.type == TIFF_SRATIONAL:
            for numerator, denominator in zip(tup, tup[1:]):
                val = 0
                if denominator != 0:
                    val = numerator / denominator

                self.values.append(val)
        else:
            for val in tup:
                self.values.append(val)

        if len(self.values) &lt; 5:
            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- Tag {tag} ({tagname}): {n} value(s) {val}&#34;.format(tag=self.tag, tagname=tagName(self.tag), n=len(self.values), val=self.values))
        else:
            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- Tag {tag} ({tagname}): {n} value(s)&#34;.format(tag=self.tag, tagname=tagName(self.tag), n=len(self.values)))

    def getValue(self):
        if len(self.values) &gt; 0:
            return self.values[0]
        else:
            raise Exception(&#34;TIFF field with tag {tag} does not come with any value.&#34;.format(tag=self.tag))

    def sizeInBytes(self):
        size = 12
        size += self.sizeOfExtraValues()

        return size

    def sizeOfExtraValues(self):
        size = 0

        # If the values don&#39;t fit in the IFD entry, they are stored somewhere else:
        if (bytesPerTIFFtype(self.type)*len(self.values)) &gt; 4:
            size += bytesPerTIFFtype(self.type)*len(self.values)

        return size

    def printOffset(self):
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;    IFD entry, tag {t}  {offset}&#34;.format(t=self.tag, offset=self.ifdEntryPos))

    def printExtraDataOffset(self):
        if self.nValueBytes() &gt; 4:
            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;    IFD entry, tag {t}  {offset}  Extra Data&#34;.format(t=self.tag, offset=self.extraValuesOffset))

    def prepareDataOffsets(self, offset, extraDataOffset):
        self.ifdEntryPos = offset
        self.extraValuesOffset = extraDataOffset
        return (offset+12), (extraDataOffset + self.sizeOfExtraValues())

    def write(self, f, byteOrder):
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;IDF Entry at pos {}&#34;.format(f.tell()))
        buff = struct.pack(&#34;{endian}HHL&#34;.format(endian=byteOrder), self.tag, self.type, self.count)
        f.write(buff)

        if self.nValueBytes() &gt; 4:  # point to value storage offset
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}): Pointing to {offset}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, endian=byteOrder, offset=self.extraValuesOffset))
            buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), self.extraValuesOffset)
            f.write(buff)
        else:
            structChar = TIFFtypeStructCharacter(self.type)

            padding = 4 - self.nValueBytes()
            if padding &gt; 0:
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar}{padding}x {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, padding=padding, vals=self.values))
                buff = struct.pack(&#34;{endian}{count}{structchar}{padding}x&#34;.format(endian=byteOrder, count=self.count, structchar=structChar, padding=padding), *self.values)
                f.write(buff)
            else:
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar} {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, vals=self.values))
                buff = struct.pack(&#34;{endian}{count}{structchar}&#34;.format(endian=byteOrder, count=self.count, structchar=structChar), *self.values)
                f.write(buff)

    def writeExtraValues(self, f, byteOrder):
        structChar = TIFFtypeStructCharacter(self.type)
        if self.nValueBytes() &gt; 4:
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar} {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, vals=self.values))

            buff = struct.pack(&#34;{endian}{count}{structchar}&#34;.format(endian=byteOrder, count=self.count, structchar=structChar), *self.values)
            f.write(buff)


class ifd:
    def __init__(self):
        self.ifdPos = None
        self.fieldBytes = []
        self.fields = []
        self.fieldCount = 0
        self.nextIfdPos = 0

    def addEntry(self, entry):
        self.fields.append(entry)

    def read(self, ifdPos, f, byteOrder):
        self.ifdPos = ifdPos

        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- new IFD.&#34;)

        f.seek(ifdPos)
        buff = f.read(2)
        offset = ifdPos + 2
        (self.fieldCount,) = struct.unpack(&#34;{endian}H&#34;.format(endian=byteOrder), buff)
        
        for i in range(self.fieldCount):
            entry = ifdEntry()
            entry.read(offset, f, byteOrder)
            self.fields.append(entry)
            offset += 12

        f.seek(offset)
        buff = f.read(4)
        (self.nextIfdPos,) = struct.unpack(&#34;{endian}L&#34;.format(endian=byteOrder), buff)

    def sizeInBytes(self):
        size = 2 + 4  # Number of entries (2 bytes) + offset to next IFD (4 bytes)
        for field in self.fields:
            size += field.sizeInBytes()

        return size

    def prepareDataOffsets(self, offset):
        self.ifdPos = offset

        offset += 2  # number of entries (2 bytes)
        extraDataOffset = offset + 12*len(self.fields) + 4  # offset for each entry (12 bytes) + pointer to next IFD (4 bytes)

        for field in self.fields:
            offset, extraDataOffset = field.prepareDataOffsets(offset, extraDataOffset)

        return offset

    def printOffset(self):
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;+ IFD                   {offset} -&gt; {nextIFD}&#34;.format(offset=self.ifdPos, nextIFD=self.nextIfdPos))

        for entry in self.fields:
            entry.printOffset()

        for entry in self.fields:
            entry.printExtraDataOffset()

    def write(self, f, byteOrder):
        buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), len(self.fields))
        f.write(buff)

        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Written IFD. Now at position {}&#34;.format(f.tell()))

        # IFD entries:
        for entry in self.fields:
            entry.write(f, byteOrder)

        buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), self.nextIfdPos)
        f.write(buff)

        # extra data
        for entry in self.fields:
            entry.writeExtraValues(f, byteOrder)


class tiffSubfile:
    def __init__(self):
        self.px = []      # Array of numpy arrays to store image data (i.e. pixel values). One for each component/channel. Shape: (nChannel, nRows, nCols)
        self.imageDataOffset = 0  # Location of beginning of image data
        self.sampleFormat = [TIFF_SAMPLEFORMAT_UINT]  # Standard: uint

        self.filename = None
        self.byteOrder = &#34;&lt;&#34;  # little endian
        self.ifd = None

        self.photometricInterpretation = TIFF_BLACK_IS_ZERO
        self.compression = TIFF_NO_COMPRESSION
        self.predictor = TIFF_NO_PREDICTOR

        self.rows = 0
        self.cols = 0

        self.resolutionUnit = TIFF_RES_INCH
        self.resX = 0
        self.resY = 0

        self.rowsPerStrip = 0
        self.stripOffsets = []
        self.stripByteCounts = []

        self.bitsPerSample = (1,)        # Bilevel images do not define this, so make 1 bit/sample the default.
        self.samplesPerPixel = 1
        self.planarConfig = TIFF_CHUNKY  # Chunky (RGBRGBRGB...)
        self.orientation = 1
        self.colorMap = None             # For palette-color images

    def reset(self):
        self.__init__()

    def set(self, imageData, resX=0, resY=0):
        if len(imageData) &gt; 0:
            self.reset()
            self.px = imageData

            shp = numpy.shape(self.px)  # Shape must be 3-component tuple: (nChannels, height, width)
            if len(shp) == 3:
                self.samplesPerPixel = shp[0]
                self.rows = shp[1]
                self.cols = shp[2]

                self.rowsPerStrip = self.rows
                # self.stripByteCounts and self.stripOffsets will be set later by self.prepareDataOffsets()

                # Byte order
                self.byteOrder = getByteOrder(self.px)

                # Sample format
                if numpy.issubdtype(self.px.dtype, numpy.signedinteger):
                    self.sampleFormat = [TIFF_SAMPLEFORMAT_INT] * self.nChannels()
                elif numpy.issubdtype(self.px.dtype, numpy.unsignedinteger):
                    self.sampleFormat = [TIFF_SAMPLEFORMAT_UINT] * self.nChannels()
                elif numpy.issubdtype(self.px.dtype, numpy.floating):
                    self.sampleFormat = [TIFF_SAMPLEFORMAT_IEEEFP] * self.nChannels()
                else:
                    raise Exception(&#34;Unsupported dtype ({}) of provided image data. Must be an integer or floating point type.&#34;.format(numpy.dtype(self.px)))

                self.bitsPerSample  = [self.px.dtype.itemsize*8] * self.samplesPerPixel
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Setting bits per sample: {}&#34;.format(self.bitsPerSample))
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Setting sample format:   {}&#34;.format(self.sampleFormat))

                self.resolutionUnit = TIFF_RES_NONE
                self.resX = resX
                self.resY = resY

                self.compression    = TIFF_NO_COMPRESSION

                
                self.photometricInterpretation = TIFF_BLACK_IS_ZERO
                if self.nChannels() == 3:
                    self.photometricInterpretation = TIFF_RGB

                #if self.samplesPerPixel &gt; 1:
                #    self.planarConfig   = TIFF_PLANAR
                #else:
                #    self.planarConfig   = TIFF_CHUNKY
                self.planarConfig   = TIFF_CHUNKY

            else:
                raise Exception(&#34;Error setting image data. Please provide a numpy array of shape (nChannels, nRows, nColumns).&#34;)

    def addIFDentry_shortOrLong(self, tag, values):
        # find the right integer type for the provided values:
        m = max(values)
        typ = TIFF_LONG
        if m &lt; (2**16):
            typ = TIFF_SHORT

        self.addIFDentry(tag, typ, values)

    def addIFDentry(self, tag, typ, values):
        entry = ifdEntry()
        entry.set(tag, typ, values)
        self.ifd.addEntry(entry)

    def setupIFD(self):
        self.ifd = None
        self.ifd = ifd()

        self.addIFDentry_shortOrLong(256, (self.cols, ))                        # n columns
        self.addIFDentry_shortOrLong(257, (self.rows, ))                        # n rows
        self.addIFDentry(258, TIFF_SHORT, self.bitsPerSample)                   # bits per sample, already an array
        self.addIFDentry(259, TIFF_SHORT, (TIFF_NO_COMPRESSION, ))               # compression
        self.addIFDentry(262, TIFF_SHORT, (self.photometricInterpretation, ))   # photometric interpretation
        self.addIFDentry(266, TIFF_SHORT, (TIFF_MSB2LSB, ))                      # fill order 
        self.addIFDentry_shortOrLong(273, (self.imageDataOffset, ))             # offset location of strip
        self.addIFDentry(274, TIFF_SHORT, (self.orientation, ))                 # orientation
        self.addIFDentry(277, TIFF_SHORT, (self.samplesPerPixel, ))             # samples per pixel
        self.addIFDentry_shortOrLong(278, (self.rowsPerStrip, ))                # rows per strip
        self.addIFDentry_shortOrLong(279, (self.dataSizeInBytes(), ))            # strip byte counts
        # insert resolution entries here later...
        self.addIFDentry(284, TIFF_SHORT, (self.planarConfig, ))                # planar configuration
       
        #self.addIFDentry(296, TIFF_SHORT, (self.resolutionUnit, ))             # resolution unit
        
        if self.predictor != TIFF_NO_PREDICTOR:
            self.addIFDentry(317, TIFF_SHORT, (self.predictor, ))                   # predictor
        # color map
        
        self.addIFDentry(339, TIFF_SHORT, self.sampleFormat)                    # sample format, already an array

    def dataSizeInBytes(self):
        &#34;&#34;&#34; Size of pixel data (in bytes) &#34;&#34;&#34;
        size = 0
        for bitsPerSample in self.bitsPerSample:
            s = int(bitsPerSample * self.nPixels())
            size += s

        return size/8

    def sizeInBytes(self):
        size = 0
        if self.ifd != None:
            size += self.ifd.sizeInBytes()

        size += self.dataSizeInBytes()

        return size

    def prepareDataOffsets(self, offset):
        if self.ifd != None:
            self.ifd.prepareDataOffsets(offset)

            offset += self.ifd.sizeInBytes()
            self.imageDataOffset = offset  # image data starts here

            self.stripOffsets    = (self.imageDataOffset, )
            self.stripByteCounts = self.dataSizeInBytes()

            offset += self.dataSizeInBytes()
            return offset
        else:
            return 0

    def printOffset(self):
        if self.ifd != None:
            self.ifd.printOffset()

        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;  Image Data            {offset}&#34;.format(offset=self.imageDataOffset))

    def readMetaInformation(self, filename, byteOrder, imgFileDirectory):
        self.filename = filename
        self.byteOrder = byteOrder
        self.ifd = imgFileDirectory

        # Interpret IFD fields based on their TIFF tags:
        for field in self.ifd.fields:
            if field.tag == 256:  # Number of columns
                self.cols = field.getValue()
            elif field.tag == 257:  # Number of rows
                self.rows = field.getValue()
            elif field.tag == 258:  # Bits per sample
                self.bitsPerSample = field.values
            elif field.tag == 259:  # Compression
                self.compression = field.getValue()
                if self.compression == 0:
                    self.compression = TIFF_NO_COMPRESSION
            elif field.tag == 262:    # Photometric interpretation
                self.photometricInterpretation = field.getValue()
            elif field.tag == 273:  # Strip offsets
                self.stripOffsets = field.values
            elif field.tag == 274:  # Orientation
                self.orientation = field.getValue()
            elif field.tag == 277:  # Samples per pixel
                self.samplesPerPixel = field.getValue()
            elif field.tag == 278:  # Rows per strip
                self.rowsPerStrip = field.getValue()
            elif field.tag == 279:  # Strip byte counts
                self.stripByteCounts = field.values
            elif field.tag == 282:  # x resolution
                self.resX = field.getValue()
            elif field.tag == 283:  # y resolution
                self.resY = field.getValue()
            elif field.tag == 284:  # Planar configuration (order of pixel components)
                self.planarConfig = field.getValue()
            elif field.tag == 296:  # Resolution unit
                self.resolutionUnit = field.getValue()
            elif field.tag == 317:  # Predictor
                self.predictor = field.getValue()
            elif field.tag == 320:  # Color map
                pass # implement later...
            elif field.tag == 339:  # Sample format
                self.sampleFormat = field.values            

    def nChannels(self):
        return self.samplesPerPixel

    def nPixels(self):
        return self.rows*self.cols

    def bitsPerPixel(self):
        bits = 0
        for b in self.bitsPerSample:
            bits += b

        return bits

    def isPlanar(self):
        return (self.samplesPerPixel == 1 or self.planarConfig == TIFF_PLANAR)

    def isSet(self):
        &#34;&#34;&#34; Check if image has a valid width and height. &#34;&#34;&#34;
        if(self.getHeight() &gt; 0):
            if(self.getWidth() &gt; 0):
                return True

        return False

    def getWidth(self):
        return self.cols

    def getHeight(self):
        return self.rows

    def rot90(self):
        if self.isSet():
            self.px = numpy.rot90(self.px, k=1, axes=(1,2))
            self.cols, self.rows = self.rows, self.cols

    def rot180(self):
        if self.isSet():
            self.px = numpy.rot90(self.px, k=2, axes=(1,2))

    def rot270(self):
        if self.isSet():
            self.px = numpy.rot90(self.px, k=-1, axes=(1,2))
            self.cols, self.rows = self.rows, self.cols

    def rotate(self, rotation):
        if rotation == &#34;90&#34;:
            self.rot90()
        elif rotation == &#34;180&#34;:
            self.rot180()
        elif rotation == &#34;270&#34;:
            self.rot270()

    def flipHorizontal(self):
        if self.isSet():
            for i in range(self.nChannels()):
                self.px[i] = numpy.fliplr(self.px[i])

    def flipVertical(self):
        if self.isSet():
            for i in range(self.nChannels()):
                self.px[i] = numpy.flipud(self.px[i])

    def setFlip(self, horz=False, vert=False):
        self.flipHorz = horz
        self.flipVert = vert

    def getHorizontalFlip(self):
        return self.flipHorz

    def getVerticalFlip(self):
        return self.flipVert

    def flip(self, horizontal=False, vertical=False):
        if horizontal:
            self.flipHorizontal()
        if vertical:
            self.flipVertical()

    def numpyDatatype(self, sampleFormat, bitsPerSample):
        formatString = self.byteOrder
        if sampleFormat == TIFF_SAMPLEFORMAT_UINT:  # unsigned
            if bitsPerSample == 8:
                formatString = &#34;u1&#34;   # unsigned char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;u2&#34;   # unsigned short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;u4&#34;   # unsigned long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;u8&#34;   # unsigned long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_INT:  # signed
            if bitsPerSample == 8:
                formatString = &#34;i1&#34;   # signed char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;i2&#34;   # signed short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;i4&#34;   # signed long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;i8&#34;   # signed long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_IEEEFP:
            if bitsPerSample == 16:
                formatString += &#34;f2&#34;   # float 16 bit
            elif bitsPerSample == 32:
                formatString += &#34;f4&#34;   # float 32 bit
            elif bitsPerSample == 64:
                formatString += &#34;f8&#34;   # double 64 bit

        if len(formatString) &gt;= 1:
            return numpy.dtype(formatString)

        raise Exception(&#34;Unsupported data type: {bps} bits per sample for TIFF sample format {sf}.&#34;.format(bps=bitsPerSample, sf=sampleFormat))

    def structDataTypeString(self, sampleFormat, bitsPerSample):
        formatString = self.byteOrder
        if sampleFormat == TIFF_SAMPLEFORMAT_UINT:  # unsigned
            if bitsPerSample == 8:
                formatString = &#34;B&#34;   # unsigned char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;H&#34;   # unsigned short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;L&#34;   # unsigned long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;Q&#34;   # unsigned long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_INT:  # signed
            if bitsPerSample == 8:
                formatString = &#34;b&#34;   # signed char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;h&#34;   # signed short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;l&#34;   # signed long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;q&#34;   # signed long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_IEEEFP:
            if bitsPerSample == 16:
                formatString += &#34;e&#34;   # float 16 bit
            elif bitsPerSample == 32:
                formatString += &#34;f&#34;   # float 32 bit
            elif bitsPerSample == 64:
                formatString += &#34;d&#34;   # double 64 bit

        if len(formatString) &gt;= 1:
            return formatString

        raise Exception(&#34;Unsupported data type: {bps} bits per sample for TIFF sample format {sf}.&#34;.format(bps=bitsPerSample, sf=sampleFormat))

    def importFromUncompressedBuffer(self, pixelOffset, nPixels, datatype, channel, buff):
        if self.isPlanar():  # Buffer contains data just for one channel.
            self.px[channel][int(pixelOffset):int(pixelOffset+nPixels)] = numpy.frombuffer(buff, dtype=datatype)
        else: # CHUNKY configuration. channel is irrelevant here (and wrong.)
            bitsPerPixel = self.bitsPerPixel()
            bytesPerPixel = int(bitsPerPixel / 8)

            bytesPerSample = [x/8 for x in self.bitsPerSample]

            buff1d = numpy.frombuffer(buff, dtype=datatype)
            self.px[int(pixelOffset):int(pixelOffset+nPixels)] = numpy.reshape(buff1d, (nPixels, self.nChannels()))

            &#34;&#34;&#34;
            for pixel in range(nPixels):
                channelOffset = 0

                

                for c in range(self.samplesPerPixel):
                    # Current index in bytes
                    idxStart = int((pixel + pixelOffset)*bytesPerPixel + channelOffset/8)
                    idxStop  = int(idxStart + bytesPerSample[c])

                    #print(&#34;Start: {}, Stop: {}&#34;.format(idxStart, idxStop))

                    self.px[c][pixel] = numpy.frombuffer(buff[idxStart:idxStop], dtype=dt)

                    channelOffset += self.bitsPerSample[c]
            &#34;&#34;&#34;

    def imageData(self, obeyOrientation=True):
        # Read data into byte buffer:
        if len(self.stripOffsets) &gt; 0:
            if len(self.stripOffsets) == len(self.stripByteCounts):
                if os.path.isfile(self.filename):
                    with open(self.filename, &#34;rb&#34;) as f:
                        # Initialize nChannels x nPixels array for each channel:

                        # Check if bits per sample is the same for each channel:
                        if self.bitsPerSample.count(self.bitsPerSample[0]) == len(self.bitsPerSample) and self.sampleFormat.count(self.sampleFormat[0]) == len(self.sampleFormat):
                            sampleFormat  = self.sampleFormat[0]
                            bitsPerSample = self.bitsPerSample[0]

                            dt = self.numpyDatatype(sampleFormat, bitsPerSample)

                            if self.isPlanar():
                                self.px = numpy.zeros((self.nChannels(), self.nPixels()), dtype=dt)
                            else:
                                # Make array the shape of a chunky tiff configuration and reshape later...
                                self.px = numpy.zeros((self.nPixels(), self.nChannels()), dtype=dt)

                            nStrips = len(self.stripOffsets)

                            if self.compression == TIFF_NO_COMPRESSION or self.compression == TIFF_LZW_COMPRESSION:
                                pixel = 0
                                bitsPerPixel = self.bitsPerPixel()

                                c = 0  # channel id. Only necessary for PLANAR configuration.
                                nStripsPerChannel = int(nStrips / self.samplesPerPixel)

                                for i in range(nStrips):
                                    if self.samplesPerPixel &gt; 1:
                                        if self.planarConfig == TIFF_PLANAR:
                                            # Import next channel once all strips for one component channel have been imported.
                                            if (i % nStripsPerChannel) == 0:
                                                c += 1

                                    offset = self.stripOffsets[i]
                                    byteCount = self.stripByteCounts[i]  # byte count after compression

                                    #print(&#34;Strip #{}/{}, Byte Offset: {}, Byte Count: {}&#34;.format(i, nStrips, offset, byteCount))

                                    f.seek(offset)
                                    buff = f.read(byteCount)
                                    if self.compression == TIFF_LZW_COMPRESSION:
                                        compressed = lzwData()
                                        compressed.setCompressed(buff)

                                        #print(&#34;Decompressing LZW for strip {i}/{n}...&#34;.format(i=i, n=nStrips))
                                        compressed.decompress()
                                        buff = bytes(compressed.uncompressed)

                                    byteCount = len(buff)
                                    bitCount = 8*byteCount
                                    if not self.isPlanar(): # Standard is chunky, also for only 1 sample/pixel.
                                        pixelsInStrip = int(bitCount / bitsPerPixel)
                                    else:
                                        pixelsInStrip = int(bitCount / self.bitsPerSample[c])

                                    self.importFromUncompressedBuffer(
                                        pixelOffset = pixel,
                                        nPixels = pixelsInStrip,
                                        datatype = dt,
                                        channel = c,
                                        buff = buff)

                                    pixel += pixelsInStrip

                                tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;{} strips imported.&#34;.format(nStrips))
                            else:
                                raise Exception(&#34;TIFF: Compression scheme {} not supported.&#34;.format(self.compression))

                            f.close()

                            if not(self.isPlanar()):
                                # Chunky mode. Swap axes from (pixels, channels) to (channels, pixels):
                                self.px = numpy.swapaxes(self.px, 0, 1)

                            # Reshape components into 2D arrays:
                            if len(self.px) &gt; 0:
                                self.px = numpy.reshape(self.px, (self.nChannels(), self.rows, self.cols))

                            # Convert horizontal differences to absolute values:
                            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;Applying horizontal differencing...&#34;)
                            if self.predictor == TIFF_HORIZONTAL_DIFFERENCING:
                                for col in range(1, self.cols):
                                    self.px[...,col] = self.px[...,col-1] + self.px[...,col]

                            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;Orientation is: {}&#34;.format(self.orientation))
                            if obeyOrientation:
                                # Rotate back to orientation 1 ((0,0) is upper left)
                                if self.orientation == 2:     # (col0, row0) is (top, right)
                                    self.flip(horizontal=True, vertical=False)
                                elif self.orientation == 3:   # (col0, row0) is (bottom, right)
                                    self.flip(horizontal=True, vertical=True)
                                elif self.orientation == 4:   # (col0, row0) is bottom left
                                    self.flip(horizontal=False, vertical=True)
                                elif self.orientation == 5:   # (col0, row0) is (left, top)
                                    self.rotate(&#34;90&#34;)
                                    self.flip(horizontal=False, vertical=True)
                                elif self.orientation == 6:   # (col0, row0) is (right, top)
                                    self.rotate(&#34;270&#34;)
                                elif self.orientation == 7:   # (col0, row0) is (right, bottom)
                                    self.rotate(&#34;90&#34;)
                                    self.flip(horizontal=True, vertical=False)
                                elif self.orientation == 8:   # (col0, row0) is (left, bottom)
                                    self.rotate(&#34;90&#34;)

                                self.orientation = 1

                            return self.px
                        else:
                            f.close()
                            raise Exception(&#34;Unsupported TIFF format: all channels must have the same type and size. Sample format: {}, Bits per sample: {}&#34;.format(self.sampleFormat, self.bitsPerSample))                       

                raise Exception(&#34;File not available: {}&#34;.format(self.filename))
            else:
                raise Exception(&#34;Number of strip offsets ({nOffsets}) does not match number of strip byte counts ({nByteCounts}).&#34;.format(nOffsets=len(self.stripOffsets), nByteCounts=len(self.stripByteCounts)))
        else:
            raise Exception(&#34;No data strips found for requested subfile in {filename}.&#34;.format(filename=self.filename))

    def write(self, f, byteOrder):
        &#34;&#34;&#34; Expects an open, writable file pointer f. &#34;&#34;&#34;
        self.ifd.write(f, byteOrder)

        dataByteOrder = getByteOrder(self.px)
        if dataByteOrder != byteOrder:
            self.px.byteswap(inplace=True)

        # Write image data:
        if self.samplesPerPixel == 1:
            f.write(self.px)
        else:
            chunkyBytes = numpy.swapaxes(self.px, 0, 2)  # channel &lt;-&gt; cols  --&gt; (cols, rows, channel)
            chunkyBytes = numpy.swapaxes(chunkyBytes, 0, 1)  # cols &lt;-&gt; rows  --&gt; (rows, cols, channel)
            chunkyBytes.tofile(f, &#34;&#34;)

            &#34;&#34;&#34;
            dataString = []
            for c in range(self.nChannels()):
                dataString.append(self.structDataTypeString(self.sampleFormat[c], self.bitsPerSample[c]))

            for y in range(self.rows):
                for x in range(self.cols):
                    # Chunky style.
                    for c in range(self.nChannels()):
                        buff = struct.pack(&#34;{endian}{ds}&#34;.format(endian=byteOrder, ds=dataString[c]), self.px[c][y][x])
                        f.write(buff)
            &#34;&#34;&#34;

class tiff:
    def __init__(self):
        self.filename = None
        self.byteOrder = &#34;&lt;&#34;
        self.subfiles = []

    def reset(self):
        self.__init__()

    def read(self, filename=None):
        self.filename = filename

        if self.filename != None:
            if os.path.isfile(self.filename):
                filesize = os.path.getsize(self.filename)
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Size of {filename}: {size} Bytes.&#34;.format(filename=self.filename, size=filesize))

                if filesize &gt; 2:
                    with open(self.filename, &#34;rb&#34;) as f:
                        buff = f.read(2)
                        (tiffformat,) = struct.unpack(&#34;&lt;H&#34;, buff)  # Just read as little endian. It&#39;s symmetric, it doesn&#39;t matter.

                        self.byteOrder = &#34;&lt;&#34;   # little endian
                        if tiffformat == 0x4949:
                            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;II format. Little endian.&#34;)
                            self.byteOrder = &#34;&lt;&#34;
                        elif tiffformat == 0x4d4d:
                            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;MM format. Big endian.&#34;)
                            self.byteOrder = &#34;&gt;&#34;
                        else:
                            f.close()
                            raise Exception(&#34;Invalid byte order for first two bytes in TIFF header. Must be 0x4949 (II) or 0x4d4d (MM).&#34;)

                        buff = f.read(2)
                        (magicByte,) = struct.unpack(&#34;{endian}H&#34;.format(endian=self.byteOrder), buff)
                        if magicByte == 42:
                            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Magic Byte: {}&#34;.format(magicByte))
                        else:
                            raise Exception(&#34;TIFF magic byte is not 42: {}&#34;.format(self.filename))


                        # Get location of first image file directory (IFD):
                        buff = f.read(4)
                        (ifdPos,) = struct.unpack(&#34;{endian}L&#34;.format(endian=self.byteOrder), buff)

                        ifd0 = ifd()
                        ifd0.read(ifdPos, f, self.byteOrder)

                        self.subfiles = []
                        subfile0 = tiffSubfile()
                        subfile0.readMetaInformation(self.filename, self.byteOrder, ifd0)
                        self.subfiles.append(subfile0)

                        nextIfdPos = ifd0.nextIfdPos
                        while nextIfdPos != 0:
                            ifdn = ifd()
                            ifdn.read(nextIfdPos, f, self.byteOrder)
                            subfilen = tiffSubfile()
                            subfilen.readMetaInformation(self.filename, self.byteOrder, ifdn)
                            self.subfiles.append(subfilen)
                            nextIfdPos = ifdn.nextIfdPos

                        f.close()
                else:
                    raise Exception(&#34;TIFF file does not contain any data: {}&#34;.format(self.filename))
            else:
                raise Exception(&#34;File not found: {}&#34;.format(self.filename))

    def imageData(self, subfile=0, channel=None, obeyOrientation=True):
        if subfile &lt; len(self.subfiles):
            data = self.subfiles[subfile].imageData()
            if channel == None:
                return data
            else:
                return data[0]
        else:
            raise Exception(&#34;Subfile id not available: {}&#34;.format(subfile))

    def getNrSubfiles(self):
        &#34;&#34;&#34; Return number of subfiles. &#34;&#34;&#34;
        return len(self.subfiles)

    def getWidth(self, subfile=0):
        if subfile &lt; len(self.subfiles):
            return self.subfiles[subfile].getWidth()

    def getHeight(self, subfile=0):
        if subfile &lt; len(self.subfiles):
            return self.subfiles[subfile].getHeight()

    def sizeInBytes(self):
        size = 8  # TIFF header

        # Add size for each sub file:
        for sub in self.subfiles:
            size += sub.sizeInBytes()

        return size

    def prepareDataOffsets(self):
        offset = 8  # TIFF header
        for sub in self.subfiles:
            offset = sub.prepareDataOffsets(offset)

    def printOffset(self):
        self.prepareDataOffsets()
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;TIFF HEADER             0&#34;)
        for sub in self.subfiles:
            sub.printOffset()

    def set(self, imageData, resX=0, resY=0):
        self.reset()
        self.addImgData(imageData, resX, resY)

    def addImgData(self, imageData, resX=0, resY=0):
        if len(numpy.shape(imageData)) == 2:
            # We have to add another dimension for the channel...
            imageData = numpy.expand_dims(a=imageData, axis=0)

        if len(numpy.shape(imageData)) == 3:
            img = tiffSubfile()
            img.set(imageData, resX, resY)
            self.subfiles.append(img)

            # IFDs must be setup twice to ensure correct data offset pointers.
            for sub in self.subfiles:
                sub.setupIFD()
            self.prepareDataOffsets()
            for sub in self.subfiles:
                sub.setupIFD()
        else:
            raise Exception(&#34;TIFF: adding image data failed. Image data must be a numpy array of shape (height, width) or (channels, height, width).&#34;)

    def save(self, filename, endian=&#34;little&#34;):
        byteOrder = &#34;&lt;&#34; # little endian is default
        if endian == &#34;big&#34;:
            byteOrder = &#34;&gt;&#34;

        with open(filename, &#39;wb&#39;) as f:
            # Write the TIFF header.

            # Endian:
            if byteOrder == &#34;&gt;&#34;:
                buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 0x4d4d)
            else:
                buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 0x4949)
            f.write(buff)

            # Magic number:
            buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 42)
            f.write(buff)

            # The IFD0 always follows the header in our case:
            buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), 8)
            f.write(buff)

            for sub in self.subfiles:
                sub.write(f, byteOrder)
           
            f.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctsimu.tiffy.TIFFtypeStructCharacter"><code class="name flex">
<span>def <span class="ident">TIFFtypeStructCharacter</span></span>(<span>tp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TIFFtypeStructCharacter(tp):
    if tp &gt; 0 and tp &lt;= len(TIFF_BYTES_PER_TYPE):
        return TIFF_STRUCT_CHAR_FOR_TYPE[tp-1]

    raise Exception(&#34;Unknown TIFF data type: {}&#34;.format(tp))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bytesPerTIFFtype"><code class="name flex">
<span>def <span class="ident">bytesPerTIFFtype</span></span>(<span>tp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bytesPerTIFFtype(tp):
    if tp &gt; 0 and tp &lt;= len(TIFF_BYTES_PER_TYPE):
        return TIFF_BYTES_PER_TYPE[tp-1]

    raise Exception(&#34;Unknown TIFF data type: {}&#34;.format(tp))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.getByteOrder"><code class="name flex">
<span>def <span class="ident">getByteOrder</span></span>(<span>numpyArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getByteOrder(numpyArray):
    byteOrder = numpyArray.dtype.byteorder
    if byteOrder == &#34;=&#34;:  # native byte order
        if sys.byteorder == &#34;big&#34;:
            byteOrder = &#34;&gt;&#34;
        else:
            byteOrder = &#34;&lt;&#34;

    return byteOrder</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tagName"><code class="name flex">
<span>def <span class="ident">tagName</span></span>(<span>intTag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tagName(intTag):
    strTag = &#34;{}&#34;.format(intTag)
    if strTag in TAGNAMES:
        return TAGNAMES[strTag]
    else:
        return &#34;Unknown&#34;</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffyLog"><code class="name flex">
<span>def <span class="ident">tiffyLog</span></span>(<span>level, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tiffyLog(level, message):
    if level &lt; tiffy_currentLogLevel:
        print(message)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctsimu.tiffy.bits"><code class="flex name class">
<span>class <span class="ident">bits</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class bits:
    def __init__(self):
        self.data = bytearray()

    def set(self, n):
        &#34;&#34;&#34; Takes a number n and stores it in self.data in bitwise manner. &#34;&#34;&#34;
        self.data = bytearray()

        pos = 0
        while pos&gt;0:
            self.setBit(pos, n&amp;1)
            n = n &gt;&gt; 1
            pos += 1

    def __str__(self):
        &#34;&#34;&#34; Print in binary representation. &#34;&#34;&#34;
        maxPos = len(self.data)*8
        binString = &#34;&#34;

        pos = 0
        nChunks = 0
        nBytes = 0
        while pos &lt;= maxPos:
            if pos%9 == 0:
                binString = &#34;.&#34; + binString
                nChunks += 1
            if pos%8 == 0:
                binString = &#34;|&#34; + binString
                nBytes += 1

            binString = &#34;{}&#34;.format(self.getBit(pos)) + binString
            pos += 1

        binString += &#34;\n{} chunks in {} bytes.&#34;.format(nChunks, nBytes)
        return binString

    def setBytes(self, b):
        &#34;&#34;&#34; Takes a bytes object b and stores it in self.data. &#34;&#34;&#34;
        self.data = bytearray()
        self.data += b

    def reverseBitsInBytes(self):
        for i in range(len(self.data)):
            newByte = 0
            for b in range(8):
                newByte = newByte &lt;&lt; 1
                newByte += ((self.data[i] &gt;&gt; b) &amp; 1)
                
            self.data[i] = newByte

    &#34;&#34;&#34;
    def reverseBits(self, start, stop):
        newBits = bits()
        pos = 0
        for i in range(stopBit-1, startBit-1, -1):
            newBits.setBit(pos, self.getBit(i))
            pos += 1

        for i in range(startBit, stopBit):
            self.setBit(i, self.getBit(i-startBit))
    &#34;&#34;&#34;

    def byteAndBit(self, pos):
        &#34;&#34;&#34; From a given bit position, returns the byte index and the bit index within this byte. &#34;&#34;&#34;
        byteIdx = int(math.floor(pos/8))
        inByte = pos%8

        return byteIdx, inByte

    def getInt(self, startBit, stopBit):
        s = 0
        if startBit &lt; stopBit:
            for i in range(stopBit-1, startBit-1, -1):
                s = s &lt;&lt; 1
                s += self.getBit(i)

        return int(s)

    def getIntMSBtoLSB(self, startBit, stopBit):
        s = 0
        for i in range(startBit, stopBit):  # MSB to LSB
            s = s &lt;&lt; 1
            s += self.getBit(i)

        return s

    def getIntMSBtoLSB_inBytes(self, startByte, startBit, nBits):
        s = 0

        # Maximum of three masks required (for 9..12 bits)
        mask1 = mask &lt;&lt; startBit
        mask2 = 255 &lt;&lt; (nBits-7)
        mask3 = 255

        &#34;&#34;&#34;
        i = 0
        #print(&#34;StartByte: {}, StartBit: {}, nBits: {}&#34;.format(startByte, startBit, nBits))
        while i&lt;nBits:  # MSB to LSB
            s = s &lt;&lt; 1  # Shift left by 1
            s += ((self.data[startByte] &gt;&gt; (7-startBit)) &amp; 1)

            startBit += 1
            if startBit &gt; 7:
                startBit = 0
                startByte += 1

            i += 1
        &#34;&#34;&#34;

        startBit += nBits
        if startBit &gt; 7:
            startBit = 0
            startByte += 1

        return s, startByte+1, startBit+nBits

    def getIntMSBtoLSB_faster(self, startByte, rightZeros, mask0, mask1, mask2):
        s = ((self.data[startByte]&amp;mask0)&lt;&lt;16) + ((self.data[startByte+1]&amp;mask1)&lt;&lt;8) + (self.data[startByte+2]&amp;mask2)

        s = s &gt;&gt; rightZeros
        #newByte = 0
        #for b in range(9):
        #    newByte = newByte &lt;&lt; 1
        #    newByte += ((s &gt;&gt; b) &amp; 1)

        #return newByte

        return s

    def getBit(self, pos):
        byteIdx, inByte = self.byteAndBit(pos)

        if(byteIdx &gt;= len(self.data)):
            return 0

        return ((self.data[byteIdx] &gt;&gt; inByte) &amp; 1)

    def getBitInByte(self, byteIdx, bitPos):
        return ((self.data[byteIdx] &gt;&gt; bitPos) &amp; 1)

    def setBit(self, pos, value=1):
        byteIdx, inByte = self.byteAndBit(pos)

        while(byteIdx &gt; len(self.data)):
            self.data += bytes(1)

        mask = 1 &lt;&lt; inByte
        if value == 1:   # set bit
            self.data[byteIdx] = self.data[byteIdx] | mask
        else:  # clear bit
            self.data[byteIdx] = self.data[byteIdx] &amp; ~mask

    def setBitInByte(self, byteIdx, bitPos, value=1):
        while(byteIdx &gt; len(self.data)):
            self.data += bytes(1)

        mask = 1 &lt;&lt; bitPos
        if value == 1:   # set bit
            self.data[byteIdx] = self.data[byteIdx] | mask
        else:  # clear bit
            self.data[byteIdx] = self.data[byteIdx] &amp; ~mask       </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.tiffy.bits.byteAndBit"><code class="name flex">
<span>def <span class="ident">byteAndBit</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>From a given bit position, returns the byte index and the bit index within this byte.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byteAndBit(self, pos):
    &#34;&#34;&#34; From a given bit position, returns the byte index and the bit index within this byte. &#34;&#34;&#34;
    byteIdx = int(math.floor(pos/8))
    inByte = pos%8

    return byteIdx, inByte</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.getBit"><code class="name flex">
<span>def <span class="ident">getBit</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBit(self, pos):
    byteIdx, inByte = self.byteAndBit(pos)

    if(byteIdx &gt;= len(self.data)):
        return 0

    return ((self.data[byteIdx] &gt;&gt; inByte) &amp; 1)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.getBitInByte"><code class="name flex">
<span>def <span class="ident">getBitInByte</span></span>(<span>self, byteIdx, bitPos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBitInByte(self, byteIdx, bitPos):
    return ((self.data[byteIdx] &gt;&gt; bitPos) &amp; 1)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.getInt"><code class="name flex">
<span>def <span class="ident">getInt</span></span>(<span>self, startBit, stopBit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInt(self, startBit, stopBit):
    s = 0
    if startBit &lt; stopBit:
        for i in range(stopBit-1, startBit-1, -1):
            s = s &lt;&lt; 1
            s += self.getBit(i)

    return int(s)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.getIntMSBtoLSB"><code class="name flex">
<span>def <span class="ident">getIntMSBtoLSB</span></span>(<span>self, startBit, stopBit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIntMSBtoLSB(self, startBit, stopBit):
    s = 0
    for i in range(startBit, stopBit):  # MSB to LSB
        s = s &lt;&lt; 1
        s += self.getBit(i)

    return s</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.getIntMSBtoLSB_faster"><code class="name flex">
<span>def <span class="ident">getIntMSBtoLSB_faster</span></span>(<span>self, startByte, rightZeros, mask0, mask1, mask2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIntMSBtoLSB_faster(self, startByte, rightZeros, mask0, mask1, mask2):
    s = ((self.data[startByte]&amp;mask0)&lt;&lt;16) + ((self.data[startByte+1]&amp;mask1)&lt;&lt;8) + (self.data[startByte+2]&amp;mask2)

    s = s &gt;&gt; rightZeros
    #newByte = 0
    #for b in range(9):
    #    newByte = newByte &lt;&lt; 1
    #    newByte += ((s &gt;&gt; b) &amp; 1)

    #return newByte

    return s</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.getIntMSBtoLSB_inBytes"><code class="name flex">
<span>def <span class="ident">getIntMSBtoLSB_inBytes</span></span>(<span>self, startByte, startBit, nBits)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIntMSBtoLSB_inBytes(self, startByte, startBit, nBits):
    s = 0

    # Maximum of three masks required (for 9..12 bits)
    mask1 = mask &lt;&lt; startBit
    mask2 = 255 &lt;&lt; (nBits-7)
    mask3 = 255

    &#34;&#34;&#34;
    i = 0
    #print(&#34;StartByte: {}, StartBit: {}, nBits: {}&#34;.format(startByte, startBit, nBits))
    while i&lt;nBits:  # MSB to LSB
        s = s &lt;&lt; 1  # Shift left by 1
        s += ((self.data[startByte] &gt;&gt; (7-startBit)) &amp; 1)

        startBit += 1
        if startBit &gt; 7:
            startBit = 0
            startByte += 1

        i += 1
    &#34;&#34;&#34;

    startBit += nBits
    if startBit &gt; 7:
        startBit = 0
        startByte += 1

    return s, startByte+1, startBit+nBits</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.reverseBitsInBytes"><code class="name flex">
<span>def <span class="ident">reverseBitsInBytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverseBitsInBytes(self):
    for i in range(len(self.data)):
        newByte = 0
        for b in range(8):
            newByte = newByte &lt;&lt; 1
            newByte += ((self.data[i] &gt;&gt; b) &amp; 1)
            
        self.data[i] = newByte</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a number n and stores it in self.data in bitwise manner.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, n):
    &#34;&#34;&#34; Takes a number n and stores it in self.data in bitwise manner. &#34;&#34;&#34;
    self.data = bytearray()

    pos = 0
    while pos&gt;0:
        self.setBit(pos, n&amp;1)
        n = n &gt;&gt; 1
        pos += 1</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.setBit"><code class="name flex">
<span>def <span class="ident">setBit</span></span>(<span>self, pos, value=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBit(self, pos, value=1):
    byteIdx, inByte = self.byteAndBit(pos)

    while(byteIdx &gt; len(self.data)):
        self.data += bytes(1)

    mask = 1 &lt;&lt; inByte
    if value == 1:   # set bit
        self.data[byteIdx] = self.data[byteIdx] | mask
    else:  # clear bit
        self.data[byteIdx] = self.data[byteIdx] &amp; ~mask</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.setBitInByte"><code class="name flex">
<span>def <span class="ident">setBitInByte</span></span>(<span>self, byteIdx, bitPos, value=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBitInByte(self, byteIdx, bitPos, value=1):
    while(byteIdx &gt; len(self.data)):
        self.data += bytes(1)

    mask = 1 &lt;&lt; bitPos
    if value == 1:   # set bit
        self.data[byteIdx] = self.data[byteIdx] | mask
    else:  # clear bit
        self.data[byteIdx] = self.data[byteIdx] &amp; ~mask       </code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.bits.setBytes"><code class="name flex">
<span>def <span class="ident">setBytes</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a bytes object b and stores it in self.data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBytes(self, b):
    &#34;&#34;&#34; Takes a bytes object b and stores it in self.data. &#34;&#34;&#34;
    self.data = bytearray()
    self.data += b</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.tiffy.ifd"><code class="flex name class">
<span>class <span class="ident">ifd</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ifd:
    def __init__(self):
        self.ifdPos = None
        self.fieldBytes = []
        self.fields = []
        self.fieldCount = 0
        self.nextIfdPos = 0

    def addEntry(self, entry):
        self.fields.append(entry)

    def read(self, ifdPos, f, byteOrder):
        self.ifdPos = ifdPos

        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- new IFD.&#34;)

        f.seek(ifdPos)
        buff = f.read(2)
        offset = ifdPos + 2
        (self.fieldCount,) = struct.unpack(&#34;{endian}H&#34;.format(endian=byteOrder), buff)
        
        for i in range(self.fieldCount):
            entry = ifdEntry()
            entry.read(offset, f, byteOrder)
            self.fields.append(entry)
            offset += 12

        f.seek(offset)
        buff = f.read(4)
        (self.nextIfdPos,) = struct.unpack(&#34;{endian}L&#34;.format(endian=byteOrder), buff)

    def sizeInBytes(self):
        size = 2 + 4  # Number of entries (2 bytes) + offset to next IFD (4 bytes)
        for field in self.fields:
            size += field.sizeInBytes()

        return size

    def prepareDataOffsets(self, offset):
        self.ifdPos = offset

        offset += 2  # number of entries (2 bytes)
        extraDataOffset = offset + 12*len(self.fields) + 4  # offset for each entry (12 bytes) + pointer to next IFD (4 bytes)

        for field in self.fields:
            offset, extraDataOffset = field.prepareDataOffsets(offset, extraDataOffset)

        return offset

    def printOffset(self):
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;+ IFD                   {offset} -&gt; {nextIFD}&#34;.format(offset=self.ifdPos, nextIFD=self.nextIfdPos))

        for entry in self.fields:
            entry.printOffset()

        for entry in self.fields:
            entry.printExtraDataOffset()

    def write(self, f, byteOrder):
        buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), len(self.fields))
        f.write(buff)

        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Written IFD. Now at position {}&#34;.format(f.tell()))

        # IFD entries:
        for entry in self.fields:
            entry.write(f, byteOrder)

        buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), self.nextIfdPos)
        f.write(buff)

        # extra data
        for entry in self.fields:
            entry.writeExtraValues(f, byteOrder)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.tiffy.ifd.addEntry"><code class="name flex">
<span>def <span class="ident">addEntry</span></span>(<span>self, entry)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addEntry(self, entry):
    self.fields.append(entry)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifd.prepareDataOffsets"><code class="name flex">
<span>def <span class="ident">prepareDataOffsets</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepareDataOffsets(self, offset):
    self.ifdPos = offset

    offset += 2  # number of entries (2 bytes)
    extraDataOffset = offset + 12*len(self.fields) + 4  # offset for each entry (12 bytes) + pointer to next IFD (4 bytes)

    for field in self.fields:
        offset, extraDataOffset = field.prepareDataOffsets(offset, extraDataOffset)

    return offset</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifd.printOffset"><code class="name flex">
<span>def <span class="ident">printOffset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printOffset(self):
    tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;+ IFD                   {offset} -&gt; {nextIFD}&#34;.format(offset=self.ifdPos, nextIFD=self.nextIfdPos))

    for entry in self.fields:
        entry.printOffset()

    for entry in self.fields:
        entry.printExtraDataOffset()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifd.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, ifdPos, f, byteOrder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, ifdPos, f, byteOrder):
    self.ifdPos = ifdPos

    tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- new IFD.&#34;)

    f.seek(ifdPos)
    buff = f.read(2)
    offset = ifdPos + 2
    (self.fieldCount,) = struct.unpack(&#34;{endian}H&#34;.format(endian=byteOrder), buff)
    
    for i in range(self.fieldCount):
        entry = ifdEntry()
        entry.read(offset, f, byteOrder)
        self.fields.append(entry)
        offset += 12

    f.seek(offset)
    buff = f.read(4)
    (self.nextIfdPos,) = struct.unpack(&#34;{endian}L&#34;.format(endian=byteOrder), buff)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifd.sizeInBytes"><code class="name flex">
<span>def <span class="ident">sizeInBytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sizeInBytes(self):
    size = 2 + 4  # Number of entries (2 bytes) + offset to next IFD (4 bytes)
    for field in self.fields:
        size += field.sizeInBytes()

    return size</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifd.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, f, byteOrder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, f, byteOrder):
    buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), len(self.fields))
    f.write(buff)

    tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Written IFD. Now at position {}&#34;.format(f.tell()))

    # IFD entries:
    for entry in self.fields:
        entry.write(f, byteOrder)

    buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), self.nextIfdPos)
    f.write(buff)

    # extra data
    for entry in self.fields:
        entry.writeExtraValues(f, byteOrder)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.tiffy.ifdEntry"><code class="flex name class">
<span>class <span class="ident">ifdEntry</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ifdEntry:
    def __init__(self):
        self.tag      = 0  # TIFF Tag ID
        self.type     = 0  # Field Type
        self.count    = 0  # Number of values (NOT bytes)
        self.ifdEntryPos = 0

        self.values = []
        self.extraValuesOffset = 0   # storage offset (in byte) for any extra values that don&#39;t fit in the 4 values bytes of this IFD entry

    def set(self, tag, typ, values):
        self.setTagID(tag)
        self.setType(typ)
        self.setValues(values)

    def setTagID(self, tagid):
        self.tag = tagid

    def setType(self, typ):
        self.type = typ

    def setValue(self, value):
        if self.type in TIFF_INTTYPES:
            value = int(value)

        self.values = [value, ]
        self.count = 1

    def setValues(self, values):
        self.values = [0] * len(values)
     
        for i in range(len(self.values)):
            if self.type in TIFF_INTTYPES:
                self.values[i] = int(values[i])
            else:
                self.values[i] = values[i]

        self.count = len(values)

    def nValueBytes(self):
        return self.count * bytesPerTIFFtype(self.type)

    def read(self, offset, f, byteOrder):
        f.seek(offset)
        buff = f.read(8)
        (self.tag, self.type, self.count) = struct.unpack(&#34;{endian}HHL&#34;.format(endian=byteOrder), buff)

        # Calculate amount of bytes necessary for value(s):
        self.nValueBytes = self.nValueBytes()

        # Read value(s):
        f.seek(offset+8)
        buff = f.read(4)

        if self.nValueBytes &gt; 4:  # The field&#39;s actual value bytes must be read from the provided pointer.
            (valueOffset,) = struct.unpack(&#34;{endian}L&#34;.format(endian=byteOrder), buff)
            f.seek(valueOffset)
            buff = f.read(self.nValueBytes)
      
        # Prepare a struct pattern:
        structPattern = &#34;&#34;
        structCharacter = TIFFtypeStructCharacter(self.type)
        for i in range(self.count):
            structPattern += structCharacter

        # Fill rest of pattern with pad bytes:
        if self.nValueBytes &lt; 4:
            for j in range(4 - self.nValueBytes):
                structPattern += &#34;x&#34;

        tup = struct.unpack(&#34;{endian}{pattern}&#34;.format(endian=byteOrder, pattern=structPattern), buff)

        if self.type == TIFF_RATIONAL or self.type == TIFF_SRATIONAL:
            for numerator, denominator in zip(tup, tup[1:]):
                val = 0
                if denominator != 0:
                    val = numerator / denominator

                self.values.append(val)
        else:
            for val in tup:
                self.values.append(val)

        if len(self.values) &lt; 5:
            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- Tag {tag} ({tagname}): {n} value(s) {val}&#34;.format(tag=self.tag, tagname=tagName(self.tag), n=len(self.values), val=self.values))
        else:
            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- Tag {tag} ({tagname}): {n} value(s)&#34;.format(tag=self.tag, tagname=tagName(self.tag), n=len(self.values)))

    def getValue(self):
        if len(self.values) &gt; 0:
            return self.values[0]
        else:
            raise Exception(&#34;TIFF field with tag {tag} does not come with any value.&#34;.format(tag=self.tag))

    def sizeInBytes(self):
        size = 12
        size += self.sizeOfExtraValues()

        return size

    def sizeOfExtraValues(self):
        size = 0

        # If the values don&#39;t fit in the IFD entry, they are stored somewhere else:
        if (bytesPerTIFFtype(self.type)*len(self.values)) &gt; 4:
            size += bytesPerTIFFtype(self.type)*len(self.values)

        return size

    def printOffset(self):
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;    IFD entry, tag {t}  {offset}&#34;.format(t=self.tag, offset=self.ifdEntryPos))

    def printExtraDataOffset(self):
        if self.nValueBytes() &gt; 4:
            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;    IFD entry, tag {t}  {offset}  Extra Data&#34;.format(t=self.tag, offset=self.extraValuesOffset))

    def prepareDataOffsets(self, offset, extraDataOffset):
        self.ifdEntryPos = offset
        self.extraValuesOffset = extraDataOffset
        return (offset+12), (extraDataOffset + self.sizeOfExtraValues())

    def write(self, f, byteOrder):
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;IDF Entry at pos {}&#34;.format(f.tell()))
        buff = struct.pack(&#34;{endian}HHL&#34;.format(endian=byteOrder), self.tag, self.type, self.count)
        f.write(buff)

        if self.nValueBytes() &gt; 4:  # point to value storage offset
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}): Pointing to {offset}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, endian=byteOrder, offset=self.extraValuesOffset))
            buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), self.extraValuesOffset)
            f.write(buff)
        else:
            structChar = TIFFtypeStructCharacter(self.type)

            padding = 4 - self.nValueBytes()
            if padding &gt; 0:
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar}{padding}x {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, padding=padding, vals=self.values))
                buff = struct.pack(&#34;{endian}{count}{structchar}{padding}x&#34;.format(endian=byteOrder, count=self.count, structchar=structChar, padding=padding), *self.values)
                f.write(buff)
            else:
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar} {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, vals=self.values))
                buff = struct.pack(&#34;{endian}{count}{structchar}&#34;.format(endian=byteOrder, count=self.count, structchar=structChar), *self.values)
                f.write(buff)

    def writeExtraValues(self, f, byteOrder):
        structChar = TIFFtypeStructCharacter(self.type)
        if self.nValueBytes() &gt; 4:
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar} {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, vals=self.values))

            buff = struct.pack(&#34;{endian}{count}{structchar}&#34;.format(endian=byteOrder, count=self.count, structchar=structChar), *self.values)
            f.write(buff)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.tiffy.ifdEntry.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValue(self):
    if len(self.values) &gt; 0:
        return self.values[0]
    else:
        raise Exception(&#34;TIFF field with tag {tag} does not come with any value.&#34;.format(tag=self.tag))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.nValueBytes"><code class="name flex">
<span>def <span class="ident">nValueBytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nValueBytes(self):
    return self.count * bytesPerTIFFtype(self.type)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.prepareDataOffsets"><code class="name flex">
<span>def <span class="ident">prepareDataOffsets</span></span>(<span>self, offset, extraDataOffset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepareDataOffsets(self, offset, extraDataOffset):
    self.ifdEntryPos = offset
    self.extraValuesOffset = extraDataOffset
    return (offset+12), (extraDataOffset + self.sizeOfExtraValues())</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.printExtraDataOffset"><code class="name flex">
<span>def <span class="ident">printExtraDataOffset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printExtraDataOffset(self):
    if self.nValueBytes() &gt; 4:
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;    IFD entry, tag {t}  {offset}  Extra Data&#34;.format(t=self.tag, offset=self.extraValuesOffset))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.printOffset"><code class="name flex">
<span>def <span class="ident">printOffset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printOffset(self):
    tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;    IFD entry, tag {t}  {offset}&#34;.format(t=self.tag, offset=self.ifdEntryPos))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, offset, f, byteOrder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, offset, f, byteOrder):
    f.seek(offset)
    buff = f.read(8)
    (self.tag, self.type, self.count) = struct.unpack(&#34;{endian}HHL&#34;.format(endian=byteOrder), buff)

    # Calculate amount of bytes necessary for value(s):
    self.nValueBytes = self.nValueBytes()

    # Read value(s):
    f.seek(offset+8)
    buff = f.read(4)

    if self.nValueBytes &gt; 4:  # The field&#39;s actual value bytes must be read from the provided pointer.
        (valueOffset,) = struct.unpack(&#34;{endian}L&#34;.format(endian=byteOrder), buff)
        f.seek(valueOffset)
        buff = f.read(self.nValueBytes)
  
    # Prepare a struct pattern:
    structPattern = &#34;&#34;
    structCharacter = TIFFtypeStructCharacter(self.type)
    for i in range(self.count):
        structPattern += structCharacter

    # Fill rest of pattern with pad bytes:
    if self.nValueBytes &lt; 4:
        for j in range(4 - self.nValueBytes):
            structPattern += &#34;x&#34;

    tup = struct.unpack(&#34;{endian}{pattern}&#34;.format(endian=byteOrder, pattern=structPattern), buff)

    if self.type == TIFF_RATIONAL or self.type == TIFF_SRATIONAL:
        for numerator, denominator in zip(tup, tup[1:]):
            val = 0
            if denominator != 0:
                val = numerator / denominator

            self.values.append(val)
    else:
        for val in tup:
            self.values.append(val)

    if len(self.values) &lt; 5:
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- Tag {tag} ({tagname}): {n} value(s) {val}&#34;.format(tag=self.tag, tagname=tagName(self.tag), n=len(self.values), val=self.values))
    else:
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34; -- Tag {tag} ({tagname}): {n} value(s)&#34;.format(tag=self.tag, tagname=tagName(self.tag), n=len(self.values)))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, tag, typ, values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, tag, typ, values):
    self.setTagID(tag)
    self.setType(typ)
    self.setValues(values)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.setTagID"><code class="name flex">
<span>def <span class="ident">setTagID</span></span>(<span>self, tagid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTagID(self, tagid):
    self.tag = tagid</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.setType"><code class="name flex">
<span>def <span class="ident">setType</span></span>(<span>self, typ)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setType(self, typ):
    self.type = typ</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.setValue"><code class="name flex">
<span>def <span class="ident">setValue</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setValue(self, value):
    if self.type in TIFF_INTTYPES:
        value = int(value)

    self.values = [value, ]
    self.count = 1</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.setValues"><code class="name flex">
<span>def <span class="ident">setValues</span></span>(<span>self, values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setValues(self, values):
    self.values = [0] * len(values)
 
    for i in range(len(self.values)):
        if self.type in TIFF_INTTYPES:
            self.values[i] = int(values[i])
        else:
            self.values[i] = values[i]

    self.count = len(values)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.sizeInBytes"><code class="name flex">
<span>def <span class="ident">sizeInBytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sizeInBytes(self):
    size = 12
    size += self.sizeOfExtraValues()

    return size</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.sizeOfExtraValues"><code class="name flex">
<span>def <span class="ident">sizeOfExtraValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sizeOfExtraValues(self):
    size = 0

    # If the values don&#39;t fit in the IFD entry, they are stored somewhere else:
    if (bytesPerTIFFtype(self.type)*len(self.values)) &gt; 4:
        size += bytesPerTIFFtype(self.type)*len(self.values)

    return size</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, f, byteOrder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, f, byteOrder):
    tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;IDF Entry at pos {}&#34;.format(f.tell()))
    buff = struct.pack(&#34;{endian}HHL&#34;.format(endian=byteOrder), self.tag, self.type, self.count)
    f.write(buff)

    if self.nValueBytes() &gt; 4:  # point to value storage offset
        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}): Pointing to {offset}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, endian=byteOrder, offset=self.extraValuesOffset))
        buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), self.extraValuesOffset)
        f.write(buff)
    else:
        structChar = TIFFtypeStructCharacter(self.type)

        padding = 4 - self.nValueBytes()
        if padding &gt; 0:
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar}{padding}x {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, padding=padding, vals=self.values))
            buff = struct.pack(&#34;{endian}{count}{structchar}{padding}x&#34;.format(endian=byteOrder, count=self.count, structchar=structChar, padding=padding), *self.values)
            f.write(buff)
        else:
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar} {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, vals=self.values))
            buff = struct.pack(&#34;{endian}{count}{structchar}&#34;.format(endian=byteOrder, count=self.count, structchar=structChar), *self.values)
            f.write(buff)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.ifdEntry.writeExtraValues"><code class="name flex">
<span>def <span class="ident">writeExtraValues</span></span>(<span>self, f, byteOrder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeExtraValues(self, f, byteOrder):
    structChar = TIFFtypeStructCharacter(self.type)
    if self.nValueBytes() &gt; 4:
        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Packing for tag {tag} (type {typ}, count {cnt}) at pos {pos}: {endian}{count}{structchar} {vals}&#34;.format(tag=self.tag, typ=self.type, cnt=self.count, pos=f.tell(), endian=byteOrder, count=self.count, structchar=structChar, vals=self.values))

        buff = struct.pack(&#34;{endian}{count}{structchar}&#34;.format(endian=byteOrder, count=self.count, structchar=structChar), *self.values)
        f.write(buff)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.tiffy.lzwData"><code class="flex name class">
<span>class <span class="ident">lzwData</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class lzwData:
    def __init__(self):
        self.compressed = None
        self.umcompressed = None
        self.stringTable = lzwStringTable()

        self.currentBitPos = 0

        self.currentByteIdx = 0
        self.currentBitPosInByte  = 0  # in byte

        self.codeWidth = 9  # Starting with 9 bit wide codes

        self.masks = {} #[[[0]*3]*8]*14
        self.byteSkips = {} # [[0]*8]*14
        self.leftAlignOffsets = {}

        for codeWidth in range(9, 14):
            fundMask = 2**codeWidth - 1

            for shift in range(0, 8):   # Bitshift / startBit
                leftAlignOffset = 3*8 - codeWidth - shift

                mask = fundMask &lt;&lt; leftAlignOffset
                mask0 = (mask &gt;&gt; 16) &amp; 255  # 00000000 00000000 11111111
                mask1 = (mask &gt;&gt; 8) &amp; 255   # 00000000 11111111 00000000
                mask2 = (mask) &amp; 255        # 11111111 00000000 00000000

                self.masks[codeWidth,shift,0] = mask0
                self.masks[codeWidth,shift,1] = mask1
                self.masks[codeWidth,shift,2] = mask2

                self.byteSkips[codeWidth,shift] = int(math.ceil((codeWidth+shift+1)/8))-1
                self.leftAlignOffsets[codeWidth,shift] = leftAlignOffset

    def resetStringtable(self):
        self.stringTable.init()
        self.codeWidth = 9

    def setCompressed(self, compressed):
        self.compressed = bits()
        self.compressed.setBytes(compressed)
        self.compressed.data += bytes(3)   # for integer conversion

    def getNextCode(self):
        #s1 = self.currentBitPos
        #s2 = s1 + self.codeWidth

        #code = self.compressed.getIntMSBtoLSB(startBit=s1, stopBit=s2)
        #code, self.currentByteIdx, self.currentBitPosInByte = self.compressed.getIntMSBtoLSB_inBytes(startByte=self.currentByteIdx, startBit=self.currentBitPosInByte, nBits=self.codeWidth)

        startByte = self.currentByteIdx
        mask0=self.masks[self.codeWidth,self.currentBitPosInByte,0]
        mask1=self.masks[self.codeWidth,self.currentBitPosInByte,1]
        mask2=self.masks[self.codeWidth,self.currentBitPosInByte,2]

        code = self.compressed.getIntMSBtoLSB_faster(startByte=startByte, rightZeros=self.leftAlignOffsets[self.codeWidth,self.currentBitPosInByte], mask0=mask0, mask1=mask1, mask2=mask2)

        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Requesting {}({}). Skip: {} CodeWidth: {} Offset: {}  Masks: {:08b}.{:08b}.{:08b} -&gt; {}&#34;.format(startByte, self.currentBitPosInByte, self.byteSkips[self.codeWidth,self.currentBitPosInByte], self.codeWidth, self.currentBitPosInByte, mask0, mask1, mask2, code))

        self.currentByteIdx += self.byteSkips[self.codeWidth,self.currentBitPosInByte]
        self.currentBitPosInByte += self.codeWidth
        self.currentBitPosInByte = self.currentBitPosInByte % 8

        return code

    def decompress(self):
        self.uncompressed = bytearray()

        self.currentBitPos = 0
        oldCode = -1
        code = self.getNextCode()

        self.stringTable.init()  # If compressed data doesn&#39;t start with ClearCode

        while not self.stringTable.isEndOfInformation(code):
            if(self.stringTable.isClearCode(code)):
                self.resetStringtable()                

                code = self.getNextCode()
                if(self.stringTable.isEndOfInformation(code)):
                    break

                self.uncompressed += self.stringTable.stringFromCode(code, self.codeWidth)
                oldCode = code
            else:
                if self.stringTable.contains(code):
                    s = self.stringTable.stringFromCode(code, self.codeWidth)
                    self.uncompressed += s
                    self.stringTable.add(self.stringTable.stringFromCode(oldCode, self.codeWidth) + bytes([s[0]]))
                else:
                    s = self.stringTable.stringFromCode(oldCode, self.codeWidth)
                    outString = s + bytes([s[0]])
                    self.uncompressed += outString
                    self.stringTable.add(outString)

                oldCode = code

                self.codeWidth = self.stringTable.currentCodeBitWidth()

            code = self.getNextCode()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.tiffy.lzwData.decompress"><code class="name flex">
<span>def <span class="ident">decompress</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompress(self):
    self.uncompressed = bytearray()

    self.currentBitPos = 0
    oldCode = -1
    code = self.getNextCode()

    self.stringTable.init()  # If compressed data doesn&#39;t start with ClearCode

    while not self.stringTable.isEndOfInformation(code):
        if(self.stringTable.isClearCode(code)):
            self.resetStringtable()                

            code = self.getNextCode()
            if(self.stringTable.isEndOfInformation(code)):
                break

            self.uncompressed += self.stringTable.stringFromCode(code, self.codeWidth)
            oldCode = code
        else:
            if self.stringTable.contains(code):
                s = self.stringTable.stringFromCode(code, self.codeWidth)
                self.uncompressed += s
                self.stringTable.add(self.stringTable.stringFromCode(oldCode, self.codeWidth) + bytes([s[0]]))
            else:
                s = self.stringTable.stringFromCode(oldCode, self.codeWidth)
                outString = s + bytes([s[0]])
                self.uncompressed += outString
                self.stringTable.add(outString)

            oldCode = code

            self.codeWidth = self.stringTable.currentCodeBitWidth()

        code = self.getNextCode()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwData.getNextCode"><code class="name flex">
<span>def <span class="ident">getNextCode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNextCode(self):
    #s1 = self.currentBitPos
    #s2 = s1 + self.codeWidth

    #code = self.compressed.getIntMSBtoLSB(startBit=s1, stopBit=s2)
    #code, self.currentByteIdx, self.currentBitPosInByte = self.compressed.getIntMSBtoLSB_inBytes(startByte=self.currentByteIdx, startBit=self.currentBitPosInByte, nBits=self.codeWidth)

    startByte = self.currentByteIdx
    mask0=self.masks[self.codeWidth,self.currentBitPosInByte,0]
    mask1=self.masks[self.codeWidth,self.currentBitPosInByte,1]
    mask2=self.masks[self.codeWidth,self.currentBitPosInByte,2]

    code = self.compressed.getIntMSBtoLSB_faster(startByte=startByte, rightZeros=self.leftAlignOffsets[self.codeWidth,self.currentBitPosInByte], mask0=mask0, mask1=mask1, mask2=mask2)

    tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Requesting {}({}). Skip: {} CodeWidth: {} Offset: {}  Masks: {:08b}.{:08b}.{:08b} -&gt; {}&#34;.format(startByte, self.currentBitPosInByte, self.byteSkips[self.codeWidth,self.currentBitPosInByte], self.codeWidth, self.currentBitPosInByte, mask0, mask1, mask2, code))

    self.currentByteIdx += self.byteSkips[self.codeWidth,self.currentBitPosInByte]
    self.currentBitPosInByte += self.codeWidth
    self.currentBitPosInByte = self.currentBitPosInByte % 8

    return code</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwData.resetStringtable"><code class="name flex">
<span>def <span class="ident">resetStringtable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetStringtable(self):
    self.stringTable.init()
    self.codeWidth = 9</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwData.setCompressed"><code class="name flex">
<span>def <span class="ident">setCompressed</span></span>(<span>self, compressed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCompressed(self, compressed):
    self.compressed = bits()
    self.compressed.setBytes(compressed)
    self.compressed.data += bytes(3)   # for integer conversion</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.tiffy.lzwStringTable"><code class="flex name class">
<span>class <span class="ident">lzwStringTable</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class lzwStringTable:
    def __init__(self):
        self.byteStrings = []
        self.init()

    def init(self):
        self.byteStrings = []

        # Create all bytes:
        for i in range(256):
            self.byteStrings.append(bytearray(struct.pack(&#34;B&#34;, i)))

        self.byteStrings.append(bytearray())  # ClearCode: 256
        self.byteStrings.append(bytearray())  # EndOfInformation code: 257

    def currentCodeBitWidth(self):
        &#34;&#34;&#34;
        l = len(self.byteStrings) + 1
        bitWidth = 0
        while l != 0:
            l = l &gt;&gt; 1
            bitWidth += 1

        return bitWidth
        &#34;&#34;&#34;

        if len(self.byteStrings) &lt; 255:
            return 8
        elif len(self.byteStrings) &lt; 511:
            return 9
        elif len(self.byteStrings) &lt; 1023:
            return 10
        elif len(self.byteStrings) &lt; 2047:
            return 11
        elif len(self.byteStrings) &lt; 4095:
            return 12
        elif len(self.byteStrings) &lt; 8191:
            return 13
        elif len(self.byteStrings) &lt; 16383:
            return 14
        else:
            raise Exception(&#34;LZW: Dictionary is too big.&#34;)

    def contains(self, code):
        if code &lt; len(self.byteStrings):
            return True

        return False

    def add(self, b):
        self.byteStrings.append(b)

    def isClearCode(self, code):
        if code == 256:
            return True

        return False

    def isEndOfInformation(self, code):
        if code == 257:
            return True

        return False

    def stringFromCode(self, code, codeWidth):
        #if code &lt; 0:
        #    return bytearray()

        return self.byteStrings[code]

        &#34;&#34;&#34;
        if code &lt; len(self.byteStrings):
            #print(&#34;String from code {}: {}&#34;.format(code, self.byteStrings[code]))
            return self.byteStrings[code]
        else:
            raise Exception(&#34;LZW: Requested code #{} not in current string table. Current string table size: {}. Current bit width: {}&#34;.format(code, len(self.byteStrings), codeWidth))
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.tiffy.lzwStringTable.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, b):
    self.byteStrings.append(b)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwStringTable.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, code):
    if code &lt; len(self.byteStrings):
        return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwStringTable.currentCodeBitWidth"><code class="name flex">
<span>def <span class="ident">currentCodeBitWidth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>l = len(self.byteStrings) + 1
bitWidth = 0
while l != 0:
l = l &gt;&gt; 1
bitWidth += 1</p>
<p>return bitWidth</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def currentCodeBitWidth(self):
    &#34;&#34;&#34;
    l = len(self.byteStrings) + 1
    bitWidth = 0
    while l != 0:
        l = l &gt;&gt; 1
        bitWidth += 1

    return bitWidth
    &#34;&#34;&#34;

    if len(self.byteStrings) &lt; 255:
        return 8
    elif len(self.byteStrings) &lt; 511:
        return 9
    elif len(self.byteStrings) &lt; 1023:
        return 10
    elif len(self.byteStrings) &lt; 2047:
        return 11
    elif len(self.byteStrings) &lt; 4095:
        return 12
    elif len(self.byteStrings) &lt; 8191:
        return 13
    elif len(self.byteStrings) &lt; 16383:
        return 14
    else:
        raise Exception(&#34;LZW: Dictionary is too big.&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwStringTable.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self):
    self.byteStrings = []

    # Create all bytes:
    for i in range(256):
        self.byteStrings.append(bytearray(struct.pack(&#34;B&#34;, i)))

    self.byteStrings.append(bytearray())  # ClearCode: 256
    self.byteStrings.append(bytearray())  # EndOfInformation code: 257</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwStringTable.isClearCode"><code class="name flex">
<span>def <span class="ident">isClearCode</span></span>(<span>self, code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isClearCode(self, code):
    if code == 256:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwStringTable.isEndOfInformation"><code class="name flex">
<span>def <span class="ident">isEndOfInformation</span></span>(<span>self, code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isEndOfInformation(self, code):
    if code == 257:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.lzwStringTable.stringFromCode"><code class="name flex">
<span>def <span class="ident">stringFromCode</span></span>(<span>self, code, codeWidth)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringFromCode(self, code, codeWidth):
    #if code &lt; 0:
    #    return bytearray()

    return self.byteStrings[code]

    &#34;&#34;&#34;
    if code &lt; len(self.byteStrings):
        #print(&#34;String from code {}: {}&#34;.format(code, self.byteStrings[code]))
        return self.byteStrings[code]
    else:
        raise Exception(&#34;LZW: Requested code #{} not in current string table. Current string table size: {}. Current bit width: {}&#34;.format(code, len(self.byteStrings), codeWidth))
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.tiffy.tiff"><code class="flex name class">
<span>class <span class="ident">tiff</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tiff:
    def __init__(self):
        self.filename = None
        self.byteOrder = &#34;&lt;&#34;
        self.subfiles = []

    def reset(self):
        self.__init__()

    def read(self, filename=None):
        self.filename = filename

        if self.filename != None:
            if os.path.isfile(self.filename):
                filesize = os.path.getsize(self.filename)
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Size of {filename}: {size} Bytes.&#34;.format(filename=self.filename, size=filesize))

                if filesize &gt; 2:
                    with open(self.filename, &#34;rb&#34;) as f:
                        buff = f.read(2)
                        (tiffformat,) = struct.unpack(&#34;&lt;H&#34;, buff)  # Just read as little endian. It&#39;s symmetric, it doesn&#39;t matter.

                        self.byteOrder = &#34;&lt;&#34;   # little endian
                        if tiffformat == 0x4949:
                            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;II format. Little endian.&#34;)
                            self.byteOrder = &#34;&lt;&#34;
                        elif tiffformat == 0x4d4d:
                            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;MM format. Big endian.&#34;)
                            self.byteOrder = &#34;&gt;&#34;
                        else:
                            f.close()
                            raise Exception(&#34;Invalid byte order for first two bytes in TIFF header. Must be 0x4949 (II) or 0x4d4d (MM).&#34;)

                        buff = f.read(2)
                        (magicByte,) = struct.unpack(&#34;{endian}H&#34;.format(endian=self.byteOrder), buff)
                        if magicByte == 42:
                            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Magic Byte: {}&#34;.format(magicByte))
                        else:
                            raise Exception(&#34;TIFF magic byte is not 42: {}&#34;.format(self.filename))


                        # Get location of first image file directory (IFD):
                        buff = f.read(4)
                        (ifdPos,) = struct.unpack(&#34;{endian}L&#34;.format(endian=self.byteOrder), buff)

                        ifd0 = ifd()
                        ifd0.read(ifdPos, f, self.byteOrder)

                        self.subfiles = []
                        subfile0 = tiffSubfile()
                        subfile0.readMetaInformation(self.filename, self.byteOrder, ifd0)
                        self.subfiles.append(subfile0)

                        nextIfdPos = ifd0.nextIfdPos
                        while nextIfdPos != 0:
                            ifdn = ifd()
                            ifdn.read(nextIfdPos, f, self.byteOrder)
                            subfilen = tiffSubfile()
                            subfilen.readMetaInformation(self.filename, self.byteOrder, ifdn)
                            self.subfiles.append(subfilen)
                            nextIfdPos = ifdn.nextIfdPos

                        f.close()
                else:
                    raise Exception(&#34;TIFF file does not contain any data: {}&#34;.format(self.filename))
            else:
                raise Exception(&#34;File not found: {}&#34;.format(self.filename))

    def imageData(self, subfile=0, channel=None, obeyOrientation=True):
        if subfile &lt; len(self.subfiles):
            data = self.subfiles[subfile].imageData()
            if channel == None:
                return data
            else:
                return data[0]
        else:
            raise Exception(&#34;Subfile id not available: {}&#34;.format(subfile))

    def getNrSubfiles(self):
        &#34;&#34;&#34; Return number of subfiles. &#34;&#34;&#34;
        return len(self.subfiles)

    def getWidth(self, subfile=0):
        if subfile &lt; len(self.subfiles):
            return self.subfiles[subfile].getWidth()

    def getHeight(self, subfile=0):
        if subfile &lt; len(self.subfiles):
            return self.subfiles[subfile].getHeight()

    def sizeInBytes(self):
        size = 8  # TIFF header

        # Add size for each sub file:
        for sub in self.subfiles:
            size += sub.sizeInBytes()

        return size

    def prepareDataOffsets(self):
        offset = 8  # TIFF header
        for sub in self.subfiles:
            offset = sub.prepareDataOffsets(offset)

    def printOffset(self):
        self.prepareDataOffsets()
        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;TIFF HEADER             0&#34;)
        for sub in self.subfiles:
            sub.printOffset()

    def set(self, imageData, resX=0, resY=0):
        self.reset()
        self.addImgData(imageData, resX, resY)

    def addImgData(self, imageData, resX=0, resY=0):
        if len(numpy.shape(imageData)) == 2:
            # We have to add another dimension for the channel...
            imageData = numpy.expand_dims(a=imageData, axis=0)

        if len(numpy.shape(imageData)) == 3:
            img = tiffSubfile()
            img.set(imageData, resX, resY)
            self.subfiles.append(img)

            # IFDs must be setup twice to ensure correct data offset pointers.
            for sub in self.subfiles:
                sub.setupIFD()
            self.prepareDataOffsets()
            for sub in self.subfiles:
                sub.setupIFD()
        else:
            raise Exception(&#34;TIFF: adding image data failed. Image data must be a numpy array of shape (height, width) or (channels, height, width).&#34;)

    def save(self, filename, endian=&#34;little&#34;):
        byteOrder = &#34;&lt;&#34; # little endian is default
        if endian == &#34;big&#34;:
            byteOrder = &#34;&gt;&#34;

        with open(filename, &#39;wb&#39;) as f:
            # Write the TIFF header.

            # Endian:
            if byteOrder == &#34;&gt;&#34;:
                buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 0x4d4d)
            else:
                buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 0x4949)
            f.write(buff)

            # Magic number:
            buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 42)
            f.write(buff)

            # The IFD0 always follows the header in our case:
            buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), 8)
            f.write(buff)

            for sub in self.subfiles:
                sub.write(f, byteOrder)
           
            f.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.tiffy.tiff.addImgData"><code class="name flex">
<span>def <span class="ident">addImgData</span></span>(<span>self, imageData, resX=0, resY=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addImgData(self, imageData, resX=0, resY=0):
    if len(numpy.shape(imageData)) == 2:
        # We have to add another dimension for the channel...
        imageData = numpy.expand_dims(a=imageData, axis=0)

    if len(numpy.shape(imageData)) == 3:
        img = tiffSubfile()
        img.set(imageData, resX, resY)
        self.subfiles.append(img)

        # IFDs must be setup twice to ensure correct data offset pointers.
        for sub in self.subfiles:
            sub.setupIFD()
        self.prepareDataOffsets()
        for sub in self.subfiles:
            sub.setupIFD()
    else:
        raise Exception(&#34;TIFF: adding image data failed. Image data must be a numpy array of shape (height, width) or (channels, height, width).&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.getHeight"><code class="name flex">
<span>def <span class="ident">getHeight</span></span>(<span>self, subfile=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHeight(self, subfile=0):
    if subfile &lt; len(self.subfiles):
        return self.subfiles[subfile].getHeight()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.getNrSubfiles"><code class="name flex">
<span>def <span class="ident">getNrSubfiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return number of subfiles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNrSubfiles(self):
    &#34;&#34;&#34; Return number of subfiles. &#34;&#34;&#34;
    return len(self.subfiles)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.getWidth"><code class="name flex">
<span>def <span class="ident">getWidth</span></span>(<span>self, subfile=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWidth(self, subfile=0):
    if subfile &lt; len(self.subfiles):
        return self.subfiles[subfile].getWidth()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.imageData"><code class="name flex">
<span>def <span class="ident">imageData</span></span>(<span>self, subfile=0, channel=None, obeyOrientation=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imageData(self, subfile=0, channel=None, obeyOrientation=True):
    if subfile &lt; len(self.subfiles):
        data = self.subfiles[subfile].imageData()
        if channel == None:
            return data
        else:
            return data[0]
    else:
        raise Exception(&#34;Subfile id not available: {}&#34;.format(subfile))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.prepareDataOffsets"><code class="name flex">
<span>def <span class="ident">prepareDataOffsets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepareDataOffsets(self):
    offset = 8  # TIFF header
    for sub in self.subfiles:
        offset = sub.prepareDataOffsets(offset)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.printOffset"><code class="name flex">
<span>def <span class="ident">printOffset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printOffset(self):
    self.prepareDataOffsets()
    tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;TIFF HEADER             0&#34;)
    for sub in self.subfiles:
        sub.printOffset()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, filename=None):
    self.filename = filename

    if self.filename != None:
        if os.path.isfile(self.filename):
            filesize = os.path.getsize(self.filename)
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Size of {filename}: {size} Bytes.&#34;.format(filename=self.filename, size=filesize))

            if filesize &gt; 2:
                with open(self.filename, &#34;rb&#34;) as f:
                    buff = f.read(2)
                    (tiffformat,) = struct.unpack(&#34;&lt;H&#34;, buff)  # Just read as little endian. It&#39;s symmetric, it doesn&#39;t matter.

                    self.byteOrder = &#34;&lt;&#34;   # little endian
                    if tiffformat == 0x4949:
                        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;II format. Little endian.&#34;)
                        self.byteOrder = &#34;&lt;&#34;
                    elif tiffformat == 0x4d4d:
                        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;MM format. Big endian.&#34;)
                        self.byteOrder = &#34;&gt;&#34;
                    else:
                        f.close()
                        raise Exception(&#34;Invalid byte order for first two bytes in TIFF header. Must be 0x4949 (II) or 0x4d4d (MM).&#34;)

                    buff = f.read(2)
                    (magicByte,) = struct.unpack(&#34;{endian}H&#34;.format(endian=self.byteOrder), buff)
                    if magicByte == 42:
                        tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Magic Byte: {}&#34;.format(magicByte))
                    else:
                        raise Exception(&#34;TIFF magic byte is not 42: {}&#34;.format(self.filename))


                    # Get location of first image file directory (IFD):
                    buff = f.read(4)
                    (ifdPos,) = struct.unpack(&#34;{endian}L&#34;.format(endian=self.byteOrder), buff)

                    ifd0 = ifd()
                    ifd0.read(ifdPos, f, self.byteOrder)

                    self.subfiles = []
                    subfile0 = tiffSubfile()
                    subfile0.readMetaInformation(self.filename, self.byteOrder, ifd0)
                    self.subfiles.append(subfile0)

                    nextIfdPos = ifd0.nextIfdPos
                    while nextIfdPos != 0:
                        ifdn = ifd()
                        ifdn.read(nextIfdPos, f, self.byteOrder)
                        subfilen = tiffSubfile()
                        subfilen.readMetaInformation(self.filename, self.byteOrder, ifdn)
                        self.subfiles.append(subfilen)
                        nextIfdPos = ifdn.nextIfdPos

                    f.close()
            else:
                raise Exception(&#34;TIFF file does not contain any data: {}&#34;.format(self.filename))
        else:
            raise Exception(&#34;File not found: {}&#34;.format(self.filename))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.__init__()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename, endian='little')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename, endian=&#34;little&#34;):
    byteOrder = &#34;&lt;&#34; # little endian is default
    if endian == &#34;big&#34;:
        byteOrder = &#34;&gt;&#34;

    with open(filename, &#39;wb&#39;) as f:
        # Write the TIFF header.

        # Endian:
        if byteOrder == &#34;&gt;&#34;:
            buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 0x4d4d)
        else:
            buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 0x4949)
        f.write(buff)

        # Magic number:
        buff = struct.pack(&#34;{endian}H&#34;.format(endian=byteOrder), 42)
        f.write(buff)

        # The IFD0 always follows the header in our case:
        buff = struct.pack(&#34;{endian}L&#34;.format(endian=byteOrder), 8)
        f.write(buff)

        for sub in self.subfiles:
            sub.write(f, byteOrder)
       
        f.close()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, imageData, resX=0, resY=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, imageData, resX=0, resY=0):
    self.reset()
    self.addImgData(imageData, resX, resY)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiff.sizeInBytes"><code class="name flex">
<span>def <span class="ident">sizeInBytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sizeInBytes(self):
    size = 8  # TIFF header

    # Add size for each sub file:
    for sub in self.subfiles:
        size += sub.sizeInBytes()

    return size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile"><code class="flex name class">
<span>class <span class="ident">tiffSubfile</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tiffSubfile:
    def __init__(self):
        self.px = []      # Array of numpy arrays to store image data (i.e. pixel values). One for each component/channel. Shape: (nChannel, nRows, nCols)
        self.imageDataOffset = 0  # Location of beginning of image data
        self.sampleFormat = [TIFF_SAMPLEFORMAT_UINT]  # Standard: uint

        self.filename = None
        self.byteOrder = &#34;&lt;&#34;  # little endian
        self.ifd = None

        self.photometricInterpretation = TIFF_BLACK_IS_ZERO
        self.compression = TIFF_NO_COMPRESSION
        self.predictor = TIFF_NO_PREDICTOR

        self.rows = 0
        self.cols = 0

        self.resolutionUnit = TIFF_RES_INCH
        self.resX = 0
        self.resY = 0

        self.rowsPerStrip = 0
        self.stripOffsets = []
        self.stripByteCounts = []

        self.bitsPerSample = (1,)        # Bilevel images do not define this, so make 1 bit/sample the default.
        self.samplesPerPixel = 1
        self.planarConfig = TIFF_CHUNKY  # Chunky (RGBRGBRGB...)
        self.orientation = 1
        self.colorMap = None             # For palette-color images

    def reset(self):
        self.__init__()

    def set(self, imageData, resX=0, resY=0):
        if len(imageData) &gt; 0:
            self.reset()
            self.px = imageData

            shp = numpy.shape(self.px)  # Shape must be 3-component tuple: (nChannels, height, width)
            if len(shp) == 3:
                self.samplesPerPixel = shp[0]
                self.rows = shp[1]
                self.cols = shp[2]

                self.rowsPerStrip = self.rows
                # self.stripByteCounts and self.stripOffsets will be set later by self.prepareDataOffsets()

                # Byte order
                self.byteOrder = getByteOrder(self.px)

                # Sample format
                if numpy.issubdtype(self.px.dtype, numpy.signedinteger):
                    self.sampleFormat = [TIFF_SAMPLEFORMAT_INT] * self.nChannels()
                elif numpy.issubdtype(self.px.dtype, numpy.unsignedinteger):
                    self.sampleFormat = [TIFF_SAMPLEFORMAT_UINT] * self.nChannels()
                elif numpy.issubdtype(self.px.dtype, numpy.floating):
                    self.sampleFormat = [TIFF_SAMPLEFORMAT_IEEEFP] * self.nChannels()
                else:
                    raise Exception(&#34;Unsupported dtype ({}) of provided image data. Must be an integer or floating point type.&#34;.format(numpy.dtype(self.px)))

                self.bitsPerSample  = [self.px.dtype.itemsize*8] * self.samplesPerPixel
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Setting bits per sample: {}&#34;.format(self.bitsPerSample))
                tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Setting sample format:   {}&#34;.format(self.sampleFormat))

                self.resolutionUnit = TIFF_RES_NONE
                self.resX = resX
                self.resY = resY

                self.compression    = TIFF_NO_COMPRESSION

                
                self.photometricInterpretation = TIFF_BLACK_IS_ZERO
                if self.nChannels() == 3:
                    self.photometricInterpretation = TIFF_RGB

                #if self.samplesPerPixel &gt; 1:
                #    self.planarConfig   = TIFF_PLANAR
                #else:
                #    self.planarConfig   = TIFF_CHUNKY
                self.planarConfig   = TIFF_CHUNKY

            else:
                raise Exception(&#34;Error setting image data. Please provide a numpy array of shape (nChannels, nRows, nColumns).&#34;)

    def addIFDentry_shortOrLong(self, tag, values):
        # find the right integer type for the provided values:
        m = max(values)
        typ = TIFF_LONG
        if m &lt; (2**16):
            typ = TIFF_SHORT

        self.addIFDentry(tag, typ, values)

    def addIFDentry(self, tag, typ, values):
        entry = ifdEntry()
        entry.set(tag, typ, values)
        self.ifd.addEntry(entry)

    def setupIFD(self):
        self.ifd = None
        self.ifd = ifd()

        self.addIFDentry_shortOrLong(256, (self.cols, ))                        # n columns
        self.addIFDentry_shortOrLong(257, (self.rows, ))                        # n rows
        self.addIFDentry(258, TIFF_SHORT, self.bitsPerSample)                   # bits per sample, already an array
        self.addIFDentry(259, TIFF_SHORT, (TIFF_NO_COMPRESSION, ))               # compression
        self.addIFDentry(262, TIFF_SHORT, (self.photometricInterpretation, ))   # photometric interpretation
        self.addIFDentry(266, TIFF_SHORT, (TIFF_MSB2LSB, ))                      # fill order 
        self.addIFDentry_shortOrLong(273, (self.imageDataOffset, ))             # offset location of strip
        self.addIFDentry(274, TIFF_SHORT, (self.orientation, ))                 # orientation
        self.addIFDentry(277, TIFF_SHORT, (self.samplesPerPixel, ))             # samples per pixel
        self.addIFDentry_shortOrLong(278, (self.rowsPerStrip, ))                # rows per strip
        self.addIFDentry_shortOrLong(279, (self.dataSizeInBytes(), ))            # strip byte counts
        # insert resolution entries here later...
        self.addIFDentry(284, TIFF_SHORT, (self.planarConfig, ))                # planar configuration
       
        #self.addIFDentry(296, TIFF_SHORT, (self.resolutionUnit, ))             # resolution unit
        
        if self.predictor != TIFF_NO_PREDICTOR:
            self.addIFDentry(317, TIFF_SHORT, (self.predictor, ))                   # predictor
        # color map
        
        self.addIFDentry(339, TIFF_SHORT, self.sampleFormat)                    # sample format, already an array

    def dataSizeInBytes(self):
        &#34;&#34;&#34; Size of pixel data (in bytes) &#34;&#34;&#34;
        size = 0
        for bitsPerSample in self.bitsPerSample:
            s = int(bitsPerSample * self.nPixels())
            size += s

        return size/8

    def sizeInBytes(self):
        size = 0
        if self.ifd != None:
            size += self.ifd.sizeInBytes()

        size += self.dataSizeInBytes()

        return size

    def prepareDataOffsets(self, offset):
        if self.ifd != None:
            self.ifd.prepareDataOffsets(offset)

            offset += self.ifd.sizeInBytes()
            self.imageDataOffset = offset  # image data starts here

            self.stripOffsets    = (self.imageDataOffset, )
            self.stripByteCounts = self.dataSizeInBytes()

            offset += self.dataSizeInBytes()
            return offset
        else:
            return 0

    def printOffset(self):
        if self.ifd != None:
            self.ifd.printOffset()

        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;  Image Data            {offset}&#34;.format(offset=self.imageDataOffset))

    def readMetaInformation(self, filename, byteOrder, imgFileDirectory):
        self.filename = filename
        self.byteOrder = byteOrder
        self.ifd = imgFileDirectory

        # Interpret IFD fields based on their TIFF tags:
        for field in self.ifd.fields:
            if field.tag == 256:  # Number of columns
                self.cols = field.getValue()
            elif field.tag == 257:  # Number of rows
                self.rows = field.getValue()
            elif field.tag == 258:  # Bits per sample
                self.bitsPerSample = field.values
            elif field.tag == 259:  # Compression
                self.compression = field.getValue()
                if self.compression == 0:
                    self.compression = TIFF_NO_COMPRESSION
            elif field.tag == 262:    # Photometric interpretation
                self.photometricInterpretation = field.getValue()
            elif field.tag == 273:  # Strip offsets
                self.stripOffsets = field.values
            elif field.tag == 274:  # Orientation
                self.orientation = field.getValue()
            elif field.tag == 277:  # Samples per pixel
                self.samplesPerPixel = field.getValue()
            elif field.tag == 278:  # Rows per strip
                self.rowsPerStrip = field.getValue()
            elif field.tag == 279:  # Strip byte counts
                self.stripByteCounts = field.values
            elif field.tag == 282:  # x resolution
                self.resX = field.getValue()
            elif field.tag == 283:  # y resolution
                self.resY = field.getValue()
            elif field.tag == 284:  # Planar configuration (order of pixel components)
                self.planarConfig = field.getValue()
            elif field.tag == 296:  # Resolution unit
                self.resolutionUnit = field.getValue()
            elif field.tag == 317:  # Predictor
                self.predictor = field.getValue()
            elif field.tag == 320:  # Color map
                pass # implement later...
            elif field.tag == 339:  # Sample format
                self.sampleFormat = field.values            

    def nChannels(self):
        return self.samplesPerPixel

    def nPixels(self):
        return self.rows*self.cols

    def bitsPerPixel(self):
        bits = 0
        for b in self.bitsPerSample:
            bits += b

        return bits

    def isPlanar(self):
        return (self.samplesPerPixel == 1 or self.planarConfig == TIFF_PLANAR)

    def isSet(self):
        &#34;&#34;&#34; Check if image has a valid width and height. &#34;&#34;&#34;
        if(self.getHeight() &gt; 0):
            if(self.getWidth() &gt; 0):
                return True

        return False

    def getWidth(self):
        return self.cols

    def getHeight(self):
        return self.rows

    def rot90(self):
        if self.isSet():
            self.px = numpy.rot90(self.px, k=1, axes=(1,2))
            self.cols, self.rows = self.rows, self.cols

    def rot180(self):
        if self.isSet():
            self.px = numpy.rot90(self.px, k=2, axes=(1,2))

    def rot270(self):
        if self.isSet():
            self.px = numpy.rot90(self.px, k=-1, axes=(1,2))
            self.cols, self.rows = self.rows, self.cols

    def rotate(self, rotation):
        if rotation == &#34;90&#34;:
            self.rot90()
        elif rotation == &#34;180&#34;:
            self.rot180()
        elif rotation == &#34;270&#34;:
            self.rot270()

    def flipHorizontal(self):
        if self.isSet():
            for i in range(self.nChannels()):
                self.px[i] = numpy.fliplr(self.px[i])

    def flipVertical(self):
        if self.isSet():
            for i in range(self.nChannels()):
                self.px[i] = numpy.flipud(self.px[i])

    def setFlip(self, horz=False, vert=False):
        self.flipHorz = horz
        self.flipVert = vert

    def getHorizontalFlip(self):
        return self.flipHorz

    def getVerticalFlip(self):
        return self.flipVert

    def flip(self, horizontal=False, vertical=False):
        if horizontal:
            self.flipHorizontal()
        if vertical:
            self.flipVertical()

    def numpyDatatype(self, sampleFormat, bitsPerSample):
        formatString = self.byteOrder
        if sampleFormat == TIFF_SAMPLEFORMAT_UINT:  # unsigned
            if bitsPerSample == 8:
                formatString = &#34;u1&#34;   # unsigned char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;u2&#34;   # unsigned short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;u4&#34;   # unsigned long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;u8&#34;   # unsigned long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_INT:  # signed
            if bitsPerSample == 8:
                formatString = &#34;i1&#34;   # signed char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;i2&#34;   # signed short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;i4&#34;   # signed long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;i8&#34;   # signed long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_IEEEFP:
            if bitsPerSample == 16:
                formatString += &#34;f2&#34;   # float 16 bit
            elif bitsPerSample == 32:
                formatString += &#34;f4&#34;   # float 32 bit
            elif bitsPerSample == 64:
                formatString += &#34;f8&#34;   # double 64 bit

        if len(formatString) &gt;= 1:
            return numpy.dtype(formatString)

        raise Exception(&#34;Unsupported data type: {bps} bits per sample for TIFF sample format {sf}.&#34;.format(bps=bitsPerSample, sf=sampleFormat))

    def structDataTypeString(self, sampleFormat, bitsPerSample):
        formatString = self.byteOrder
        if sampleFormat == TIFF_SAMPLEFORMAT_UINT:  # unsigned
            if bitsPerSample == 8:
                formatString = &#34;B&#34;   # unsigned char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;H&#34;   # unsigned short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;L&#34;   # unsigned long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;Q&#34;   # unsigned long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_INT:  # signed
            if bitsPerSample == 8:
                formatString = &#34;b&#34;   # signed char (1 byte)
            elif bitsPerSample == 16:
                formatString += &#34;h&#34;   # signed short (2 bytes)
            elif bitsPerSample == 32:
                formatString += &#34;l&#34;   # signed long (4 bytes)
            elif bitsPerSample == 64:
                formatString += &#34;q&#34;   # signed long long (8 bytes)
        elif sampleFormat == TIFF_SAMPLEFORMAT_IEEEFP:
            if bitsPerSample == 16:
                formatString += &#34;e&#34;   # float 16 bit
            elif bitsPerSample == 32:
                formatString += &#34;f&#34;   # float 32 bit
            elif bitsPerSample == 64:
                formatString += &#34;d&#34;   # double 64 bit

        if len(formatString) &gt;= 1:
            return formatString

        raise Exception(&#34;Unsupported data type: {bps} bits per sample for TIFF sample format {sf}.&#34;.format(bps=bitsPerSample, sf=sampleFormat))

    def importFromUncompressedBuffer(self, pixelOffset, nPixels, datatype, channel, buff):
        if self.isPlanar():  # Buffer contains data just for one channel.
            self.px[channel][int(pixelOffset):int(pixelOffset+nPixels)] = numpy.frombuffer(buff, dtype=datatype)
        else: # CHUNKY configuration. channel is irrelevant here (and wrong.)
            bitsPerPixel = self.bitsPerPixel()
            bytesPerPixel = int(bitsPerPixel / 8)

            bytesPerSample = [x/8 for x in self.bitsPerSample]

            buff1d = numpy.frombuffer(buff, dtype=datatype)
            self.px[int(pixelOffset):int(pixelOffset+nPixels)] = numpy.reshape(buff1d, (nPixels, self.nChannels()))

            &#34;&#34;&#34;
            for pixel in range(nPixels):
                channelOffset = 0

                

                for c in range(self.samplesPerPixel):
                    # Current index in bytes
                    idxStart = int((pixel + pixelOffset)*bytesPerPixel + channelOffset/8)
                    idxStop  = int(idxStart + bytesPerSample[c])

                    #print(&#34;Start: {}, Stop: {}&#34;.format(idxStart, idxStop))

                    self.px[c][pixel] = numpy.frombuffer(buff[idxStart:idxStop], dtype=dt)

                    channelOffset += self.bitsPerSample[c]
            &#34;&#34;&#34;

    def imageData(self, obeyOrientation=True):
        # Read data into byte buffer:
        if len(self.stripOffsets) &gt; 0:
            if len(self.stripOffsets) == len(self.stripByteCounts):
                if os.path.isfile(self.filename):
                    with open(self.filename, &#34;rb&#34;) as f:
                        # Initialize nChannels x nPixels array for each channel:

                        # Check if bits per sample is the same for each channel:
                        if self.bitsPerSample.count(self.bitsPerSample[0]) == len(self.bitsPerSample) and self.sampleFormat.count(self.sampleFormat[0]) == len(self.sampleFormat):
                            sampleFormat  = self.sampleFormat[0]
                            bitsPerSample = self.bitsPerSample[0]

                            dt = self.numpyDatatype(sampleFormat, bitsPerSample)

                            if self.isPlanar():
                                self.px = numpy.zeros((self.nChannels(), self.nPixels()), dtype=dt)
                            else:
                                # Make array the shape of a chunky tiff configuration and reshape later...
                                self.px = numpy.zeros((self.nPixels(), self.nChannels()), dtype=dt)

                            nStrips = len(self.stripOffsets)

                            if self.compression == TIFF_NO_COMPRESSION or self.compression == TIFF_LZW_COMPRESSION:
                                pixel = 0
                                bitsPerPixel = self.bitsPerPixel()

                                c = 0  # channel id. Only necessary for PLANAR configuration.
                                nStripsPerChannel = int(nStrips / self.samplesPerPixel)

                                for i in range(nStrips):
                                    if self.samplesPerPixel &gt; 1:
                                        if self.planarConfig == TIFF_PLANAR:
                                            # Import next channel once all strips for one component channel have been imported.
                                            if (i % nStripsPerChannel) == 0:
                                                c += 1

                                    offset = self.stripOffsets[i]
                                    byteCount = self.stripByteCounts[i]  # byte count after compression

                                    #print(&#34;Strip #{}/{}, Byte Offset: {}, Byte Count: {}&#34;.format(i, nStrips, offset, byteCount))

                                    f.seek(offset)
                                    buff = f.read(byteCount)
                                    if self.compression == TIFF_LZW_COMPRESSION:
                                        compressed = lzwData()
                                        compressed.setCompressed(buff)

                                        #print(&#34;Decompressing LZW for strip {i}/{n}...&#34;.format(i=i, n=nStrips))
                                        compressed.decompress()
                                        buff = bytes(compressed.uncompressed)

                                    byteCount = len(buff)
                                    bitCount = 8*byteCount
                                    if not self.isPlanar(): # Standard is chunky, also for only 1 sample/pixel.
                                        pixelsInStrip = int(bitCount / bitsPerPixel)
                                    else:
                                        pixelsInStrip = int(bitCount / self.bitsPerSample[c])

                                    self.importFromUncompressedBuffer(
                                        pixelOffset = pixel,
                                        nPixels = pixelsInStrip,
                                        datatype = dt,
                                        channel = c,
                                        buff = buff)

                                    pixel += pixelsInStrip

                                tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;{} strips imported.&#34;.format(nStrips))
                            else:
                                raise Exception(&#34;TIFF: Compression scheme {} not supported.&#34;.format(self.compression))

                            f.close()

                            if not(self.isPlanar()):
                                # Chunky mode. Swap axes from (pixels, channels) to (channels, pixels):
                                self.px = numpy.swapaxes(self.px, 0, 1)

                            # Reshape components into 2D arrays:
                            if len(self.px) &gt; 0:
                                self.px = numpy.reshape(self.px, (self.nChannels(), self.rows, self.cols))

                            # Convert horizontal differences to absolute values:
                            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;Applying horizontal differencing...&#34;)
                            if self.predictor == TIFF_HORIZONTAL_DIFFERENCING:
                                for col in range(1, self.cols):
                                    self.px[...,col] = self.px[...,col-1] + self.px[...,col]

                            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;Orientation is: {}&#34;.format(self.orientation))
                            if obeyOrientation:
                                # Rotate back to orientation 1 ((0,0) is upper left)
                                if self.orientation == 2:     # (col0, row0) is (top, right)
                                    self.flip(horizontal=True, vertical=False)
                                elif self.orientation == 3:   # (col0, row0) is (bottom, right)
                                    self.flip(horizontal=True, vertical=True)
                                elif self.orientation == 4:   # (col0, row0) is bottom left
                                    self.flip(horizontal=False, vertical=True)
                                elif self.orientation == 5:   # (col0, row0) is (left, top)
                                    self.rotate(&#34;90&#34;)
                                    self.flip(horizontal=False, vertical=True)
                                elif self.orientation == 6:   # (col0, row0) is (right, top)
                                    self.rotate(&#34;270&#34;)
                                elif self.orientation == 7:   # (col0, row0) is (right, bottom)
                                    self.rotate(&#34;90&#34;)
                                    self.flip(horizontal=True, vertical=False)
                                elif self.orientation == 8:   # (col0, row0) is (left, bottom)
                                    self.rotate(&#34;90&#34;)

                                self.orientation = 1

                            return self.px
                        else:
                            f.close()
                            raise Exception(&#34;Unsupported TIFF format: all channels must have the same type and size. Sample format: {}, Bits per sample: {}&#34;.format(self.sampleFormat, self.bitsPerSample))                       

                raise Exception(&#34;File not available: {}&#34;.format(self.filename))
            else:
                raise Exception(&#34;Number of strip offsets ({nOffsets}) does not match number of strip byte counts ({nByteCounts}).&#34;.format(nOffsets=len(self.stripOffsets), nByteCounts=len(self.stripByteCounts)))
        else:
            raise Exception(&#34;No data strips found for requested subfile in {filename}.&#34;.format(filename=self.filename))

    def write(self, f, byteOrder):
        &#34;&#34;&#34; Expects an open, writable file pointer f. &#34;&#34;&#34;
        self.ifd.write(f, byteOrder)

        dataByteOrder = getByteOrder(self.px)
        if dataByteOrder != byteOrder:
            self.px.byteswap(inplace=True)

        # Write image data:
        if self.samplesPerPixel == 1:
            f.write(self.px)
        else:
            chunkyBytes = numpy.swapaxes(self.px, 0, 2)  # channel &lt;-&gt; cols  --&gt; (cols, rows, channel)
            chunkyBytes = numpy.swapaxes(chunkyBytes, 0, 1)  # cols &lt;-&gt; rows  --&gt; (rows, cols, channel)
            chunkyBytes.tofile(f, &#34;&#34;)

            &#34;&#34;&#34;
            dataString = []
            for c in range(self.nChannels()):
                dataString.append(self.structDataTypeString(self.sampleFormat[c], self.bitsPerSample[c]))

            for y in range(self.rows):
                for x in range(self.cols):
                    # Chunky style.
                    for c in range(self.nChannels()):
                        buff = struct.pack(&#34;{endian}{ds}&#34;.format(endian=byteOrder, ds=dataString[c]), self.px[c][y][x])
                        f.write(buff)
            &#34;&#34;&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctsimu.tiffy.tiffSubfile.addIFDentry"><code class="name flex">
<span>def <span class="ident">addIFDentry</span></span>(<span>self, tag, typ, values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addIFDentry(self, tag, typ, values):
    entry = ifdEntry()
    entry.set(tag, typ, values)
    self.ifd.addEntry(entry)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.addIFDentry_shortOrLong"><code class="name flex">
<span>def <span class="ident">addIFDentry_shortOrLong</span></span>(<span>self, tag, values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addIFDentry_shortOrLong(self, tag, values):
    # find the right integer type for the provided values:
    m = max(values)
    typ = TIFF_LONG
    if m &lt; (2**16):
        typ = TIFF_SHORT

    self.addIFDentry(tag, typ, values)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.bitsPerPixel"><code class="name flex">
<span>def <span class="ident">bitsPerPixel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitsPerPixel(self):
    bits = 0
    for b in self.bitsPerSample:
        bits += b

    return bits</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.dataSizeInBytes"><code class="name flex">
<span>def <span class="ident">dataSizeInBytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Size of pixel data (in bytes)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataSizeInBytes(self):
    &#34;&#34;&#34; Size of pixel data (in bytes) &#34;&#34;&#34;
    size = 0
    for bitsPerSample in self.bitsPerSample:
        s = int(bitsPerSample * self.nPixels())
        size += s

    return size/8</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>self, horizontal=False, vertical=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(self, horizontal=False, vertical=False):
    if horizontal:
        self.flipHorizontal()
    if vertical:
        self.flipVertical()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.flipHorizontal"><code class="name flex">
<span>def <span class="ident">flipHorizontal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flipHorizontal(self):
    if self.isSet():
        for i in range(self.nChannels()):
            self.px[i] = numpy.fliplr(self.px[i])</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.flipVertical"><code class="name flex">
<span>def <span class="ident">flipVertical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flipVertical(self):
    if self.isSet():
        for i in range(self.nChannels()):
            self.px[i] = numpy.flipud(self.px[i])</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.getHeight"><code class="name flex">
<span>def <span class="ident">getHeight</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHeight(self):
    return self.rows</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.getHorizontalFlip"><code class="name flex">
<span>def <span class="ident">getHorizontalFlip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHorizontalFlip(self):
    return self.flipHorz</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.getVerticalFlip"><code class="name flex">
<span>def <span class="ident">getVerticalFlip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVerticalFlip(self):
    return self.flipVert</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.getWidth"><code class="name flex">
<span>def <span class="ident">getWidth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWidth(self):
    return self.cols</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.imageData"><code class="name flex">
<span>def <span class="ident">imageData</span></span>(<span>self, obeyOrientation=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imageData(self, obeyOrientation=True):
    # Read data into byte buffer:
    if len(self.stripOffsets) &gt; 0:
        if len(self.stripOffsets) == len(self.stripByteCounts):
            if os.path.isfile(self.filename):
                with open(self.filename, &#34;rb&#34;) as f:
                    # Initialize nChannels x nPixels array for each channel:

                    # Check if bits per sample is the same for each channel:
                    if self.bitsPerSample.count(self.bitsPerSample[0]) == len(self.bitsPerSample) and self.sampleFormat.count(self.sampleFormat[0]) == len(self.sampleFormat):
                        sampleFormat  = self.sampleFormat[0]
                        bitsPerSample = self.bitsPerSample[0]

                        dt = self.numpyDatatype(sampleFormat, bitsPerSample)

                        if self.isPlanar():
                            self.px = numpy.zeros((self.nChannels(), self.nPixels()), dtype=dt)
                        else:
                            # Make array the shape of a chunky tiff configuration and reshape later...
                            self.px = numpy.zeros((self.nPixels(), self.nChannels()), dtype=dt)

                        nStrips = len(self.stripOffsets)

                        if self.compression == TIFF_NO_COMPRESSION or self.compression == TIFF_LZW_COMPRESSION:
                            pixel = 0
                            bitsPerPixel = self.bitsPerPixel()

                            c = 0  # channel id. Only necessary for PLANAR configuration.
                            nStripsPerChannel = int(nStrips / self.samplesPerPixel)

                            for i in range(nStrips):
                                if self.samplesPerPixel &gt; 1:
                                    if self.planarConfig == TIFF_PLANAR:
                                        # Import next channel once all strips for one component channel have been imported.
                                        if (i % nStripsPerChannel) == 0:
                                            c += 1

                                offset = self.stripOffsets[i]
                                byteCount = self.stripByteCounts[i]  # byte count after compression

                                #print(&#34;Strip #{}/{}, Byte Offset: {}, Byte Count: {}&#34;.format(i, nStrips, offset, byteCount))

                                f.seek(offset)
                                buff = f.read(byteCount)
                                if self.compression == TIFF_LZW_COMPRESSION:
                                    compressed = lzwData()
                                    compressed.setCompressed(buff)

                                    #print(&#34;Decompressing LZW for strip {i}/{n}...&#34;.format(i=i, n=nStrips))
                                    compressed.decompress()
                                    buff = bytes(compressed.uncompressed)

                                byteCount = len(buff)
                                bitCount = 8*byteCount
                                if not self.isPlanar(): # Standard is chunky, also for only 1 sample/pixel.
                                    pixelsInStrip = int(bitCount / bitsPerPixel)
                                else:
                                    pixelsInStrip = int(bitCount / self.bitsPerSample[c])

                                self.importFromUncompressedBuffer(
                                    pixelOffset = pixel,
                                    nPixels = pixelsInStrip,
                                    datatype = dt,
                                    channel = c,
                                    buff = buff)

                                pixel += pixelsInStrip

                            tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;{} strips imported.&#34;.format(nStrips))
                        else:
                            raise Exception(&#34;TIFF: Compression scheme {} not supported.&#34;.format(self.compression))

                        f.close()

                        if not(self.isPlanar()):
                            # Chunky mode. Swap axes from (pixels, channels) to (channels, pixels):
                            self.px = numpy.swapaxes(self.px, 0, 1)

                        # Reshape components into 2D arrays:
                        if len(self.px) &gt; 0:
                            self.px = numpy.reshape(self.px, (self.nChannels(), self.rows, self.cols))

                        # Convert horizontal differences to absolute values:
                        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;Applying horizontal differencing...&#34;)
                        if self.predictor == TIFF_HORIZONTAL_DIFFERENCING:
                            for col in range(1, self.cols):
                                self.px[...,col] = self.px[...,col-1] + self.px[...,col]

                        tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;Orientation is: {}&#34;.format(self.orientation))
                        if obeyOrientation:
                            # Rotate back to orientation 1 ((0,0) is upper left)
                            if self.orientation == 2:     # (col0, row0) is (top, right)
                                self.flip(horizontal=True, vertical=False)
                            elif self.orientation == 3:   # (col0, row0) is (bottom, right)
                                self.flip(horizontal=True, vertical=True)
                            elif self.orientation == 4:   # (col0, row0) is bottom left
                                self.flip(horizontal=False, vertical=True)
                            elif self.orientation == 5:   # (col0, row0) is (left, top)
                                self.rotate(&#34;90&#34;)
                                self.flip(horizontal=False, vertical=True)
                            elif self.orientation == 6:   # (col0, row0) is (right, top)
                                self.rotate(&#34;270&#34;)
                            elif self.orientation == 7:   # (col0, row0) is (right, bottom)
                                self.rotate(&#34;90&#34;)
                                self.flip(horizontal=True, vertical=False)
                            elif self.orientation == 8:   # (col0, row0) is (left, bottom)
                                self.rotate(&#34;90&#34;)

                            self.orientation = 1

                        return self.px
                    else:
                        f.close()
                        raise Exception(&#34;Unsupported TIFF format: all channels must have the same type and size. Sample format: {}, Bits per sample: {}&#34;.format(self.sampleFormat, self.bitsPerSample))                       

            raise Exception(&#34;File not available: {}&#34;.format(self.filename))
        else:
            raise Exception(&#34;Number of strip offsets ({nOffsets}) does not match number of strip byte counts ({nByteCounts}).&#34;.format(nOffsets=len(self.stripOffsets), nByteCounts=len(self.stripByteCounts)))
    else:
        raise Exception(&#34;No data strips found for requested subfile in {filename}.&#34;.format(filename=self.filename))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.importFromUncompressedBuffer"><code class="name flex">
<span>def <span class="ident">importFromUncompressedBuffer</span></span>(<span>self, pixelOffset, nPixels, datatype, channel, buff)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importFromUncompressedBuffer(self, pixelOffset, nPixels, datatype, channel, buff):
    if self.isPlanar():  # Buffer contains data just for one channel.
        self.px[channel][int(pixelOffset):int(pixelOffset+nPixels)] = numpy.frombuffer(buff, dtype=datatype)
    else: # CHUNKY configuration. channel is irrelevant here (and wrong.)
        bitsPerPixel = self.bitsPerPixel()
        bytesPerPixel = int(bitsPerPixel / 8)

        bytesPerSample = [x/8 for x in self.bitsPerSample]

        buff1d = numpy.frombuffer(buff, dtype=datatype)
        self.px[int(pixelOffset):int(pixelOffset+nPixels)] = numpy.reshape(buff1d, (nPixels, self.nChannels()))

        &#34;&#34;&#34;
        for pixel in range(nPixels):
            channelOffset = 0

            

            for c in range(self.samplesPerPixel):
                # Current index in bytes
                idxStart = int((pixel + pixelOffset)*bytesPerPixel + channelOffset/8)
                idxStop  = int(idxStart + bytesPerSample[c])

                #print(&#34;Start: {}, Stop: {}&#34;.format(idxStart, idxStop))

                self.px[c][pixel] = numpy.frombuffer(buff[idxStart:idxStop], dtype=dt)

                channelOffset += self.bitsPerSample[c]
        &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.isPlanar"><code class="name flex">
<span>def <span class="ident">isPlanar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isPlanar(self):
    return (self.samplesPerPixel == 1 or self.planarConfig == TIFF_PLANAR)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.isSet"><code class="name flex">
<span>def <span class="ident">isSet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if image has a valid width and height.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isSet(self):
    &#34;&#34;&#34; Check if image has a valid width and height. &#34;&#34;&#34;
    if(self.getHeight() &gt; 0):
        if(self.getWidth() &gt; 0):
            return True

    return False</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.nChannels"><code class="name flex">
<span>def <span class="ident">nChannels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nChannels(self):
    return self.samplesPerPixel</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.nPixels"><code class="name flex">
<span>def <span class="ident">nPixels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nPixels(self):
    return self.rows*self.cols</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.numpyDatatype"><code class="name flex">
<span>def <span class="ident">numpyDatatype</span></span>(<span>self, sampleFormat, bitsPerSample)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpyDatatype(self, sampleFormat, bitsPerSample):
    formatString = self.byteOrder
    if sampleFormat == TIFF_SAMPLEFORMAT_UINT:  # unsigned
        if bitsPerSample == 8:
            formatString = &#34;u1&#34;   # unsigned char (1 byte)
        elif bitsPerSample == 16:
            formatString += &#34;u2&#34;   # unsigned short (2 bytes)
        elif bitsPerSample == 32:
            formatString += &#34;u4&#34;   # unsigned long (4 bytes)
        elif bitsPerSample == 64:
            formatString += &#34;u8&#34;   # unsigned long long (8 bytes)
    elif sampleFormat == TIFF_SAMPLEFORMAT_INT:  # signed
        if bitsPerSample == 8:
            formatString = &#34;i1&#34;   # signed char (1 byte)
        elif bitsPerSample == 16:
            formatString += &#34;i2&#34;   # signed short (2 bytes)
        elif bitsPerSample == 32:
            formatString += &#34;i4&#34;   # signed long (4 bytes)
        elif bitsPerSample == 64:
            formatString += &#34;i8&#34;   # signed long long (8 bytes)
    elif sampleFormat == TIFF_SAMPLEFORMAT_IEEEFP:
        if bitsPerSample == 16:
            formatString += &#34;f2&#34;   # float 16 bit
        elif bitsPerSample == 32:
            formatString += &#34;f4&#34;   # float 32 bit
        elif bitsPerSample == 64:
            formatString += &#34;f8&#34;   # double 64 bit

    if len(formatString) &gt;= 1:
        return numpy.dtype(formatString)

    raise Exception(&#34;Unsupported data type: {bps} bits per sample for TIFF sample format {sf}.&#34;.format(bps=bitsPerSample, sf=sampleFormat))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.prepareDataOffsets"><code class="name flex">
<span>def <span class="ident">prepareDataOffsets</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepareDataOffsets(self, offset):
    if self.ifd != None:
        self.ifd.prepareDataOffsets(offset)

        offset += self.ifd.sizeInBytes()
        self.imageDataOffset = offset  # image data starts here

        self.stripOffsets    = (self.imageDataOffset, )
        self.stripByteCounts = self.dataSizeInBytes()

        offset += self.dataSizeInBytes()
        return offset
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.printOffset"><code class="name flex">
<span>def <span class="ident">printOffset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printOffset(self):
    if self.ifd != None:
        self.ifd.printOffset()

    tiffyLog(TIFFY_LOGLEVEL_INFO, &#34;  Image Data            {offset}&#34;.format(offset=self.imageDataOffset))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.readMetaInformation"><code class="name flex">
<span>def <span class="ident">readMetaInformation</span></span>(<span>self, filename, byteOrder, imgFileDirectory)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readMetaInformation(self, filename, byteOrder, imgFileDirectory):
    self.filename = filename
    self.byteOrder = byteOrder
    self.ifd = imgFileDirectory

    # Interpret IFD fields based on their TIFF tags:
    for field in self.ifd.fields:
        if field.tag == 256:  # Number of columns
            self.cols = field.getValue()
        elif field.tag == 257:  # Number of rows
            self.rows = field.getValue()
        elif field.tag == 258:  # Bits per sample
            self.bitsPerSample = field.values
        elif field.tag == 259:  # Compression
            self.compression = field.getValue()
            if self.compression == 0:
                self.compression = TIFF_NO_COMPRESSION
        elif field.tag == 262:    # Photometric interpretation
            self.photometricInterpretation = field.getValue()
        elif field.tag == 273:  # Strip offsets
            self.stripOffsets = field.values
        elif field.tag == 274:  # Orientation
            self.orientation = field.getValue()
        elif field.tag == 277:  # Samples per pixel
            self.samplesPerPixel = field.getValue()
        elif field.tag == 278:  # Rows per strip
            self.rowsPerStrip = field.getValue()
        elif field.tag == 279:  # Strip byte counts
            self.stripByteCounts = field.values
        elif field.tag == 282:  # x resolution
            self.resX = field.getValue()
        elif field.tag == 283:  # y resolution
            self.resY = field.getValue()
        elif field.tag == 284:  # Planar configuration (order of pixel components)
            self.planarConfig = field.getValue()
        elif field.tag == 296:  # Resolution unit
            self.resolutionUnit = field.getValue()
        elif field.tag == 317:  # Predictor
            self.predictor = field.getValue()
        elif field.tag == 320:  # Color map
            pass # implement later...
        elif field.tag == 339:  # Sample format
            self.sampleFormat = field.values            </code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.__init__()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.rot180"><code class="name flex">
<span>def <span class="ident">rot180</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot180(self):
    if self.isSet():
        self.px = numpy.rot90(self.px, k=2, axes=(1,2))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.rot270"><code class="name flex">
<span>def <span class="ident">rot270</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot270(self):
    if self.isSet():
        self.px = numpy.rot90(self.px, k=-1, axes=(1,2))
        self.cols, self.rows = self.rows, self.cols</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.rot90"><code class="name flex">
<span>def <span class="ident">rot90</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot90(self):
    if self.isSet():
        self.px = numpy.rot90(self.px, k=1, axes=(1,2))
        self.cols, self.rows = self.rows, self.cols</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, rotation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, rotation):
    if rotation == &#34;90&#34;:
        self.rot90()
    elif rotation == &#34;180&#34;:
        self.rot180()
    elif rotation == &#34;270&#34;:
        self.rot270()</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, imageData, resX=0, resY=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, imageData, resX=0, resY=0):
    if len(imageData) &gt; 0:
        self.reset()
        self.px = imageData

        shp = numpy.shape(self.px)  # Shape must be 3-component tuple: (nChannels, height, width)
        if len(shp) == 3:
            self.samplesPerPixel = shp[0]
            self.rows = shp[1]
            self.cols = shp[2]

            self.rowsPerStrip = self.rows
            # self.stripByteCounts and self.stripOffsets will be set later by self.prepareDataOffsets()

            # Byte order
            self.byteOrder = getByteOrder(self.px)

            # Sample format
            if numpy.issubdtype(self.px.dtype, numpy.signedinteger):
                self.sampleFormat = [TIFF_SAMPLEFORMAT_INT] * self.nChannels()
            elif numpy.issubdtype(self.px.dtype, numpy.unsignedinteger):
                self.sampleFormat = [TIFF_SAMPLEFORMAT_UINT] * self.nChannels()
            elif numpy.issubdtype(self.px.dtype, numpy.floating):
                self.sampleFormat = [TIFF_SAMPLEFORMAT_IEEEFP] * self.nChannels()
            else:
                raise Exception(&#34;Unsupported dtype ({}) of provided image data. Must be an integer or floating point type.&#34;.format(numpy.dtype(self.px)))

            self.bitsPerSample  = [self.px.dtype.itemsize*8] * self.samplesPerPixel
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Setting bits per sample: {}&#34;.format(self.bitsPerSample))
            tiffyLog(TIFFY_LOGLEVEL_DEBUG, &#34;Setting sample format:   {}&#34;.format(self.sampleFormat))

            self.resolutionUnit = TIFF_RES_NONE
            self.resX = resX
            self.resY = resY

            self.compression    = TIFF_NO_COMPRESSION

            
            self.photometricInterpretation = TIFF_BLACK_IS_ZERO
            if self.nChannels() == 3:
                self.photometricInterpretation = TIFF_RGB

            #if self.samplesPerPixel &gt; 1:
            #    self.planarConfig   = TIFF_PLANAR
            #else:
            #    self.planarConfig   = TIFF_CHUNKY
            self.planarConfig   = TIFF_CHUNKY

        else:
            raise Exception(&#34;Error setting image data. Please provide a numpy array of shape (nChannels, nRows, nColumns).&#34;)</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.setFlip"><code class="name flex">
<span>def <span class="ident">setFlip</span></span>(<span>self, horz=False, vert=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setFlip(self, horz=False, vert=False):
    self.flipHorz = horz
    self.flipVert = vert</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.setupIFD"><code class="name flex">
<span>def <span class="ident">setupIFD</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setupIFD(self):
    self.ifd = None
    self.ifd = ifd()

    self.addIFDentry_shortOrLong(256, (self.cols, ))                        # n columns
    self.addIFDentry_shortOrLong(257, (self.rows, ))                        # n rows
    self.addIFDentry(258, TIFF_SHORT, self.bitsPerSample)                   # bits per sample, already an array
    self.addIFDentry(259, TIFF_SHORT, (TIFF_NO_COMPRESSION, ))               # compression
    self.addIFDentry(262, TIFF_SHORT, (self.photometricInterpretation, ))   # photometric interpretation
    self.addIFDentry(266, TIFF_SHORT, (TIFF_MSB2LSB, ))                      # fill order 
    self.addIFDentry_shortOrLong(273, (self.imageDataOffset, ))             # offset location of strip
    self.addIFDentry(274, TIFF_SHORT, (self.orientation, ))                 # orientation
    self.addIFDentry(277, TIFF_SHORT, (self.samplesPerPixel, ))             # samples per pixel
    self.addIFDentry_shortOrLong(278, (self.rowsPerStrip, ))                # rows per strip
    self.addIFDentry_shortOrLong(279, (self.dataSizeInBytes(), ))            # strip byte counts
    # insert resolution entries here later...
    self.addIFDentry(284, TIFF_SHORT, (self.planarConfig, ))                # planar configuration
   
    #self.addIFDentry(296, TIFF_SHORT, (self.resolutionUnit, ))             # resolution unit
    
    if self.predictor != TIFF_NO_PREDICTOR:
        self.addIFDentry(317, TIFF_SHORT, (self.predictor, ))                   # predictor
    # color map
    
    self.addIFDentry(339, TIFF_SHORT, self.sampleFormat)                    # sample format, already an array</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.sizeInBytes"><code class="name flex">
<span>def <span class="ident">sizeInBytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sizeInBytes(self):
    size = 0
    if self.ifd != None:
        size += self.ifd.sizeInBytes()

    size += self.dataSizeInBytes()

    return size</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.structDataTypeString"><code class="name flex">
<span>def <span class="ident">structDataTypeString</span></span>(<span>self, sampleFormat, bitsPerSample)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structDataTypeString(self, sampleFormat, bitsPerSample):
    formatString = self.byteOrder
    if sampleFormat == TIFF_SAMPLEFORMAT_UINT:  # unsigned
        if bitsPerSample == 8:
            formatString = &#34;B&#34;   # unsigned char (1 byte)
        elif bitsPerSample == 16:
            formatString += &#34;H&#34;   # unsigned short (2 bytes)
        elif bitsPerSample == 32:
            formatString += &#34;L&#34;   # unsigned long (4 bytes)
        elif bitsPerSample == 64:
            formatString += &#34;Q&#34;   # unsigned long long (8 bytes)
    elif sampleFormat == TIFF_SAMPLEFORMAT_INT:  # signed
        if bitsPerSample == 8:
            formatString = &#34;b&#34;   # signed char (1 byte)
        elif bitsPerSample == 16:
            formatString += &#34;h&#34;   # signed short (2 bytes)
        elif bitsPerSample == 32:
            formatString += &#34;l&#34;   # signed long (4 bytes)
        elif bitsPerSample == 64:
            formatString += &#34;q&#34;   # signed long long (8 bytes)
    elif sampleFormat == TIFF_SAMPLEFORMAT_IEEEFP:
        if bitsPerSample == 16:
            formatString += &#34;e&#34;   # float 16 bit
        elif bitsPerSample == 32:
            formatString += &#34;f&#34;   # float 32 bit
        elif bitsPerSample == 64:
            formatString += &#34;d&#34;   # double 64 bit

    if len(formatString) &gt;= 1:
        return formatString

    raise Exception(&#34;Unsupported data type: {bps} bits per sample for TIFF sample format {sf}.&#34;.format(bps=bitsPerSample, sf=sampleFormat))</code></pre>
</details>
</dd>
<dt id="ctsimu.tiffy.tiffSubfile.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, f, byteOrder)</span>
</code></dt>
<dd>
<div class="desc"><p>Expects an open, writable file pointer f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, f, byteOrder):
    &#34;&#34;&#34; Expects an open, writable file pointer f. &#34;&#34;&#34;
    self.ifd.write(f, byteOrder)

    dataByteOrder = getByteOrder(self.px)
    if dataByteOrder != byteOrder:
        self.px.byteswap(inplace=True)

    # Write image data:
    if self.samplesPerPixel == 1:
        f.write(self.px)
    else:
        chunkyBytes = numpy.swapaxes(self.px, 0, 2)  # channel &lt;-&gt; cols  --&gt; (cols, rows, channel)
        chunkyBytes = numpy.swapaxes(chunkyBytes, 0, 1)  # cols &lt;-&gt; rows  --&gt; (rows, cols, channel)
        chunkyBytes.tofile(f, &#34;&#34;)

        &#34;&#34;&#34;
        dataString = []
        for c in range(self.nChannels()):
            dataString.append(self.structDataTypeString(self.sampleFormat[c], self.bitsPerSample[c]))

        for y in range(self.rows):
            for x in range(self.cols):
                # Chunky style.
                for c in range(self.nChannels()):
                    buff = struct.pack(&#34;{endian}{ds}&#34;.format(endian=byteOrder, ds=dataString[c]), self.px[c][y][x])
                    f.write(buff)
        &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://bamresearch.github.io/ctsimu-toolbox">
<img src="toolbox.png" alt=""> ctsimu
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctsimu" href="index.html">ctsimu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctsimu.tiffy.TIFFtypeStructCharacter" href="#ctsimu.tiffy.TIFFtypeStructCharacter">TIFFtypeStructCharacter</a></code></li>
<li><code><a title="ctsimu.tiffy.bytesPerTIFFtype" href="#ctsimu.tiffy.bytesPerTIFFtype">bytesPerTIFFtype</a></code></li>
<li><code><a title="ctsimu.tiffy.getByteOrder" href="#ctsimu.tiffy.getByteOrder">getByteOrder</a></code></li>
<li><code><a title="ctsimu.tiffy.tagName" href="#ctsimu.tiffy.tagName">tagName</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffyLog" href="#ctsimu.tiffy.tiffyLog">tiffyLog</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctsimu.tiffy.bits" href="#ctsimu.tiffy.bits">bits</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.tiffy.bits.byteAndBit" href="#ctsimu.tiffy.bits.byteAndBit">byteAndBit</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.getBit" href="#ctsimu.tiffy.bits.getBit">getBit</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.getBitInByte" href="#ctsimu.tiffy.bits.getBitInByte">getBitInByte</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.getInt" href="#ctsimu.tiffy.bits.getInt">getInt</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.getIntMSBtoLSB" href="#ctsimu.tiffy.bits.getIntMSBtoLSB">getIntMSBtoLSB</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.getIntMSBtoLSB_faster" href="#ctsimu.tiffy.bits.getIntMSBtoLSB_faster">getIntMSBtoLSB_faster</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.getIntMSBtoLSB_inBytes" href="#ctsimu.tiffy.bits.getIntMSBtoLSB_inBytes">getIntMSBtoLSB_inBytes</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.reverseBitsInBytes" href="#ctsimu.tiffy.bits.reverseBitsInBytes">reverseBitsInBytes</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.set" href="#ctsimu.tiffy.bits.set">set</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.setBit" href="#ctsimu.tiffy.bits.setBit">setBit</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.setBitInByte" href="#ctsimu.tiffy.bits.setBitInByte">setBitInByte</a></code></li>
<li><code><a title="ctsimu.tiffy.bits.setBytes" href="#ctsimu.tiffy.bits.setBytes">setBytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.tiffy.ifd" href="#ctsimu.tiffy.ifd">ifd</a></code></h4>
<ul class="two-column">
<li><code><a title="ctsimu.tiffy.ifd.addEntry" href="#ctsimu.tiffy.ifd.addEntry">addEntry</a></code></li>
<li><code><a title="ctsimu.tiffy.ifd.prepareDataOffsets" href="#ctsimu.tiffy.ifd.prepareDataOffsets">prepareDataOffsets</a></code></li>
<li><code><a title="ctsimu.tiffy.ifd.printOffset" href="#ctsimu.tiffy.ifd.printOffset">printOffset</a></code></li>
<li><code><a title="ctsimu.tiffy.ifd.read" href="#ctsimu.tiffy.ifd.read">read</a></code></li>
<li><code><a title="ctsimu.tiffy.ifd.sizeInBytes" href="#ctsimu.tiffy.ifd.sizeInBytes">sizeInBytes</a></code></li>
<li><code><a title="ctsimu.tiffy.ifd.write" href="#ctsimu.tiffy.ifd.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.tiffy.ifdEntry" href="#ctsimu.tiffy.ifdEntry">ifdEntry</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.tiffy.ifdEntry.getValue" href="#ctsimu.tiffy.ifdEntry.getValue">getValue</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.nValueBytes" href="#ctsimu.tiffy.ifdEntry.nValueBytes">nValueBytes</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.prepareDataOffsets" href="#ctsimu.tiffy.ifdEntry.prepareDataOffsets">prepareDataOffsets</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.printExtraDataOffset" href="#ctsimu.tiffy.ifdEntry.printExtraDataOffset">printExtraDataOffset</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.printOffset" href="#ctsimu.tiffy.ifdEntry.printOffset">printOffset</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.read" href="#ctsimu.tiffy.ifdEntry.read">read</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.set" href="#ctsimu.tiffy.ifdEntry.set">set</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.setTagID" href="#ctsimu.tiffy.ifdEntry.setTagID">setTagID</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.setType" href="#ctsimu.tiffy.ifdEntry.setType">setType</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.setValue" href="#ctsimu.tiffy.ifdEntry.setValue">setValue</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.setValues" href="#ctsimu.tiffy.ifdEntry.setValues">setValues</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.sizeInBytes" href="#ctsimu.tiffy.ifdEntry.sizeInBytes">sizeInBytes</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.sizeOfExtraValues" href="#ctsimu.tiffy.ifdEntry.sizeOfExtraValues">sizeOfExtraValues</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.write" href="#ctsimu.tiffy.ifdEntry.write">write</a></code></li>
<li><code><a title="ctsimu.tiffy.ifdEntry.writeExtraValues" href="#ctsimu.tiffy.ifdEntry.writeExtraValues">writeExtraValues</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.tiffy.lzwData" href="#ctsimu.tiffy.lzwData">lzwData</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.tiffy.lzwData.decompress" href="#ctsimu.tiffy.lzwData.decompress">decompress</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwData.getNextCode" href="#ctsimu.tiffy.lzwData.getNextCode">getNextCode</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwData.resetStringtable" href="#ctsimu.tiffy.lzwData.resetStringtable">resetStringtable</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwData.setCompressed" href="#ctsimu.tiffy.lzwData.setCompressed">setCompressed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.tiffy.lzwStringTable" href="#ctsimu.tiffy.lzwStringTable">lzwStringTable</a></code></h4>
<ul class="two-column">
<li><code><a title="ctsimu.tiffy.lzwStringTable.add" href="#ctsimu.tiffy.lzwStringTable.add">add</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwStringTable.contains" href="#ctsimu.tiffy.lzwStringTable.contains">contains</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwStringTable.currentCodeBitWidth" href="#ctsimu.tiffy.lzwStringTable.currentCodeBitWidth">currentCodeBitWidth</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwStringTable.init" href="#ctsimu.tiffy.lzwStringTable.init">init</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwStringTable.isClearCode" href="#ctsimu.tiffy.lzwStringTable.isClearCode">isClearCode</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwStringTable.isEndOfInformation" href="#ctsimu.tiffy.lzwStringTable.isEndOfInformation">isEndOfInformation</a></code></li>
<li><code><a title="ctsimu.tiffy.lzwStringTable.stringFromCode" href="#ctsimu.tiffy.lzwStringTable.stringFromCode">stringFromCode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.tiffy.tiff" href="#ctsimu.tiffy.tiff">tiff</a></code></h4>
<ul class="two-column">
<li><code><a title="ctsimu.tiffy.tiff.addImgData" href="#ctsimu.tiffy.tiff.addImgData">addImgData</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.getHeight" href="#ctsimu.tiffy.tiff.getHeight">getHeight</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.getNrSubfiles" href="#ctsimu.tiffy.tiff.getNrSubfiles">getNrSubfiles</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.getWidth" href="#ctsimu.tiffy.tiff.getWidth">getWidth</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.imageData" href="#ctsimu.tiffy.tiff.imageData">imageData</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.prepareDataOffsets" href="#ctsimu.tiffy.tiff.prepareDataOffsets">prepareDataOffsets</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.printOffset" href="#ctsimu.tiffy.tiff.printOffset">printOffset</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.read" href="#ctsimu.tiffy.tiff.read">read</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.reset" href="#ctsimu.tiffy.tiff.reset">reset</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.save" href="#ctsimu.tiffy.tiff.save">save</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.set" href="#ctsimu.tiffy.tiff.set">set</a></code></li>
<li><code><a title="ctsimu.tiffy.tiff.sizeInBytes" href="#ctsimu.tiffy.tiff.sizeInBytes">sizeInBytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ctsimu.tiffy.tiffSubfile" href="#ctsimu.tiffy.tiffSubfile">tiffSubfile</a></code></h4>
<ul class="">
<li><code><a title="ctsimu.tiffy.tiffSubfile.addIFDentry" href="#ctsimu.tiffy.tiffSubfile.addIFDentry">addIFDentry</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.addIFDentry_shortOrLong" href="#ctsimu.tiffy.tiffSubfile.addIFDentry_shortOrLong">addIFDentry_shortOrLong</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.bitsPerPixel" href="#ctsimu.tiffy.tiffSubfile.bitsPerPixel">bitsPerPixel</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.dataSizeInBytes" href="#ctsimu.tiffy.tiffSubfile.dataSizeInBytes">dataSizeInBytes</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.flip" href="#ctsimu.tiffy.tiffSubfile.flip">flip</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.flipHorizontal" href="#ctsimu.tiffy.tiffSubfile.flipHorizontal">flipHorizontal</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.flipVertical" href="#ctsimu.tiffy.tiffSubfile.flipVertical">flipVertical</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.getHeight" href="#ctsimu.tiffy.tiffSubfile.getHeight">getHeight</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.getHorizontalFlip" href="#ctsimu.tiffy.tiffSubfile.getHorizontalFlip">getHorizontalFlip</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.getVerticalFlip" href="#ctsimu.tiffy.tiffSubfile.getVerticalFlip">getVerticalFlip</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.getWidth" href="#ctsimu.tiffy.tiffSubfile.getWidth">getWidth</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.imageData" href="#ctsimu.tiffy.tiffSubfile.imageData">imageData</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.importFromUncompressedBuffer" href="#ctsimu.tiffy.tiffSubfile.importFromUncompressedBuffer">importFromUncompressedBuffer</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.isPlanar" href="#ctsimu.tiffy.tiffSubfile.isPlanar">isPlanar</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.isSet" href="#ctsimu.tiffy.tiffSubfile.isSet">isSet</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.nChannels" href="#ctsimu.tiffy.tiffSubfile.nChannels">nChannels</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.nPixels" href="#ctsimu.tiffy.tiffSubfile.nPixels">nPixels</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.numpyDatatype" href="#ctsimu.tiffy.tiffSubfile.numpyDatatype">numpyDatatype</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.prepareDataOffsets" href="#ctsimu.tiffy.tiffSubfile.prepareDataOffsets">prepareDataOffsets</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.printOffset" href="#ctsimu.tiffy.tiffSubfile.printOffset">printOffset</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.readMetaInformation" href="#ctsimu.tiffy.tiffSubfile.readMetaInformation">readMetaInformation</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.reset" href="#ctsimu.tiffy.tiffSubfile.reset">reset</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.rot180" href="#ctsimu.tiffy.tiffSubfile.rot180">rot180</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.rot270" href="#ctsimu.tiffy.tiffSubfile.rot270">rot270</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.rot90" href="#ctsimu.tiffy.tiffSubfile.rot90">rot90</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.rotate" href="#ctsimu.tiffy.tiffSubfile.rotate">rotate</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.set" href="#ctsimu.tiffy.tiffSubfile.set">set</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.setFlip" href="#ctsimu.tiffy.tiffSubfile.setFlip">setFlip</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.setupIFD" href="#ctsimu.tiffy.tiffSubfile.setupIFD">setupIFD</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.sizeInBytes" href="#ctsimu.tiffy.tiffSubfile.sizeInBytes">sizeInBytes</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.structDataTypeString" href="#ctsimu.tiffy.tiffSubfile.structDataTypeString">structDataTypeString</a></code></li>
<li><code><a title="ctsimu.tiffy.tiffSubfile.write" href="#ctsimu.tiffy.tiffSubfile.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>